<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cargo CRM - Admin</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
    .modal { display: none; position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
    .modal.is-open { display: flex; align-items: center; justify-content: center; opacity: 1; visibility: visible; transition: opacity 0.3s ease; }
    .modal-content { background-color: #fff; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); max-width: 90%; width: 800px; max-height: 90vh; overflow-y: auto; position: relative; }
    /* --- ИСПРАВЛЕННЫЙ СТИЛЬ ЛОАДЕРА --- */
#loader {
    display: none !important; /* Гарантированно скрыт изначально */
    position: fixed; left: 0; top: 0; width: 100%; height: 100%;
    background-color: rgba(255, 255, 255, 0.7);
    z-index: 2000;
    align-items: center; justify-content: center; /* Применяется только при display: flex */
}
    .loader-spinner { border: 8px solid #f3f3f3; border-top: 8px solid #4f46e5; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
</style>
</head>
<body class="bg-gray-100">
    <div id="loader"><div class="loader-spinner"></div></div>

    <div id="shift-screen" class="hidden min-h-screen flex items-center justify-center">
    <div class="max-w-md w-full bg-white p-8 rounded-lg shadow-lg">
        <h2 class="text-2xl font-bold text-center text-gray-800 mb-6">Открыть новую смену</h2>
        <form id="open-shift-form" class="space-y-4">
            <div id="shift-employee-selector" class="hidden">
                <label for="shift-employee-select" class="block text-sm font-medium text-gray-700">Выберите сотрудника</label>
                <select id="shift-employee-select" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm bg-white"></select>
            </div>
            <div id="shift-location-selector" class="hidden">
                <label for="shift-location-select" class="block text-sm font-medium text-gray-700">Выберите филиал</label>
                <select id="shift-location-select" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm bg-white"></select>
            </div>
            <div>
                <label for="shift-exchange-rate" class="block text-sm font-medium text-gray-700">Текущий курс $</label>
                <input type="number" step="0.1" id="shift-exchange-rate" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
            </div>
            <div>
                <label for="shift-price-per-kg" class="block text-sm font-medium text-gray-700">Цена за кг ($)</label>
                <input type="number" step="0.1" id="shift-price-per-kg" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
            </div>
            <div>
                <label for="starting-cash" class="block text-sm font-medium text-gray-700">Наличные в кассе (сом)</label>
                <input type="number" step="0.01" id="starting-cash" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
            </div>
            <button type="submit" class="w-full flex justify-center py-2 px-4 border rounded-md shadow-sm font-medium text-white bg-green-600 hover:bg-green-700">Начать смену</button>
             <button type="button" id="cancel-open-shift-btn" class="hidden w-full flex justify-center py-2 px-4 border rounded-md shadow-sm font-medium text-gray-700 bg-gray-200 hover:bg-gray-300 mt-2">Отмена</button>
        </form>
    </div>
</div>

    <div id="login-screen" class="min-h-screen flex items-center justify-center">
        <div class="max-w-md w-full bg-white p-8 rounded-lg shadow-lg">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-6">Вход в Cargo CRM</h2>
            <form id="login-form">
                <div class="mb-4">
                    <label for="company-code" class="block text-sm font-medium text-gray-700">Код Компании</label>
                    <input type="text" id="company-code" placeholder="Например: SUPER или VISH" required
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm uppercase">
                    <p class="text-xs text-gray-500 mt-1">Для входа как Супер-Админ, введите <b>SUPER</b>.</p>
                </div>
                <div class="mb-4">
                    <label for="password" class="block text-sm font-medium text-gray-700">Пароль</label>
                    <input type="password" id="password" required
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <button type="submit" class="w-full flex justify-center py-2 px-4 border rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700">Войти</button>
            </form>
            <p id="login-error" class="text-red-500 text-sm mt-4 text-center"></p>
        </div>
    </div>

    <div id="main-app" class="hidden">
        <div class="max-w-7xl mx-auto p-4 sm:p-6">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-3xl font-bold text-gray-800">Админ-панель</h1>
                <div class="flex items-center gap-4">
                    <div id="user-info" class="text-right"></div>
                    <div id="company-info" class="text-right border-l pl-4"></div>
                    <button id="logout-btn" title="Выйти из системы" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-3 rounded-lg text-sm">Выйти</button>
                </div>
            </div>
            <div class="border-b border-gray-200">
                <nav class="-mb-px flex space-x-8" id="tabs"></nav>
            </div>
            <div id="tab-content" class="mt-6"></div>
        </div>
    </div>

    <div id="company-modal" class="modal"><div class="modal-content w-full max-w-lg"></div></div>
    <div id="location-modal" class="modal"><div class="modal-content w-full max-w-md"></div></div>
    <div id="employee-modal" class="modal"><div class="modal-content w-full max-w-md"></div></div>
    <div id="role-modal" class="modal"><div class="modal-content w-full max-w-md"></div></div>
    <div id="permissions-modal" class="modal"><div class="modal-content w-full max-w-2xl"></div></div>

    <div id="client-tools-modal" class="modal">
    <div class="modal-content w-full max-w-lg">
        <div class="flex justify-between items-start">
            <h3 class="text-2xl font-bold mb-4">Инструменты для Клиентов</h3>
            <button onclick="closeModal('client-tools-modal')" class="text-2xl font-bold">&times;</button>
        </div>

        <div class="bg-gray-50 p-4 rounded-lg">
            <h4 class="text-lg font-semibold mb-2">Импорт клиентов из Excel</h4>
            <p class="text-sm text-gray-600 mb-1">Обязательные колонки: <strong>full_name</strong>, <strong>phone</strong>.</p>
            <p class="text-sm text-gray-600 mb-4">Необязательно: <strong>client_code</strong> (префикс+номер или только номер).</p>
            <input type="file" id="client-excel-input" accept=".xlsx, .xls" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
            <button id="import-clients-btn" class="mt-4 w-full bg-blue-600 text-white font-bold py-2 rounded-lg hover:bg-blue-700">Импортировать</button>
            <div id="client-import-results" class="mt-4 text-sm max-h-40 overflow-y-auto border p-2 bg-white rounded"></div>
        </div>

         </div>
</div>

<div id="expense-type-modal" class="modal"><div class="modal-content w-full max-w-md"></div></div>

<div id="client-modal" class="modal">
    <div class="modal-content w-full max-w-md">
        </div>
</div>

<div id="edit-order-modal" class="modal">
    <div class="modal-content w-full max-w-lg">
        </div>
</div>

<div id="buyout-modal" class="modal">
    <div class="modal-content w-full max-w-lg">
        </div>
</div>

<div id="expense-modal" class="modal">
    <div class="modal-content w-full max-w-md">
        </div>
</div>

<div id="issue-modal" class="modal">
    <div class="modal-content w-full max-w-4xl">
        </div>
</div>

<div id="issued-history-modal" class="modal">
    <div class="modal-content w-full max-w-5xl">
        </div>
</div>

<script>
// =================================================================
// МОДУЛЬ: ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И НАСТРОЙКИ (v4.1 - Rebuild)
// =================================================================
const API_URL = 'http://213.148.7.107:8000'; // URL вашего бэкенда
let currentUser = {}; // Данные вошедшего сотрудника { id, full_name, role, permissions, is_super_admin }
let currentCompany = {}; // Данные текущей компании { id, name } (null для SuperAdmin)
let activeShift = null; // Данные активной смены { id, start_time, employee_id, location_id, ... } (null если нет)

// --- Кэши данных (заполняются динамически) ---
// Эти переменные будут хранить списки объектов, загруженные с сервера,
// чтобы не запрашивать их постоянно при открытии модальных окон или рендеринге списков.
let companyLocations = []; // Список объектов Location для текущей компании
let companyRoles = []; // Список объектов Role для текущей компании
let companyPermissions = []; // Список ВСЕХ объектов Permission (глобальные)
let companyClients = []; // Список объектов Client для текущей компании
let companyOrders = []; // Список объектов Order для текущей компании (по последнему фильтру)
let orderStatuses = ["В обработке", "Ожидает выкупа", "Выкуплен", "На складе в Китае", "В пути", "На складе в КР", "Готов к выдаче", "Выдан"]; // Список строк-статусов
let availablePartyDates = []; // Список строк-дат (YYYY-MM-DD)
let companyExpenseTypes = []; // Список объектов ExpenseType для текущей компании

// --- Ссылки на основные DOM-элементы (для быстрого доступа) ---
// Ищем эти элементы ОДИН РАЗ при загрузке скрипта. Если их нет - это критическая ошибка HTML.
const loginScreen = document.getElementById('login-screen');
const mainApp = document.getElementById('main-app');
const loginForm = document.getElementById('login-form');
const loginError = document.getElementById('login-error');
const loader = document.getElementById('loader');
const tabsContainer = document.getElementById('tabs');
const tabContentContainer = document.getElementById('tab-content');

// --- Проверка наличия основных элементов ---
// Если какой-то из этих элементов отсутствует в HTML, дальнейшая работа невозможна.
if (!loginScreen || !mainApp || !loginForm || !loginError || !loader || !tabsContainer || !tabContentContainer) {
    console.error("!!! КРИТИЧЕСКАЯ ОШИБКА: Один или несколько основных элементов DOM (loginScreen, mainApp, loginForm, loginError, loader, tabs, tab-content) не найдены при загрузке скрипта. Проверьте HTML-разметку. !!!");
    // Показываем сообщение пользователю и останавливаем выполнение скрипта
    document.body.innerHTML = '<div style="padding: 20px; text-align: center; color: red; font-size: 1.2em;">Критическая ошибка загрузки интерфейса. Пожалуйста, обратитесь к администратору. Проверьте консоль браузера (F12) для деталей.</div>';
    // Можно выбросить ошибку, чтобы точно остановить скрипт:
    // throw new Error("Критические элементы DOM не найдены.");
} else {
     console.log("[Init] Основные элементы DOM найдены.");
}

// =================================================================
// МОДУЛЬ: УТИЛИТЫ (Вспомогательные функции)
// =================================================================

// Показать/Скрыть индикатор загрузки
const showLoader = () => {
    // Используем setProperty для переопределения !important в CSS, если он есть
    loader?.style.setProperty('display', 'flex', 'important');
};
const hideLoader = () => {
    loader?.style.setProperty('display', 'none', 'important');
};

// Открыть модальное окно по ID
const openModal = (modalId) => {
     const modal = document.getElementById(modalId);
     if (modal) {
          modal.classList.add('is-open');
          console.log(`[Util] Modal opened: #${modalId}`);
     } else {
          console.error(`[Util] openModal: Modal #${modalId} not found.`);
          alert(`Ошибка интерфейса: Не найдено модальное окно ${modalId}`);
     }
};

// Закрыть модальное окно по ID
const closeModal = (modalId) => {
     const modal = document.getElementById(modalId);
     if (modal) {
          modal.classList.remove('is-open');
          console.log(`[Util] Modal closed: #${modalId}`);
     } else {
          console.error(`[Util] closeModal: Modal #${modalId} not found.`);
     }
};

// Обработка ошибок API для извлечения сообщения
async function handleApiError(response) {
    try {
        // Пытаемся прочитать тело ответа как JSON
        const errorJson = await response.json();
        // Возвращаем поле 'detail' (стандарт для FastAPI) или весь JSON, если 'detail' нет
        return errorJson.detail || JSON.stringify(errorJson);
    } catch (e) {
        // Если тело не JSON или произошла другая ошибка, возвращаем статус
        console.warn(`[Util] handleApiError: Could not parse error response as JSON. Status: ${response.status}`);
        return `Статус: ${response.status} - ${response.statusText || 'Unknown Server Error'}`;
    }
}

// Общая функция для выполнения запросов к API
async function apiFetch(endpoint, options = {}) {
    // Проверка авторизации перед каждым запросом
    if (!currentUser || !currentUser.id) {
         console.error(`[API] Попытка вызова API (${endpoint}) без авторизации! Перезагрузка...`);
         alert("Ошибка авторизации. Пожалуйста, войдите снова.");
         location.reload(); // Перезагружаем страницу
         // Выбрасываем ошибку, чтобы прервать выполнение текущей операции
         throw new Error("Пользователь не авторизован");
    }

    // Установка заголовков по умолчанию (Content-Type и кастомный X-Employee-ID)
    options.headers = {
        'Content-Type': 'application/json', // Ожидаем JSON по умолчанию
        'X-Employee-ID': currentUser.id, // Идентификатор сотрудника для бэкенда
        ...options.headers // Позволяем переопределить заголовки при вызове функции
    };

    // Логируем исходящий запрос для отладки
    console.log(`[API] Request: ${options.method || 'GET'} ${endpoint}`);
    // Можно добавить логирование тела запроса (если оно есть и не слишком большое)
    // if (options.body) console.log(`[API] Request Body:`, options.body);

    try {
        // Выполняем запрос к API
        const response = await fetch(`${API_URL}${endpoint}`, options);

        // Логируем статус ответа
        console.log(`[API] Response: ${response.status} ${response.statusText} for ${options.method || 'GET'} ${endpoint}`);

        // Проверяем статус ответа: если не OK (не 2xx), выбрасываем ошибку
        if (!response.ok) {
            const errorDetails = await handleApiError(response); // Пытаемся получить детальное сообщение
            console.error(`[API] Error Response Body for ${endpoint}:`, errorDetails);
            // Выбрасываем ошибку с сообщением от сервера
            throw new Error(errorDetails);
        }

        // Обработка успешного ответа 204 No Content (тела нет)
        if (response.status === 204) {
            console.log(`[API] Received 204 No Content for ${endpoint}`);
            return null; // Возвращаем null
        }

        // Пытаемся распарсить успешный ответ как JSON
        const data = await response.json();
        // console.log(`[API] Success Response Data for ${endpoint}:`, data); // Раскомментировать для детальной отладки
        return data; // Возвращаем полученные данные

    } catch (error) {
         // Ловим ошибки сети (например, сервер недоступен) или ошибки парсинга JSON
         console.error(`[API] Network or Parsing Error for ${endpoint}:`, error);
         // Пробрасываем ошибку дальше, чтобы ее можно было поймать и обработать в вызывающей функции
         // (Например, показать пользователю сообщение "Ошибка сети")
         throw error;
    }
}


// Функция для чтения Excel файла и преобразования в JSON
// Требует подключения библиотеки XLSX в <head> вашего HTML
const readExcelFile = (file) => new Promise((resolve, reject) => {
    // Проверяем, загружена ли библиотека XLSX
    if (typeof XLSX === 'undefined') {
         console.error("!!! [Util] readExcelFile: Библиотека XLSX не найдена. Убедитесь, что она подключена в <head>.");
         return reject(new Error("Ошибка чтения файла: Библиотека XLSX не загружена."));
    }
    // Проверяем, что передан файл
    if (!file) {
         return reject(new Error("Ошибка чтения файла: Файл не выбран."));
    }

    const reader = new FileReader(); // Создаем объект для чтения файла

    // Обработчик успешного чтения файла
    reader.onload = (event) => {
        console.log("[Util] readExcelFile: Файл успешно прочитан.");
        try {
            const data = new Uint8Array(event.target.result); // Получаем данные файла как массив байт
            // Читаем книгу Excel из массива байт
            const workbook = XLSX.read(data, { type: 'array' });
            // Получаем имя первого листа
            const sheetName = workbook.SheetNames[0];
            if (!sheetName) {
                 console.error("!!! [Util] readExcelFile: В Excel файле не найдены листы.");
                 throw new Error("В Excel файле не найдены листы.");
            }
            console.log(`[Util] readExcelFile: Чтение листа "${sheetName}"...`);
            // Получаем данные первого листа
            const worksheet = workbook.Sheets[sheetName];
            // Конвертируем данные листа в массив JSON объектов
            const json = XLSX.utils.sheet_to_json(worksheet);
            console.log(`[Util] readExcelFile: Лист успешно сконвертирован в JSON (${json.length} строк).`);
            resolve(json); // Возвращаем результат (массив объектов)
        } catch (err) {
            console.error("!!! [Util] readExcelFile: Ошибка при обработке Excel данных:", err);
            reject(err); // Возвращаем ошибку обработки
        }
    };

    // Обработчик ошибки чтения файла
    reader.onerror = error => {
         console.error("!!! [Util] readExcelFile: Ошибка чтения файла:", error);
         reject(error);
    };

    // Начинаем чтение файла как ArrayBuffer
    reader.readAsArrayBuffer(file);
    console.log(`[Util] readExcelFile: Начато чтение файла "${file.name}"...`);
});

// Функция для безопасного добавления слушателя событий (с проверкой существования элемента)
// Функция для безопасного добавления слушателя событий (с проверкой существования элемента)
function safeAddEventListener(elementId, eventType, handlerFunction) {
     const element = document.getElementById(elementId);
     if (element) {
         // Удаляем предыдущий слушатель (если функция именованная), чтобы избежать дублей
         try { element.removeEventListener(eventType, handlerFunction); } catch(e){}
         // Добавляем новый слушатель СРАЗУ, так как DOM уже готов
         element.addEventListener(eventType, handlerFunction);
         console.log(`[Listener OK] Added ${eventType} to #${elementId}`);
     } else {
         console.error(`!!! Listener FAILED: Element #${elementId} not found.`);
     }
}

// =================================================================
// МОДУЛЬ: АУТЕНТИФИКАЦИЯ И ИНИЦИАЛИЗАЦИЯ (v4.1 - Rebuild)
// =================================================================

// --- Обработчик входа в систему ---
// Добавляем слушатель к форме входа, если она существует
if (loginForm) {
    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault(); // Предотвращаем стандартную отправку формы
        showLoader(); // Показываем индикатор загрузки
        if(loginError) loginError.textContent = ''; // Очищаем предыдущие ошибки

        // Получаем значения из полей формы
        const companyCodeInput = document.getElementById('company-code');
        const passwordInput = document.getElementById('password');
        const companyCode = companyCodeInput ? companyCodeInput.value.toUpperCase().trim() : null;
        const password = passwordInput ? passwordInput.value : null;

        // Простая валидация на клиенте
        if (!companyCode || !password) {
             if(loginError) loginError.textContent = "Введите код компании и пароль.";
             hideLoader(); // Скрываем лоадер
             return; // Прерываем выполнение
        }

        console.log(`[Auth] Попытка входа с кодом: ${companyCode}`);

        try {
            // Отправляем POST запрос на эндпоинт /login
            const response = await fetch(`${API_URL}/api/login`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ password: password, company_code: companyCode })
            });

            // Проверяем ответ сервера
            if (!response.ok) {
                 // Если сервер вернул ошибку, получаем текст ошибки и выбрасываем исключение
                 throw new Error(await handleApiError(response));
            }

            // Если ответ успешный, парсим JSON
            const data = await response.json();
            currentUser = data.employee; // Сохраняем данные пользователя в глоб. переменную
            currentCompany = data.company; // Сохраняем данные компании (или null для SuperAdmin)
            console.log("[Auth] Успешный вход:", currentUser, currentCompany);

            // --- Проверка необходимости открытия смены ---
            // Выполняется ТОЛЬКО для ОБЫЧНЫХ СОТРУДНИКОВ (не Владелец, не SuperAdmin)
             if (!currentUser.is_super_admin && currentUser.role !== 'Владелец') {
                  console.log("[Auth] Проверка активной смены для обычного сотрудника...");
                  await checkActiveShiftStatus(); // Проверяем статус смены на сервере (обновляет глоб. activeShift)

                  if (!activeShift) { // Если активной смены НЕТ
                       console.log("[Auth] Активной смены нет.");
                       // Проверяем, есть ли у сотрудника права на открытие смены
                       if (currentUser.permissions && currentUser.permissions.includes('open_close_shift')) {
                            // Если ПРАВА ЕСТЬ -> Показываем экран открытия смены
                            console.log("[Auth] Есть права, показываем экран открытия смены.");
                            await showOpenShiftScreen(); // Эта функция отрисует экран и добавит ЕГО слушатели
                            // ВАЖНО: НЕ продолжаем инициализацию основного приложения здесь
                            return; // Выходим из обработчика входа, т.к. показали другой экран
                       } else {
                           // Если ПРАВ НЕТ -> Показываем ошибку и прерываем вход
                           console.error("[Auth] Нет прав на открытие смены.");
                           throw new Error("Нет активной смены в вашем филиале и нет прав на ее открытие. Обратитесь к администратору.");
                       }
                  }
                   console.log("[Auth] Активная смена найдена, продолжаем вход.");
                  // Если смена ЕСТЬ - просто продолжаем выполнение кода ниже
             } else {
                  console.log("[Auth] Вход SuperAdmin или Владельца, проверка активной смены не требуется.");
                  activeShift = null; // Убеждаемся, что для них activeShift = null
             }

             // --- Инициализация основного UI и Глобальных слушателей ---
             // Этот код выполняется, если это SuperAdmin, Владелец, ИЛИ если у обычного сотрудника есть активная смена
             console.log("[Auth] Инициализация основного интерфейса...");
             await initializeMainAppUI(); // Рендерим HTML основного приложения (шапка, вкладки, контент активной вкладки)
             console.log("[Auth] Инициализация глобальных слушателей...");
             initializeGlobalEventListeners(); // Добавляем ГЛОБАЛЬНЫЕ слушатели (кнопка Выход, контейнер вкладок и т.д.)

             // Переключаем видимость экранов
             if(loginScreen) loginScreen.classList.add('hidden');
             if(mainApp) mainApp.classList.remove('hidden');
             console.log("[Auth] Переключение на основное приложение завершено.");
             // hideLoader() будет вызван в finally функции initializeMainAppUI

        } catch (error) { // Обработка ЛЮБЫХ ошибок (сеть, сервер, проверка смены, инициализация UI)
            console.error("[Auth] Ошибка входа:", error);
            if(loginError) loginError.textContent = error.message; // Показываем ошибку пользователю
            // Убеждаемся, что лоадер скрыт, если мы остались на экране входа (или если экран смены не был показан)
            const shiftScreen = document.getElementById('shift-screen');
            if (!shiftScreen || shiftScreen.classList.contains('hidden')) {
                 hideLoader();
            }
        }
    });
} else {
     // Эта ошибка не должна возникать, если основной HTML корректен
     console.error("!!! КРИТИЧЕСКАЯ ОШИБКА: Элемент login-form не найден! Вход невозможен.");
     alert("Ошибка интерфейса: Форма входа не найдена.");
     hideLoader(); // Скрываем лоадер на всякий случай
}


// --- Инициализация основного интерфейса (ТОЛЬКО рендеринг HTML) ---
// Вызывается ПОСЛЕ успешного входа (и проверки смены, если нужно)
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ initializeMainAppUI)

async function initializeMainAppUI() {
    console.log("[UI] initializeMainAppUI: Начало рендеринга UI");
    try {
        // 1. Отображаем информацию о пользователе и компании
        console.log("[UI] Отображение user/company info...");
        const userInfoDiv = document.getElementById('user-info');
        const companyInfoDiv = document.getElementById('company-info');
        const logoutBtn = document.getElementById('logout-btn');

        if (!userInfoDiv || !companyInfoDiv || !logoutBtn) {
            throw new Error("Критическая ошибка UI: Не найдены элементы шапки.");
        }

        userInfoDiv.innerHTML = `<p class="font-semibold">${currentUser.full_name || 'Имя не указано'}</p><p class="text-sm text-gray-600">${currentUser.role || 'Роль не указана'}</p>`;
        if (currentCompany && currentCompany.name) {
            companyInfoDiv.innerHTML = `<p class="font-semibold">${currentCompany.name}</p><p class="text-sm text-gray-600">Компания</p>`;
        } else if (currentUser.is_super_admin) {
            companyInfoDiv.innerHTML = `<p class="font-semibold text-purple-600">Super-Admin</p><p class="text-sm text-gray-600">Глобальный доступ</p>`;
        } else {
            companyInfoDiv.innerHTML = '';
        }

        // 2. Добавляем/обновляем контейнер для кнопки управления сменой
        console.log("[UI] Создание/обновление shiftControlDiv...");
        let shiftControlDiv = document.getElementById('shift-control-container');
        if (!shiftControlDiv) {
            shiftControlDiv = document.createElement('div');
            shiftControlDiv.id = 'shift-control-container';
            logoutBtn.parentNode?.insertBefore(shiftControlDiv, logoutBtn);
        }
        await updateShiftControlButtonUI();
        console.log("[UI] HTML кнопки смены обновлен.");

        // --- КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Предзагрузка данных (Филиалы) ---
        // Мы должны загрузить филиалы ДО того, как будем рендерить вкладки,
        // так как фильтры филиалов (на вкладках Заказы, Выдача, Отчеты) зависят от companyLocations.
        if (!currentUser.is_super_admin && (!companyLocations || companyLocations.length === 0)) {
            try {
                console.log("[UI] Предзагрузка филиалов (companyLocations)...");
                companyLocations = await apiFetch('/api/locations');
                console.log("[UI] Филиалы успешно загружены:", companyLocations.length);
            } catch (e) {
                console.error("!!! [UI] КРИТИЧЕСКАЯ ОШИБКА: Не удалось загрузить филиалы:", e.message);
                companyLocations = []; // Устанавливаем пустой массив, чтобы избежать ошибок
            }
        }
        // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

        // 3. Генерируем HTML для вкладок на основе прав пользователя
        console.log("[UI] Генерация HTML вкладок...");
        if (!tabsContainer || !tabContentContainer) throw new Error("Не найдены контейнеры вкладок.");

        let tabsHtml = '';
        let contentHtml = '';
        const userPerms = new Set(currentUser.permissions || []);

        // Определяем, какие вкладки показывать
        if (currentUser.is_super_admin) {
            if (userPerms.has('manage_companies')) { tabsHtml += '<button data-tab="companies" class="tab-btn">Управление Компаниями</button>'; contentHtml += '<div id="tab-companies" class="tab-pane"></div>'; }
        } else { // Для Владельца и других ролей
            if (userPerms.has('manage_locations')) { tabsHtml += '<button data-tab="locations" class="tab-btn">Филиалы</button>'; contentHtml += '<div id="tab-locations" class="tab-pane"></div>'; }
            if (userPerms.has('manage_employees')) { tabsHtml += '<button data-tab="employees" class="tab-btn">Персонал</button>'; contentHtml += '<div id="tab-employees" class="tab-pane"></div>'; }
            if (userPerms.has('manage_roles')) { tabsHtml += '<button data-tab="roles" class="tab-btn">Должности и Доступы</button>'; contentHtml += '<div id="tab-roles" class="tab-pane"></div>'; }
            if (userPerms.has('manage_clients')) { tabsHtml += '<button data-tab="clients" class="tab-btn">Клиенты</button>'; contentHtml += '<div id="tab-clients" class="tab-pane"></div>'; }
            if (userPerms.has('manage_orders')) { tabsHtml += '<button data-tab="orders" class="tab-btn">Заказы</button>'; contentHtml += '<div id="tab-orders" class="tab-pane"></div>'; }
            if (userPerms.has('issue_orders')) { tabsHtml += '<button data-tab="issue" class="tab-btn">Выдача</button>'; contentHtml += '<div id="tab-issue" class="tab-pane"></div>'; }
            if (userPerms.has('manage_expense_types')) { tabsHtml += '<button data-tab="expense-types" class="tab-btn">Типы Расходов</button>'; contentHtml += '<div id="tab-expense-types" class="tab-pane"></div>'; }
            if (userPerms.has('add_expense') || userPerms.has('view_full_reports')) { tabsHtml += '<button data-tab="expenses" class="tab-btn">Расходы</button>'; contentHtml += '<div id="tab-expenses" class="tab-pane"></div>'; }
            if (userPerms.has('view_shift_report') || userPerms.has('view_full_reports')) {
                tabsHtml += '<button data-tab="reports" class="tab-btn">Отчеты</button>'; 
                contentHtml += '<div id="tab-reports" class="tab-pane"></div>'; 
            }
        }
        
        tabsContainer.innerHTML = tabsHtml.replaceAll('class="tab-btn"', 'class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"'); 
        tabContentContainer.innerHTML = contentHtml;
        console.log("[UI] HTML вкладок сгенерирован и установлен.");

        // 4. Вызываем функции рендеринга (теперь companyLocations ГАРАНТИРОВАННО существует)
        console.log("[UI] Вызов функций рендеринга для доступных вкладок...");
        const renderPromises = [];
        if (document.getElementById('tab-companies')) renderPromises.push(renderCompaniesTab());
        if (document.getElementById('tab-locations')) renderPromises.push(renderLocationsTab());
        if (document.getElementById('tab-employees')) renderPromises.push(renderEmployeesTab());
        if (document.getElementById('tab-roles')) renderPromises.push(renderRolesTab());
        if (document.getElementById('tab-clients')) renderPromises.push(renderClientsTab());
        if (document.getElementById('tab-orders')) renderPromises.push(renderOrdersTab());
        if (document.getElementById('tab-issue')) renderPromises.push(renderIssueTab());
        if (document.getElementById('tab-expense-types')) renderPromises.push(renderExpenseTypesTab());
        if (document.getElementById('tab-expenses')) renderPromises.push(renderExpensesTab());
        if (document.getElementById('tab-reports')) renderPromises.push(renderReportsTab()); 
        
        await Promise.all(renderPromises); 
        console.log("[UI] Функции рендеринга вкладок завершены.");

        // 5. Активируем первую доступную вкладку
        const firstTab = tabsContainer.querySelector('.tab-btn');
        if (firstTab) {
            console.log("[UI] Активация первой вкладки:", firstTab.dataset.tab);
            activateTab(firstTab.dataset.tab);
        } else {
            console.warn("[UI] Не найдено ни одной доступной вкладки для активации.");
            if(tabContentContainer) tabContentContainer.innerHTML = '<p class="p-4 text-center text-gray-500">Нет доступных разделов.</p>';
        }

        console.log("[UI] --- initializeMainAppUI: Успешное завершение рендеринга ---");
    } catch (e) {
        console.error("[UI] !!! initializeMainAppUI: КРИТИЧЕСКАЯ ОШИБКА:", e);
        alert(`Критическая ошибка инициализации интерфейса: ${e.message}\n\nПожалуйста, обновите страницу или обратитесь к администратору.`);
    } finally {
        console.log("[UI] initializeMainAppUI: Блок finally, скрываем лоадер.");
        hideLoader();
    }
}


// --- Добавление ГЛОБАЛЬНЫХ слушателей (вызывается ПОСЛЕ initializeMainAppUI) ---
function initializeGlobalEventListeners() {
     console.log("--- initializeGlobalEventListeners: Добавление ГЛОБАЛЬНЫХ слушателей ---");

     // --- Основные элементы интерфейса (шапка, вкладки) ---
     safeAddEventListener('logout-btn', 'click', () => { if (confirm('Выйти?')) location.reload(); });
     safeAddEventListener('tabs', 'click', e => {
          const tabButton = e.target.closest('.tab-btn');
          if (tabButton) {
              // ИСПРАВЛЕНИЕ: Передаем имя вкладки как строку (dataset.tab), а не сам элемент
              activateTab(tabButton.dataset.tab); 
            }
      });

     // --- Экран открытия смены (слушатели добавляются в showOpenShiftScreen) ---

     // --- Формы и кнопки внутри СТАТИЧНЫХ Модальных Окон ---
     // (Модалки определены в HTML, их содержимое генерируется динамически)
     // Слушатели для форм добавляются в open...Modal функциях ПОСЛЕ генерации HTML формы
     safeAddEventListener('import-clients-btn', 'click', handleClientExcelImport); // Кнопка импорта в модалке Клиентов

     // --- Динамическая кнопка Открыть/Закрыть Смену ---
     // Слушатель для нее добавляется ОТДЕЛЬНО в updateShiftControlButtonUI

     console.log("--- initializeGlobalEventListeners: Добавление ГЛОБАЛЬНЫХ слушателей завершено ---");
}

// Активация вкладки (делает ее видимой и стилизует кнопку)
function activateTab(tabName) { // Функция теперь принимает tabName (строку)
    // Проверка наличия элементов (tabName теперь используется как строка)
    if (!tabName || !tabsContainer || !tabContentContainer) {
         console.error("[ActivateTab] Ошибка: tabName, tabsContainer или tabContentContainer не найдены.");
         return;
    }
    console.log(`[UI] Активация вкладки: ${tabName}`);

    // Снимаем выделение со ВСЕХ кнопок вкладок
    tabsContainer.querySelectorAll('.tab-btn').forEach(btn => {
         btn.classList.remove('border-indigo-500', 'text-indigo-600'); // Убираем активные классы
         btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
    });

    // Находим НАЖАТУЮ кнопку по data-tab
    const activeTabButton = tabsContainer.querySelector(`[data-tab="${tabName}"]`);
    
    if(activeTabButton) {
        // Выделяем НАЖАТУЮ кнопку
        activeTabButton.classList.add('border-indigo-500', 'text-indigo-600'); // Добавляем активные классы
        activeTabButton.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
    }
    
    // Скрываем ВСЕ панели с контентом вкладок
    tabContentContainer.querySelectorAll('.tab-pane').forEach(pane => {
         pane.classList.add('hidden');
    });

    // Находим и ПОКАЗЫВАЕМ панель, соответствующую нажатой кнопке
    const activePane = document.getElementById(`tab-${tabName}`);
    if (activePane) {
         activePane.classList.remove('hidden'); // Убираем класс 'hidden'
         console.log(`[UI] Вкладка ${tabName} показана.`);
    } else {
         console.warn(`[UI] Контейнер для вкладки tab-${tabName} не найден.`);
         if (tabContentContainer) { // Показываем сообщение об ошибке в общем контейнере
              tabContentContainer.innerHTML = `<p class="p-4 text-center text-red-500">Ошибка: Контент для вкладки '${tabName}' не найден.</p>`;
         }
    }
}

// =================================================================
// МОДУЛЬ: КАССА И СМЕНЫ (v4.1 - Rebuild)
// =================================================================

// --- Функция проверки статуса активной смены на сервере ---
// Обновляет глобальную переменную `activeShift`
async function checkActiveShiftStatus() {
     activeShift = null; // Сбрасываем перед проверкой
     // Не проверяем для Владельца или SuperAdmin
     if (!currentUser || currentUser.is_super_admin || currentUser.role === 'Владелец') {
          console.log("[Shift Check] Проверка смены не требуется для Владельца/SuperAdmin.");
          return;
     }

     console.log("[Shift Check] Запрос активной смены для сотрудника ID:", currentUser.id);
     try {
         // Запрашиваем активную смену для текущего сотрудника (бэкенд проверит филиал)
         const shiftData = await apiFetch('/api/shifts/active'); // Ожидаем объект смены или null
         activeShift = shiftData; // Сохраняем результат (может быть null)
         console.log("[Shift Check] Результат проверки:", activeShift);
     } catch (error) {
          // Ошибки сети или если бэкенд вернул 4xx/5xx (кроме 404, которую apiFetch обработает как null?)
          console.warn("[Shift Check] Не удалось получить активную смену:", error.message);
          activeShift = null; // Считаем, что смены нет
     }
}

// --- Функция отображения экрана "Открыть новую смену" ---
// Вызывается, если у обычного сотрудника нет активной смены, но есть права
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ showOpenShiftScreen)

async function showOpenShiftScreen(locationId = null) {
    console.log(`[Shift UI] Показ экрана открытия смены. Целевой филиал: ${locationId || 'Не указан'}`);
    const shiftScreen = document.getElementById('shift-screen');
    const form = document.getElementById('open-shift-form');
    const employeeSelectorDiv = document.getElementById('shift-employee-selector');
    const locationSelectorDiv = document.getElementById('shift-location-selector');
    const employeeSelect = document.getElementById('shift-employee-select');
    const locationSelect = document.getElementById('shift-location-select');
    const cancelBtn = document.getElementById('cancel-open-shift-btn');

    // Проверка наличия элементов
    if (!shiftScreen || !form || !employeeSelectorDiv || !locationSelectorDiv || !employeeSelect || !locationSelect || !cancelBtn) {
        console.error("!!! КРИТИЧЕСКАЯ ОШИБКА UI: Отсутствуют элементы на экране открытия смены.");
        alert("Ошибка интерфейса: Не удалось загрузить экран открытия смены.");
        hideLoader(); 
        return;
    }

    try {
        // --- Предзаполнение полей формы (Курсы, Цена) ---
        const exchangeRateInput = document.getElementById('shift-exchange-rate');
        const pricePerKgInput = document.getElementById('shift-price-per-kg');
        const startingCashInput = document.getElementById('starting-cash');
        
        // Безопасный доступ к sysConfig
        const defaultRate = activeShift?.exchange_rate_usd 
                            || (typeof sysConfig !== 'undefined' && sysConfig.exchange_rate_usd) 
                            || 87.5;
        const defaultPrice = activeShift?.price_per_kg_usd 
                             || (typeof sysConfig !== 'undefined' && sysConfig.price_per_kg_usd) 
                             || 5.5;

        if(exchangeRateInput) exchangeRateInput.value = defaultRate; 
        if(pricePerKgInput) pricePerKgInput.value = defaultPrice;   
        if(startingCashInput) startingCashInput.value = 0;

        // --- Настройка видимости селекторов в зависимости от РОЛИ ---
        
        if (currentUser.role === 'Владелец') {
            // --- ЛОГИКА ДЛЯ ВЛАДЕЛЬЦА ---
            console.log("[Shift UI] Пользователь - Владелец. Загрузка сотрудников и филиалов...");
            
            // Убеждаемся, что кэши загружены
            if (!companyLocations || companyLocations.length === 0) {
                 companyLocations = await apiFetch('/api/locations');
            }
            const employees = await apiFetch('/api/employees'); 

            // Заполняем селектор сотрудников
            if (employeeSelect) {
                employeeSelect.innerHTML = employees
                    .filter(emp => emp.is_active) 
                    .map(emp => `<option value="${emp.id}">${emp.full_name} (${emp.role?.name || '?'})</option>`)
                    .join('');
                // Выбираем Владельца по умолчанию
                employeeSelect.value = currentUser.id; 
            }
            employeeSelectorDiv.classList.remove('hidden'); 
            employeeSelect.required = true; 

            // Заполняем селектор филиалов
            if (locationSelect) {
                 locationSelect.innerHTML = companyLocations
                    .map(loc => `<option value="${loc.id}">${loc.name}</option>`)
                    .join('');
                 
                 // --- КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: ВЫБОР ФИЛИАЛА ---
                 // Если Владелец нажал кнопку в шапке (locationId=null), используем его филиал.
                 // Если Владелец нажал кнопку в списке (locationId=6), используем этот ID.
                 locationSelect.value = locationId || currentUser.location_id; 
                 // --- КОНЕЦ ИСПРАВЛЕНИЯ ---
            }
            
            // Показываем селектор филиалов, только если их больше одного
            if (companyLocations.length > 1) {
                locationSelectorDiv.classList.remove('hidden');
                locationSelect.required = true; 
            } else {
                 locationSelectorDiv.classList.add('hidden');
                 locationSelect.required = false; 
            }
            
            cancelBtn.classList.remove('hidden'); 
            console.log("[Shift UI] Селекторы для Владельца настроены.");

        } else { 
            // --- ЛОГИКА ДЛЯ ОБЫЧНОГО СОТРУДНИКА ---
            console.log("[Shift UI] Пользователь - обычный сотрудник. Скрытие селекторов.");
            
            employeeSelectorDiv.classList.add('hidden');
            locationSelectorDiv.classList.add('hidden');
            employeeSelect.required = false; 
            locationSelect.required = false;

            cancelBtn.classList.add('hidden'); 
        }

        // --- Добавляем слушатели к элементам этого экрана ---
        const currentForm = document.getElementById('open-shift-form');
        if (currentForm) {
             const newForm = currentForm.cloneNode(true);
             currentForm.parentNode.replaceChild(newForm, currentForm);
             newForm.addEventListener('submit', handleOpenShiftSubmit);
             console.log("[Shift UI Listener OK] Added submit to #open-shift-form");
        }
        
        const currentCancelBtn = document.getElementById('cancel-open-shift-btn');
        if (currentCancelBtn) {
             const newCancelBtn = currentCancelBtn.cloneNode(true);
             currentCancelBtn.parentNode.replaceChild(newCancelBtn, currentCancelBtn);
             newCancelBtn.addEventListener('click', () => {
                 console.log("[Shift UI] Cancel button clicked.");
                 if(shiftScreen) shiftScreen.classList.add('hidden');
                 // Если отменяем, возвращаемся в Главное приложение (для Владельца)
                 if(mainApp) mainApp.classList.remove('hidden'); 
                 hideLoader();
             });
             console.log("[Shift UI Listener OK] Added click to #cancel-open-shift-btn");
        }

        // Показываем экран открытия смены
        if(loginScreen) loginScreen.classList.add('hidden');
        if(mainApp) mainApp.classList.add('hidden'); 
        if(shiftScreen) shiftScreen.classList.remove('hidden');
        console.log("[Shift UI] Экран открытия смены показан.");

    } catch (error) {
         console.error("[Shift UI] Ошибка подготовки экрана открытия смены:", error);
         alert(`Ошибка подготовки экрана открытия смены: ${error.message}`);
         if(shiftScreen) shiftScreen.classList.add('hidden');
         if(loginScreen) loginScreen.classList.remove('hidden');
    } finally {
         hideLoader(); 
         console.log("[Shift UI] showOpenShiftScreen: End");
    }
}


// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ handleOpenShiftSubmit)

async function handleOpenShiftSubmit(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Shift Action] handleOpenShiftSubmit: Start");
    showLoader(); // Показываем лоадер

    let employeeIdToOpen = currentUser.id; 
    let locationIdToOpen = currentUser.location_id; 

    // --- ИСПРАВЛЕННАЯ ЛОГИКА: Определение ID сотрудника и филиала (для Владельца) ---
    if (currentUser.role === 'Владелец') {
        const employeeSelect = document.getElementById('shift-employee-select');
        const locationSelect = document.getElementById('shift-location-select');
        
        // Владелец ВСЕГДА выбирает сотрудника из списка
        if (employeeSelect) {
            employeeIdToOpen = parseInt(employeeSelect.value);
            console.log("[Shift Action] Владелец выбрал сотрудника:", employeeIdToOpen);
        } else {
            // Если селектора нет, используем Владельца (запасной вариант)
            employeeIdToOpen = currentUser.id;
        }

        // Владелец ВСЕГДА выбирает филиал из списка
        if (locationSelect) {
            locationIdToOpen = parseInt(locationSelect.value);
            console.log("[Shift Action] Владелец выбрал филиал:", locationIdToOpen);
        } else {
             // Если селектора нет (например, только 1 филиал в компании)
             if (companyLocations && companyLocations.length === 1) {
                 locationIdToOpen = companyLocations[0].id;
             } else {
                 locationIdToOpen = currentUser.location_id; // Запасной вариант
             }
        }
    }
    // Для обычного сотрудника ID остаются currentUser.id и currentUser.location_id
    // --- КОНЕЦ ИСПРАВЛЕННОЙ ЛОГИКИ ---

    if (!locationIdToOpen) {
        hideLoader();
        console.error("[Shift Action] Ошибка: Не удалось определить ID филиала для открытия смены.");
        alert("Критическая ошибка: Не удалось определить филиал для открытия смены.");
        return;
    }
    
    // Собираем данные из формы
    const startingCashInput = document.getElementById('starting-cash');
    const exchangeRateInput = document.getElementById('shift-exchange-rate');
    const pricePerKgInput = document.getElementById('shift-price-per-kg');

    const payload = {
        employee_id: employeeIdToOpen,
        location_id: locationIdToOpen, // <-- Теперь здесь будет ID выбранного филиала
        starting_cash: startingCashInput ? parseFloat(startingCashInput.value) : 0,
        exchange_rate_usd: exchangeRateInput ? parseFloat(exchangeRateInput.value) : 0,
        price_per_kg_usd: pricePerKgInput ? parseFloat(pricePerKgInput.value) : 0
    };

    // Валидация данных
     if (isNaN(payload.starting_cash) || payload.starting_cash < 0 ||
         isNaN(payload.exchange_rate_usd) || payload.exchange_rate_usd <= 0 ||
         isNaN(payload.price_per_kg_usd) || payload.price_per_kg_usd <= 0) {
           hideLoader();
           alert("Ошибка: Пожалуйста, введите корректные числовые значения.");
           return;
     }

    console.log("[Shift Action] Отправка запроса на открытие смены:", payload);

    try {
        // Отправляем запрос на бэкенд для открытия смены
        const newShift = await apiFetch('/api/shifts/open', {
            method: 'POST',
            body: JSON.stringify(payload)
        });
        
        // ВАЖНО: Бэкенд (main.py, функция open_shift) УЖЕ ИМЕЕТ проверку, 
        // что в ЦЕЛЕВОМ филиале (payload.location_id) нет открытой смены.
        // Поэтому, если вы выберете "Главный филиал", вы получите ошибку (это ПРАВИЛЬНО).
        // Если вы выберете "WishKargo" (где смены нет), бэкенд ее откроет.

        activeShift = newShift; // Сохраняем данные новой активной смены
        console.log("[Shift Action] Смена успешно открыта:", activeShift);
        
        // 1. Переключаем видимость экранов
        const shiftScreen = document.getElementById('shift-screen');
        if(shiftScreen) shiftScreen.classList.add('hidden');
        if(mainApp) mainApp.classList.remove('hidden');
        console.log("[Shift Action] Переход в основное приложение.");

        // 2. СНАЧАЛА инициализируем HTML главного приложения
        await initializeMainAppUI(); 
        
        // 3. ТЕПЕРЬ обновляем кнопку смены
        // (Мы должны убедиться, что get_active_shift вернет смену Владельца, если он ее открыл)
        await updateShiftControlButtonUI(); 

        // 4. Инициализируем ГЛОБАЛЬНЫЕ слушатели
        initializeGlobalEventListeners(); 
        
    } catch (err) { // Обработка ошибок (включая "смена уже открыта")
         console.error("[Shift Action] Ошибка открытия смены:", err);
         alert(`Ошибка открытия смены: ${err.message}`);
         hideLoader(); // Скрываем лоадер при ошибке
    }
     console.log("[Shift Action] handleOpenShiftSubmit: End");
}

// --- Обновление HTML кнопки управления сменой (без добавления слушателя здесь) ---
// Вызывается из initializeMainAppUI
async function updateShiftControlButtonUI() {
     console.log("[Shift Button UI] updateShiftControlButtonUI: Start");
     const container = document.getElementById('shift-control-container');
     if (!container) {
          console.warn("[Shift Button UI] Контейнер #shift-control-container не найден.");
          return; // Выходим, если контейнера нет
     }
     // Для SuperAdmin кнопка не нужна
     if (!currentUser || currentUser.is_super_admin) {
          container.innerHTML = ''; // Очищаем контейнер
          console.log("[Shift Button UI] SuperAdmin, кнопка не нужна.");
          return;
     }

     container.innerHTML = 'Проверка смены...'; // Временный текст

     // Проверяем статус смены ТОЛЬКО если это НЕ Владелец
     if (currentUser.role !== 'Владелец') {
          await checkActiveShiftStatus(); // Обновляем global activeShift
     } else {
          activeShift = null; // Для Владельца смены нет
          console.log("[Shift Button UI] Пользователь - Владелец, activeShift сброшен в null.");
     }


     let buttonHtml = '';
     const buttonId = 'shift-action-btn'; // ID для кнопки

     // Определяем, какой HTML показать
     if (activeShift && currentUser.id === activeShift.employee_id) {
          // Если смена активна И это смена ТЕКУЩЕГО сотрудника -> Кнопка "Закрыть"
          console.log("[Shift Button UI] Смена активна (текущего сотрудника), генерируем 'Закрыть'.");
          buttonHtml = `<button id="${buttonId}" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg text-sm animate-pulse">Закрыть смену #${activeShift.id}</button>`;
     } else if (!activeShift && currentUser.permissions?.includes('open_close_shift')) {
           // Если смены НЕТ И есть ПРАВА на открытие -> Кнопка "Открыть"
           console.log("[Shift Button UI] Смена закрыта, есть права, генерируем 'Открыть'.");
           buttonHtml = `<button id="${buttonId}" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg text-sm">Открыть смену</button>`;
     } else if (activeShift && currentUser.role === 'Владелец'){
          // Если Владелец видит активную смену ДРУГОГО сотрудника -> Показываем инфо
          console.log("[Shift Button UI] Владелец видит активную смену другого сотрудника (ID:", activeShift.id, ")");
          // TODO: Получить имя сотрудника смены?
           buttonHtml = `<span class="text-sm text-yellow-600 font-semibold" title="Смена ID ${activeShift.id} активна">Смена активна</span>`;
           // TODO: Может Владелец должен иметь возможность принудительно закрыть чужую смену?
     } else { // Смена закрыта и нет прав ИЛИ смена открыта другим (не владельцем)
          console.log("[Shift Button UI] Смена закрыта (нет прав) или открыта другим.");
          buttonHtml = `<span class="text-sm text-red-600 font-semibold">Смена закрыта</span>`;
     }

     // Устанавливаем HTML
     container.innerHTML = buttonHtml;
     console.log("[Shift Button UI] HTML кнопки обновлен.");

     // --- Добавляем слушатель к ТОЛЬКО ЧТО созданной кнопке (если она есть) ---
     const actionButton = document.getElementById(buttonId);
     if (actionButton) {
          let listenerFunc = null;
          if (activeShift && currentUser.id === activeShift.employee_id) {
               listenerFunc = handleCloseShiftClick; // Функция закрытия
          } else if (!activeShift && currentUser.permissions?.includes('open_close_shift')) {
               listenerFunc = () => { // Функция открытия (показ экрана)
                   console.log("[Shift Button UI] Клик по кнопке 'Открыть смену'");
                   if(mainApp) mainApp.classList.add('hidden');
                   showOpenShiftScreen(); // Показываем экран открытия
               };
          }

          if (listenerFunc) {
               // Удаляем старый слушатель перед добавлением нового
               actionButton.replaceWith(actionButton.cloneNode(true));
               document.getElementById(buttonId)?.addEventListener('click', listenerFunc);
               console.log(`[Shift Button Listener OK] Added click to #${buttonId}`);
          }
     } else {
          console.log(`[Shift Button UI] Кнопка #${buttonId} не найдена или для нее не нужен слушатель.`);
     }
     console.log("[Shift Button UI] updateShiftControlButtonUI: End");
}


// --- Обработчик нажатия кнопки "Закрыть смену" ---
async function handleCloseShiftClick() {
     if (!activeShift) {
          console.warn("[Shift Action] Попытка закрыть смену, но activeShift is null.");
          alert("Ошибка: Не найдена активная смена для закрытия.");
          await updateShiftControlButtonUI(); // Обновим кнопку на всякий случай
          return;
     }
     console.log(`[Shift Action] handleCloseShiftClick: Start closing shift ID ${activeShift.id}`);

     // Запрашиваем сумму наличных в кассе
     const closingCashStr = prompt(`Закрытие смены #${activeShift.id}.\nВведите итоговую сумму НАЛИЧНЫХ в кассе (сом):`);
     // Проверяем, нажал ли пользователь Отмена
     if (closingCashStr === null) {
         console.log("[Shift Action] Закрытие смены отменено пользователем.");
         return; // Выходим, если Отмена
     }

     // Проверяем введенное значение
     const closingCash = parseFloat(closingCashStr);
     if (isNaN(closingCash) || closingCash < 0) {
         alert("Некорректная сумма. Введите положительное число.");
         return; // Выходим, если сумма некорректна
     }

     console.log(`[Shift Action] Введена сумма закрытия: ${closingCash}`);
     showLoader(); // Показываем лоадер перед запросом

     try {
         // Отправляем запрос на бэкенд для закрытия смены
         await apiFetch('/api/shifts/close', {
             method: 'POST',
             body: JSON.stringify({ closing_cash: closingCash }) // Отправляем сумму
         });
         console.log(`[Shift Action] Смена #${activeShift.id} успешно закрыта на сервере.`);
         alert(`Смена #${activeShift.id} успешно закрыта!`);
         activeShift = null; // Сбрасываем глобальную переменную

         // Перезагружаем страницу, чтобы пользователь вышел из системы
         console.log("[Shift Action] Перезагрузка страницы...");
         location.reload();

     } catch (err) { // Обработка ошибок от apiFetch
         console.error("[Shift Action] Ошибка закрытия смены:", err);
         alert(`Ошибка закрытия смены: ${err.message}`);
         hideLoader(); // Скрываем лоадер только при ошибке (при успехе страница перезагрузится)
     }
     // При успехе hideLoader не нужен, т.к. страница перезагружается
     console.log("[Shift Action] handleCloseShiftClick: End");
}

// =================================================================
// МОДУЛЬ: ТИПЫ РАСХОДОВ (Владелец) (v4.1 - Rebuild)
// =================================================================
companyExpenseTypes = []; // Кэш для хранения списка типов расходов

// --- Рендеринг вкладки "Типы Расходов" ---
// Вызывается из initializeMainAppUI, если у пользователя есть права
async function renderExpenseTypesTab() {
    console.log("[Render] renderExpenseTypesTab: Start");
    const pane = document.getElementById('tab-expense-types');
    if (!pane) {
        console.warn("[Render] renderExpenseTypesTab: Pane #tab-expense-types not found.");
        return; // Выходим, если контейнер вкладки не найден
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-1">
                <div class="bg-white p-6 rounded-lg shadow-md h-fit">
                    <h2 class="text-xl font-semibold mb-4">Добавить Тип Расхода</h2>
                    <form id="add-expense-type-form" class="space-y-3">
                        <label for="new-expense-type-name" class="block text-sm font-medium text-gray-700">Название</label>
                        <input type="text" id="new-expense-type-name" placeholder="Например: Аренда, Канцтовары" class="w-full p-2 border rounded" required>
                        <button type="submit" class="w-full bg-indigo-600 text-white font-bold py-2 rounded-lg hover:bg-indigo-700">Создать Тип</button>
                    </form>
                </div>
            </div>
            <div class="md:col-span-2">
                 <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Существующие Типы Расходов</h2>
                    <div id="expense-types-list" class="space-y-3">Загрузка типов...</div>
                </div>
            </div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addForm = document.getElementById('add-expense-type-form');
    const typeListDiv = document.getElementById('expense-types-list');

    if (addForm) {
        // Удаляем старый слушатель перед добавлением нового
        addForm.replaceWith(addForm.cloneNode(true));
        document.getElementById('add-expense-type-form').addEventListener('submit', handleAddExpenseType);
        console.log("[Listener OK] Added submit to #add-expense-type-form");
    } else {
        console.error("!!! renderExpenseTypesTab: Element #add-expense-type-form NOT FOUND after innerHTML.");
    }

    if (typeListDiv) {
         // Используем делегирование событий для кнопок внутри списка
         typeListDiv.replaceWith(typeListDiv.cloneNode(true)); // Удаляем старые
         document.getElementById('expense-types-list').addEventListener('click', handleExpenseTypeActions);
         console.log("[Listener OK] Added click listener to #expense-types-list");
    } else {
         console.error("!!! renderExpenseTypesTab: Element #expense-types-list NOT FOUND after innerHTML.");
    }
    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные
    await fetchAndRenderExpenseTypes();
    console.log("[Render] renderExpenseTypesTab: End");
}

// --- Загрузка и отображение списка Типов Расходов ---
async function fetchAndRenderExpenseTypes() {
     console.log("[Fetch] fetchAndRenderExpenseTypes: Start");
     const listDiv = document.getElementById('expense-types-list');
     if (!listDiv) return; // Проверка на случай, если элемент исчез
     listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка типов расходов...</p>'; // Улучшенная заглушка
     // Не показываем глобальный лоадер здесь, т.к. загрузка обычно быстрая
     // showLoader();
     try {
         // Запрашиваем типы расходов для текущей компании
         const types = await apiFetch('/api/expense_types');
         companyExpenseTypes = types; // Обновляем кэш

         if (!types || types.length === 0) {
             listDiv.innerHTML = '<p class="text-gray-500">У вашей компании еще нет типов расходов. Создайте первый!</p>';
         } else {
             // Отображаем список с кнопками Редактировать/Удалить
             listDiv.innerHTML = types.map(t => `
                 <div class="p-3 bg-gray-50 rounded-md flex flex-wrap justify-between items-center gap-2">
                     <p class="font-bold flex-grow">${t.name}</p>
                     <div class="flex-shrink-0 flex gap-2">
                        <button data-type-id="${t.id}" data-type-name="${t.name}" class="edit-expense-type-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">Изменить</button>
                        <button data-type-id="${t.id}" data-type-name="${t.name}" class="delete-expense-type-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">Удалить</button>
                     </div>
                 </div>
             `).join('');
         }
         console.log("[Fetch] fetchAndRenderExpenseTypes: Success");
     } catch (e) {
         console.error("[Fetch] fetchAndRenderExpenseTypes: Error", e);
         listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки типов расходов: ${e.message}</p>`;
     } finally {
         // hideLoader();
     }
}

// --- Обработчик для формы "Добавить Тип Расхода" ---
async function handleAddExpenseType(e) {
    e.preventDefault(); // Предотвращаем перезагрузку
    console.log("[Expense Type Action] handleAddExpenseType: Start");
    const nameInput = document.getElementById('new-expense-type-name');
    const name = nameInput ? nameInput.value.trim() : null;

    if (!name) {
        alert("Введите название типа расхода.");
        return;
    }
    showLoader(); // Показываем лоадер перед запросом
    try {
        // Отправляем POST запрос на создание
        await apiFetch('/api/expense_types', {
             method: 'POST',
             body: JSON.stringify({ name: name })
        });
        alert(`Тип расхода "${name}" успешно создан.`);
        if(nameInput) nameInput.value = ''; // Очищаем поле ввода
        await fetchAndRenderExpenseTypes(); // Обновляем список на странице
    } catch(err) {
        console.error("[Expense Type Action] handleAddExpenseType: Error", err);
        alert(`Ошибка создания типа расхода: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Expense Type Action] handleAddExpenseType: End");
    }
}

// --- Обработчик кликов по кнопкам в списке Типов Расходов (делегирование) ---
function handleExpenseTypeActions(e) {
     // Ищем ближайшую кнопку к месту клика
     const btn = e.target.closest('button');
     if (!btn) return; // Клик не по кнопке

     const typeId = btn.dataset.typeId;
     const typeName = btn.dataset.typeName;

     // Определяем действие по классу кнопки
     if (btn.classList.contains('edit-expense-type-btn')) {
          console.log(`[Expense Type Action] Edit button clicked for ID: ${typeId}`);
          // Находим данные типа в кэше
          const currentType = companyExpenseTypes.find(t => t.id == typeId); // Используем '==' для сравнения строки и числа
          if (currentType) {
               openExpenseTypeModal(currentType); // Открываем модальное окно для редактирования
          } else {
               console.error(`!!! Edit Expense Type: Type with ID ${typeId} not found in cache.`);
               alert("Ошибка: Не удалось найти данные для редактирования.");
          }
     } else if (btn.classList.contains('delete-expense-type-btn')) {
          console.log(`[Expense Type Action] Delete button clicked for ID: ${typeId}`);
          // Запрашиваем подтверждение перед удалением
          if (confirm(`Вы уверены, что хотите удалить тип расхода "${typeName}"?\n\nЭто действие необратимо.`)) {
               handleDeleteExpenseType(typeId, typeName); // Вызываем функцию удаления
          }
     }
}

// --- Открытие модального окна для Типа Расхода ---
function openExpenseTypeModal(expenseType = null) {
     console.log("[Modal] openExpenseTypeModal: Start", expenseType);
     const modal = document.getElementById('expense-type-modal');
     if (!modal) return console.error("!!! openExpenseTypeModal: Modal element #expense-type-modal not found!");
     const modalContent = modal.querySelector('.modal-content');
     if (!modalContent) return console.error("!!! openExpenseTypeModal: Modal content not found!");

     const isEdit = expenseType !== null;

     // Генерируем HTML для модального окна
     modalContent.innerHTML = `
         <div class="flex justify-between items-start">
             <h3 class="text-2xl font-bold mb-4">${isEdit ? 'Редактировать Тип Расхода' : 'Создать Тип Расхода'}</h3>
             <button onclick="closeModal('expense-type-modal')" class="text-2xl font-bold">&times;</button>
         </div>
         <form id="expense-type-form-inner" data-type-id="${isEdit ? expenseType.id : ''}" class="space-y-4">
             <div>
                 <label for="modal-expense-type-name" class="block text-sm font-medium text-gray-700">Название *</label>
                 <input type="text" id="modal-expense-type-name" value="${isEdit ? expenseType.name : ''}" class="mt-1 w-full p-2 border rounded" required>
             </div>
             <div class="flex gap-4 mt-6 border-t pt-4">
                 <button type="button" onclick="closeModal('expense-type-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300">Отмена</button>
                 <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
             </div>
         </form>
     `;

     // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
     const formElement = document.getElementById('expense-type-form-inner');
     if (formElement) {
         formElement.replaceWith(formElement.cloneNode(true)); // Удаляем старые слушатели
         document.getElementById('expense-type-form-inner').addEventListener('submit', handleSaveExpenseType);
         console.log("[Modal Listener OK] Added submit to #expense-type-form-inner");
     } else {
         console.error("!!! openExpenseTypeModal: Form #expense-type-form-inner NOT FOUND after innerHTML!");
     }
     // --- Конец добавления слушателя ---

     openModal('expense-type-modal'); // Открываем модальное окно
     console.log("[Modal] openExpenseTypeModal: End");
 }

// --- Сохранение данных Типа Расхода ---
async function handleSaveExpenseType(e) {
     e.preventDefault();
     console.log("[Save] handleSaveExpenseType: Start");
     showLoader();
     const form = e.target;
     const typeId = form.dataset.typeId;
     const isEdit = !!typeId;
     const nameInput = document.getElementById('modal-expense-type-name');
     const name = nameInput ? nameInput.value.trim() : null;

     if (!name) {
         hideLoader();
         alert("Название типа расхода не может быть пустым.");
         return;
     }

     const url = isEdit ? `/expense_types/${typeId}` : '/expense_types';
     const method = isEdit ? 'PATCH' : 'POST';
     const payload = { name: name };

     try {
         console.log(`[Save] handleSaveExpenseType: Sending ${method} to ${url}`, payload);
         await apiFetch(url, { method: method, body: JSON.stringify(payload) });
         alert(isEdit ? 'Тип расхода успешно обновлен!' : 'Тип расхода успешно создан!');
         closeModal('expense-type-modal');
         await fetchAndRenderExpenseTypes(); // Обновляем список
     } catch (err) {
         console.error("[Save] handleSaveExpenseType: Error", err);
         alert(`Ошибка сохранения типа расхода: ${err.message}`);
     } finally {
         hideLoader();
         console.log("[Save] handleSaveExpenseType: End");
     }
 }

// --- Удаление Типа Расхода ---
async function handleDeleteExpenseType(typeId, typeName) {
    console.log(`[Delete] handleDeleteExpenseType: Start deleting ID ${typeId} (${typeName})`);
    showLoader();
    try {
        // Отправляем DELETE запрос на бэкенд
        await apiFetch(`/api/expense_types/${typeId}`, { method: 'DELETE' });
        alert(`Тип расхода "${typeName}" успешно удален.`);
        await fetchAndRenderExpenseTypes(); // Обновляем список
    } catch(err) {
        console.error("[Delete] handleDeleteExpenseType: Error", err);
        // Бэкенд вернет ошибку (400), если тип используется, apiFetch ее обработает
        alert(`Ошибка удаления типа расхода: ${err.message}`);
    } finally {
        hideLoader();
        console.log("[Delete] handleDeleteExpenseType: End");
    }
}

// =================================================================
// МОДУЛЬ: УПРАВЛЕНИЕ КОМПАНИЯМИ (Super-Admin) (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг вкладки "Управление Компаниями" ---
// Вызывается из initializeMainAppUI, если пользователь SuperAdmin и имеет права
async function renderCompaniesTab() {
    console.log("[Render] renderCompaniesTab: Start");
    const pane = document.getElementById('tab-companies');
    if (!pane) {
         console.warn("[Render] renderCompaniesTab: Pane #tab-companies not found.");
         return; // Выходим, если контейнер вкладки не найден
    }

    // Генерируем HTML для вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4">
                <h2 class="text-2xl font-bold">Управление Компаниями-Арендаторами</h2>
                <button id="add-company-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">➕ Добавить Компанию</button>
            </div>
            <div id="companies-list" class="space-y-3">Загрузка списка компаний...</div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addBtn = document.getElementById('add-company-btn');
    const companyListDiv = document.getElementById('companies-list');

    if (addBtn) {
        // Используем replaceWith(cloneNode) для удаления старых слушателей перед добавлением нового
        const newAddBtn = addBtn.cloneNode(true);
        addBtn.parentNode.replaceChild(newAddBtn, addBtn);
        newAddBtn.addEventListener('click', () => openCompanyModal()); // Добавляем слушатель к НОВОЙ кнопке
        console.log("[Listener OK] Added click to #add-company-btn");
    } else {
        console.error("!!! renderCompaniesTab: Element #add-company-btn NOT FOUND after innerHTML.");
    }

    if (companyListDiv) {
         // Используем делегирование событий для кнопок Редактировать/Удалить внутри списка
         const newCompanyListDiv = companyListDiv.cloneNode(false); // Клонируем пустой контейнер
         companyListDiv.parentNode.replaceChild(newCompanyListDiv, companyListDiv); // Заменяем старый
         newCompanyListDiv.innerHTML = 'Загрузка списка компаний...'; // Восстанавливаем заглушку
         newCompanyListDiv.addEventListener('click', handleCompanyActions); // Добавляем слушатель к НОВОМУ контейнеру
         console.log("[Listener OK] Added click delegate listener to #companies-list");
    } else {
         console.error("!!! renderCompaniesTab: Element #companies-list NOT FOUND after innerHTML.");
    }
    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные в ТОЛЬКО ЧТО созданном #companies-list
    await fetchAndRenderCompanies();
    console.log("[Render] renderCompaniesTab: End");
}

// --- Загрузка и отображение списка компаний ---
async function fetchAndRenderCompanies() {
    console.log("[Fetch] fetchAndRenderCompanies: Start");
    const listDiv = document.getElementById('companies-list'); // Ищем контейнер заново
    if (!listDiv) {
        console.error("!!! fetchAndRenderCompanies: listDiv #companies-list not found!");
        return; // Выходим, если контейнер не найден (не должно произойти)
    }
    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка компаний...</p>';
    // Не показываем глобальный лоадер
    try {
        // Запрашиваем список компаний у бэкенда
        const companies = await apiFetch('/api/superadmin/companies');
        console.log("[Fetch] fetchAndRenderCompanies: Received companies:", companies);

        if (!companies || companies.length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">Компаний-арендаторов еще нет. Создайте первую!</p>';
        } else {
            // Генерируем HTML для каждой компании в списке
            listDiv.innerHTML = companies.map(c => `
                <div class="p-3 ${c.is_active ? 'bg-gray-50' : 'bg-red-50 opacity-70'} rounded-md flex flex-wrap justify-between items-center gap-2 border">
                    <div class="flex-grow">
                        <p class="font-bold text-lg">${c.name} (Код: <span class="text-indigo-600 font-mono">${c.company_code}</span>)</p>
                        <p class="text-sm text-gray-500">
                            Подписка до: ${c.subscription_paid_until ? new Date(c.subscription_paid_until).toLocaleDateString() : 'Не уст.'} |
                            Статус: ${c.is_active ? '<span class="text-green-600 font-semibold">Активна</span>' : '<span class="text-red-600 font-semibold">ЗАБЛОКИРОВАНА</span>'}
                        </p>
                        ${c.contact_person || c.contact_phone ? `<p class="text-xs text-gray-500">Контакт: ${c.contact_person || ''} ${c.contact_phone || ''}</p>` : ''}
                    </div>
                    <div class="flex-shrink-0 flex gap-2">
                        <button data-company-json='${JSON.stringify(c)}' class="edit-company-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">Редактировать</button>
                        <button data-company-id="${c.id}" data-company-name="${c.name}" class="delete-company-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">Удалить</button>
                    </div>
                </div>
            `).join('');
        }
        console.log("[Fetch] fetchAndRenderCompanies: Success");
    } catch (e) {
        console.error("[Fetch] fetchAndRenderCompanies: Error", e);
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки списка компаний: ${e.message}</p>`;
    } finally {
        // hideLoader(); // Глобальный лоадер не используется здесь
    }
}

// --- Открытие модального окна Компании (для создания или редактирования) ---
function openCompanyModal(company = null) {
    console.log("[Modal] openCompanyModal: Start", company);
    const modal = document.getElementById('company-modal');
    if (!modal) return console.error("!!! openCompanyModal: Modal element #company-modal not found!");

    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openCompanyModal: Modal content not found!");

    const isEdit = company !== null; // Определяем, редактирование это или создание

    // Генерируем HTML для содержимого модального окна
    // Используем префикс 'modal-' для ID всех полей формы
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold">${isEdit ? 'Редактировать Компанию' : 'Создать Новую Компанию'}</h3>
            <button onclick="closeModal('company-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
        </div>
        <form id="modal-company-form" class="space-y-4">
            <input type="hidden" id="modal-company-id" value="${isEdit ? company.id : ''}">

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="modal-company-name" class="block text-sm font-medium text-gray-700">Название компании *</label>
                    <input type="text" id="modal-company-name" class="mt-1 w-full p-2 border rounded" required value="${isEdit ? company.name : ''}">
                </div>
                <div>
                    <label for="modal-company-code" class="block text-sm font-medium text-gray-700">Код Компании (A-Z, 0-9, _) *</label>
                    <input type="text" id="modal-company-code" class="mt-1 w-full p-2 border rounded uppercase font-mono" required
                           value="${isEdit ? company.company_code : ''}"
                           ${isEdit ? 'disabled title="Код нельзя изменить после создания"' : 'placeholder="Напр. VISH, CARGO_KG"'}
                           maxlength="15" pattern="^[A-Z0-9_]{3,15}$">
                     <p class="text-xs text-gray-500 mt-1">3-15 знаков. Нельзя изменить после создания.</p>
                </div>
            </div>
            <div>
                <label for="modal-company-subscription" class="block text-sm font-medium text-gray-700">Дата окончания подписки *</label>
                <input type="date" id="modal-company-subscription" class="mt-1 w-full p-2 border rounded" required value="${isEdit && company.subscription_paid_until ? company.subscription_paid_until : ''}">
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                     <label for="modal-company-contact-person" class="block text-sm font-medium text-gray-700">Контактное лицо</label>
                     <input type="text" id="modal-company-contact-person" class="mt-1 w-full p-2 border rounded" value="${isEdit ? (company.contact_person || '') : ''}">
                </div>
                <div>
                     <label for="modal-company-contact-phone" class="block text-sm font-medium text-gray-700">Контактный телефон</label>
                     <input type="text" id="modal-company-contact-phone" class="mt-1 w-full p-2 border rounded" value="${isEdit ? (company.contact_phone || '') : ''}">
                </div>
            </div>

            <div id="modal-company-owner-fields" class="border-t pt-4 space-y-4 ${isEdit ? 'hidden' : 'block'}">
                <h4 class="text-lg font-semibold">Данные Владельца Компании</h4>
                <div>
                     <label for="modal-company-owner-name" class="block text-sm font-medium text-gray-700">ФИО Владельца *</label>
                     <input type="text" id="modal-company-owner-name" class="mt-1 w-full p-2 border rounded" ${!isEdit ? 'required' : ''}>
                </div>
                <div>
                     <label for="modal-company-owner-password" class="block text-sm font-medium text-gray-700">Пароль Владельца *</label>
                     <input type="text" id="modal-company-owner-password" class="mt-1 w-full p-2 border rounded" ${!isEdit ? 'required' : ''}>
                </div>
            </div>

            <div id="modal-company-status-field" class="border-t pt-4 ${isEdit ? 'block' : 'hidden'}">
                 <label class="flex items-center">
                     <input type="checkbox" id="modal-company-is-active" class="h-4 w-4 rounded" ${isEdit && company.is_active ? 'checked' : ''}>
                     <span class="ml-2 text-sm font-medium text-gray-700">Компания Активна (Разрешен вход)</span>
                 </label>
            </div>

            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('company-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
            </div>
        </form>
    `;

    // Устанавливаем дату подписки по умолчанию (+30 дней) для НОВОЙ компании
    if (!isEdit) {
         const subInput = document.getElementById('modal-company-subscription');
         if (subInput && !subInput.value) {
              const today = new Date();
              today.setDate(today.getDate() + 30);
              subInput.value = today.toISOString().split('T')[0];
              console.log("[Modal] Установлена дата подписки по умолчанию:", subInput.value);
         }
    }

    // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
    const formElement = document.getElementById('modal-company-form');
    if (formElement) {
        // Удаляем старые слушатели перед добавлением нового
        formElement.replaceWith(formElement.cloneNode(true));
        document.getElementById('modal-company-form').addEventListener('submit', handleSaveCompany);
        console.log("[Modal Listener OK] Added submit to #modal-company-form");
    } else {
        console.error("!!! openCompanyModal: Form #modal-company-form NOT FOUND after innerHTML!");
    }
    // --- Конец добавления слушателя ---

    openModal('company-modal'); // Открываем модальное окно
    console.log("[Modal] openCompanyModal: End");
}

// --- Обработка кликов в списке компаний (делегирование) ---
// Вызывается слушателем, добавленным в renderCompaniesTab
function handleCompanyActions(e) {
    const editButton = e.target.closest('.edit-company-btn');
    const deleteButton = e.target.closest('.delete-company-btn');

    if (editButton) {
        console.log("[Action] Edit company button clicked");
        try {
            // Извлекаем данные компании из data-атрибута кнопки
            const companyData = JSON.parse(editButton.dataset.companyJson);
            openCompanyModal(companyData); // Открываем модалку для редактирования
        } catch (err) {
            console.error("Error parsing company data for edit:", err);
            alert("Ошибка: Не удалось прочитать данные компании для редактирования.");
        }
    } else if (deleteButton) {
        console.log("[Action] Delete company button clicked");
        const companyId = deleteButton.dataset.companyId;
        const companyName = deleteButton.dataset.companyName;
        // Запрашиваем подтверждение перед удалением
        if (confirm(`ВНИМАНИЕ!\n\nВы собираетесь УДАЛИТЬ компанию "${companyName}" и ВСЕ связанные с ней данные (филиалы, сотрудники, роли, клиенты, заказы, смены, расходы)?\n\nДЕЙСТВИЕ НЕОБРАТИМО!`)) {
            // Дополнительное подтверждение для надежности
             if (prompt(`Для подтверждения удаления "${companyName}" введите ее код компании (${companyName === 'WishCargo' ? 'WISH' : 'КОД'}):`)?.toUpperCase() === companyName === 'WishCargo' ? 'WISH' : deleteButton.closest('.p-3').querySelector('.text-indigo-600')?.textContent) {
                  handleDeleteCompany(companyId, companyName); // Вызываем функцию удаления
             } else {
                  alert("Удаление отменено: Код компании введен неверно.");
             }
        }
    }
}

// --- Сохранение данных Компании (вызывается из модального окна) ---
async function handleSaveCompany(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Save] handleSaveCompany: Start");
    showLoader(); // Показываем лоадер

    // Считываем ID компании (если он есть - значит редактируем)
    const companyId = document.getElementById('modal-company-id')?.value;
    const isEdit = !!companyId; // true, если ID есть
    let url = '/superadmin/companies'; // URL для создания
    let method = 'POST'; // Метод для создания
    let payload = {}; // Объект для данных, которые отправим на сервер

    try {
        // --- Собираем данные из полей модального окна ---
        if (isEdit) {
            // --- РЕДАКТИРОВАНИЕ ---
            url = `/superadmin/companies/${companyId}`; // Обновляем URL
            method = 'PATCH'; // Обновляем метод
            payload = {
                name: document.getElementById('modal-company-name')?.value.trim(),
                subscription_paid_until: document.getElementById('modal-company-subscription')?.value,
                contact_person: document.getElementById('modal-company-contact-person')?.value.trim() || null,
                contact_phone: document.getElementById('modal-company-contact-phone')?.value.trim() || null,
                is_active: document.getElementById('modal-company-is-active')?.checked
            };
            // Проверка обязательных полей
            if (!payload.name || !payload.subscription_paid_until) {
                throw new Error("Название компании и дата окончания подписки обязательны.");
            }
        } else {
            // --- СОЗДАНИЕ ---
            payload = {
                name: document.getElementById('modal-company-name')?.value.trim(),
                company_code: document.getElementById('modal-company-code')?.value.toUpperCase().trim(),
                subscription_paid_until: document.getElementById('modal-company-subscription')?.value,
                contact_person: document.getElementById('modal-company-contact-person')?.value.trim() || null,
                contact_phone: document.getElementById('modal-company-contact-phone')?.value.trim() || null,
                owner_full_name: document.getElementById('modal-company-owner-name')?.value.trim(),
                owner_password: document.getElementById('modal-company-owner-password')?.value // Пароль не тримим
            };
            // Проверка обязательных полей
            if (!payload.name || !payload.company_code || !payload.subscription_paid_until || !payload.owner_full_name || !payload.owner_password) {
                 throw new Error("Все поля со звездочкой (*) обязательны при создании компании.");
            }
             // Проверка корректности кода компании (дублируем проверку бэкенда)
            if (!/^[A-Z0-9_]{3,15}$/.test(payload.company_code)) {
                 throw new Error("Код компании некорректен (3-15 знаков, только латинские буквы A-Z, цифры 0-9 и символ подчеркивания '_').");
            }
        }

        // --- Отправляем запрос на сервер ---
        console.log(`[Save] handleSaveCompany: Sending ${method} to ${url}`, payload);
        const result = await apiFetch(url, { method: method, body: JSON.stringify(payload) });
        console.log("[Save] handleSaveCompany: Server response", result);

        // --- Обработка успеха ---
        alert(isEdit ? 'Данные компании успешно обновлены!' : 'Новая компания успешно создана!');
        closeModal('company-modal'); // Закрываем модальное окно
        await fetchAndRenderCompanies(); // Обновляем список компаний на странице

    } catch(err) { // Обработка ошибок (от валидации или от apiFetch)
        console.error("[Save] handleSaveCompany: Error", err);
        alert(`Ошибка сохранения данных компании: ${err.message}`);
        // Оставляем модальное окно открытым для исправления
    } finally {
        // --- Скрываем лоадер в любом случае ---
        hideLoader();
        console.log("[Save] handleSaveCompany: End");
    }
}

// --- Удаление Компании ---
async function handleDeleteCompany(companyId, companyName) {
    console.log(`[Delete] handleDeleteCompany: Start deleting ID ${companyId} (${companyName})`);
    showLoader();
    try {
        // Отправляем DELETE запрос на бэкенд
        await apiFetch(`/api/superadmin/companies/${companyId}`, { method: 'DELETE' });
        console.log(`[Delete] handleDeleteCompany: Company ID ${companyId} deleted successfully.`);
        alert(`Компания "${companyName}" и все ее данные были успешно удалены.`);
        await fetchAndRenderCompanies(); // Обновляем список компаний
    } catch (err) { // Обработка ошибок от apiFetch
        console.error("[Delete] handleDeleteCompany: Error", err);
        alert(`Ошибка удаления компании "${companyName}": ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Delete] handleDeleteCompany: End");
    }
}

// =================================================================
// МОДУЛЬ: ФИЛИАЛЫ (Владелец) 
// =================================================================

// --- Рендеринг вкладки "Филиалы" (Создает HTML-контейнеры) ---

async function renderLocationsTab() {
    console.log("[Render] renderLocationsTab: Start");
    const pane = document.getElementById('tab-locations');
    if (!pane) {
         console.warn("[Render] renderLocationsTab: Pane #tab-locations not found.");
         return; 
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-start gap-4 mb-4">
                <div class="flex flex-col">
                    <h2 class="text-2xl font-bold">Филиалы (Точки) Компании</h2>
                    <p id="locations-status" class="text-sm text-gray-600">Загрузка статуса...</p>
                </div>
                <button id="add-location-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">➕ Добавить Филиал</button>
            </div>
            <div id="locations-list" class="space-y-3">Загрузка списка филиалов...</div>
        </div>
    `;

    // --- Добавляем слушатели ---
    const addBtn = document.getElementById('add-location-btn');
    if (addBtn) addBtn.addEventListener('click', () => openLocationModal()); 

    const locationListDiv = document.getElementById('locations-list');
    if (locationListDiv) {
         locationListDiv.addEventListener('click', (e) => {
             const editBtn = e.target.closest('.edit-location-btn');
             const deleteBtn = e.target.closest('.delete-location-btn');
             const toggleBtn = e.target.closest('.toggle-shift-btn');
             
             if (editBtn) openLocationModal(JSON.parse(editBtn.dataset.locationJson));
             // ... (логика для удаления и переключения смен)
             if (toggleBtn) handleShiftToggle(e); 
         });
    }

    await fetchAndRenderLocations();
    console.log("[Render] renderLocationsTab: End");
}

// --- Загрузка и отображение списка филиалов (ГДЕ БЫЛА ОШИБКА) ---
// index.html (Полностью заменяет fetchAndRenderLocations)

async function fetchAndRenderLocations() {
    console.log("[Fetch] fetchAndRenderLocations: Start");
    
    // Переменная listDiv должна быть объявлена локально!
    const listDiv = document.getElementById('locations-list'); 
    
    if (!listDiv) {
        console.error("!!! fetchAndRenderLocations: Элемент #locations-list не найден.");
        return; 
    }
    
    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка филиалов...</p>';
    showLoader(); 

    try {
        // --- Загрузка филиалов и активных смен ---
        const [locations, activeShifts] = await Promise.all([
            apiFetch('/api/locations'),
            fetchActiveShiftsForCompany() 
        ]);
        companyLocations = locations; 
        
        const shiftsByLocation = new Map();
        activeShifts.forEach(shift => shiftsByLocation.set(shift.location_id, shift));

        // --- ОБНОВЛЕНИЕ ДИНАМИЧЕСКОГО СТАТУСА ---
        const statusEl = document.getElementById('locations-status');
        const totalLocations = locations.length;
        const activeShiftCount = activeShifts.length;
        if (statusEl) {
            statusEl.textContent = `Всего точек: ${totalLocations} | Открытых смен: ${activeShiftCount}`;
        }
        // ----------------------------------------

        if (!locations || locations.length === 0) {
             listDiv.innerHTML = '<p class="text-gray-500">У вашей компании нет филиалов.</p>';
        } else {
            listDiv.innerHTML = locations.map(loc => {
                const shiftInfo = shiftsByLocation.get(loc.id);
                const isActive = !!shiftInfo;
                const employeeName = shiftInfo?.employee?.full_name || '—';
                const buttonText = isActive ? 'Закрыть смену' : 'Открыть смену';
                const buttonClass = isActive ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600';

                return `
                    <div class="p-3 bg-gray-50 rounded-md border flex flex-wrap justify-between items-center gap-2">
                        <div class="flex-grow">
                            <p class="font-bold text-lg">${loc.name}</p>
                            <p class="text-sm text-gray-600">${loc.address || 'Адрес не указан'}</p>
                            <p class="text-xs ${isActive ? 'text-green-600 font-semibold' : 'text-red-600'}">
                                ${isActive ? `СМЕНА ОТКРЫТА (Сотрудник: ${employeeName})` : 'СМЕНА ЗАКРЫТА'}
                            </p>
                        </div>
                        <div class="flex-shrink-0 flex gap-2">
                            <button data-location-json='${JSON.stringify(loc)}' class="edit-location-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">Редактировать</button>
                            <button data-location-id="${loc.id}" 
                                    data-is-active="${isActive}"
                                    data-shift-id="${shiftInfo?.id || ''}"
                                    data-employee-id="${shiftInfo?.employee_id || ''}"
                                    class="toggle-shift-btn text-sm ${buttonClass} text-white px-3 py-1 rounded">
                                ${buttonText}
                            </button>
                            ${loc.name !== 'Главный филиал' ? `<button data-location-id="${loc.id}" data-location-name="${loc.name}" class="delete-location-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">Удалить</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Note: addLocationActionListeners() больше не нужна, т.к. мы используем делегирование
        }
    } catch (e) {
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки списка филиалов: ${e.message}</p>`;
    } finally {
        hideLoader();
    }
}

// --- НОВАЯ ФУНКЦИЯ: Запрашивает все активные смены компании ---
async function fetchActiveShiftsForCompany() {
    try {
        const response = await apiFetch('/api/shifts/all_active');
        return response || [];
    } catch (e) {
        // Ловим 404, если роут не существует, и возвращаем пустой массив
        if (e.message && e.message.includes('404')) return [];
        console.error("[Shift Status] Failed to fetch all active shifts:", e);
        return []; 
    }
}

// --- Добавление слушателей к кнопкам Редакт/Удалить в списке филиалов ---
// Вызывается ПОСЛЕ того, как fetchAndRenderLocations сгенерировал HTML списка
function addLocationActionListeners() {
     const listDiv = document.getElementById('locations-list');
     if (!listDiv) return;

     // Находим все кнопки редактирования
     listDiv.querySelectorAll('.edit-location-btn').forEach(btn => {
          // Удаляем старый слушатель (если был) через клонирование
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);
          // Добавляем новый
          newBtn.addEventListener('click', (e) => {
               console.log("[Action] Edit location button clicked");
               try {
                    const locationData = JSON.parse(e.currentTarget.dataset.locationJson);
                    openLocationModal(locationData); // Открываем модалку с данными
               } catch (err) {
                    console.error("Error parsing location data for edit:", err);
                    alert("Ошибка: Не удалось прочитать данные филиала.");
               }
          });
     });

      // Находим все кнопки удаления
     listDiv.querySelectorAll('.delete-location-btn').forEach(btn => {
           const newBtn = btn.cloneNode(true);
           btn.parentNode.replaceChild(newBtn, btn);
           newBtn.addEventListener('click', (e) => {
                console.log("[Action] Delete location button clicked");
                const locationId = e.currentTarget.dataset.locationId;
                const locationName = e.currentTarget.dataset.locationName;
                if (confirm(`Удалить филиал "${locationName}"?\n\nВНИМАНИЕ: Сотрудники, привязанные к этому филиалу, останутся без филиала!`)) {
                     handleDeleteLocation(locationId, locationName); // Вызываем удаление
                }
           });
     });
     console.log("[Listeners OK] Added action listeners to location list buttons.");
}


// --- Открытие модального окна Филиала (для создания или редактирования) ---
function openLocationModal(location = null) {
    console.log("[Modal] openLocationModal: Start", location);
    const modal = document.getElementById('location-modal');
    if (!modal) return console.error("!!! openLocationModal: Modal element #location-modal not found!");
    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openLocationModal: Modal content not found!");

    const isEdit = location !== null; // true, если переданы данные для редактирования

    // Генерируем HTML для содержимого модального окна
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold">${isEdit ? 'Редактировать Филиал' : 'Добавить Новый Филиал'}</h3>
            <button onclick="closeModal('location-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
        </div>
        <form id="location-form" class="space-y-4">
            <input type="hidden" id="location-id" value="${isEdit ? location.id : ''}">
            <div>
                <label for="location-name" class="block text-sm font-medium text-gray-700">Название *</label>
                <input type="text" id="location-name" class="mt-1 w-full p-2 border rounded" required value="${isEdit ? location.name : ''}" placeholder="Например: Склад Дордой, Офис Центр">
            </div>
            <div>
                <label for="location-address" class="block text-sm font-medium text-gray-700">Адрес</label>
                <input type="text" id="location-address" class="mt-1 w-full p-2 border rounded" value="${isEdit ? (location.address || '') : ''}" placeholder="Город, улица, дом">
            </div>
            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('location-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
            </div>
        </form>
    `;

    // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
    const formElement = document.getElementById('location-form');
    if (formElement) {
        // Удаляем старые слушатели перед добавлением нового
        formElement.replaceWith(formElement.cloneNode(true));
        document.getElementById('location-form').addEventListener('submit', handleSaveLocation);
        console.log("[Modal Listener OK] Added submit to #location-form");
    } else {
        console.error("!!! openLocationModal: Form #location-form NOT FOUND after innerHTML!");
    }
    // --- Конец добавления слушателя ---

    openModal('location-modal'); // Открываем модальное окно
    console.log("[Modal] openLocationModal: End");
}

// --- Сохранение данных Филиала (вызывается из модального окна) ---
async function handleSaveLocation(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Save] handleSaveLocation: Start");
    showLoader(); // Показываем лоадер

    // Считываем ID (для определения режима - создание/редактирование)
    const locationId = document.getElementById('location-id')?.value;
    const isEdit = !!locationId; // true, если ID есть
    const url = isEdit ? `/locations/${locationId}` : '/locations'; // Определяем URL
    const method = isEdit ? 'PATCH' : 'POST'; // Определяем метод

    // Собираем данные из полей формы
    const payload = {
        name: document.getElementById('location-name')?.value.trim(),
        address: document.getElementById('location-address')?.value.trim() || null // Отправляем null если поле адреса пустое
    };

    // Валидация: проверяем, что название не пустое
    if (!payload.name) {
         hideLoader();
         alert("Название филиала не может быть пустым.");
         return; // Прерываем сохранение
     }

    try {
        // Отправляем запрос на сервер
        console.log(`[Save] handleSaveLocation: Sending ${method} to ${url}`, payload);
        const result = await apiFetch(url, { method: method, body: JSON.stringify(payload) });
        console.log("[Save] handleSaveLocation: Server response", result);

        // Обработка успеха
        alert(isEdit ? 'Данные филиала успешно обновлены!' : 'Новый филиал успешно создан!');
        closeModal('location-modal'); // Закрываем модальное окно
        await fetchAndRenderLocations(); // Обновляем список филиалов на странице

    } catch(err) { // Обработка ошибок (от валидации или от apiFetch)
        console.error("[Save] handleSaveLocation: Error", err);
        alert(`Ошибка сохранения данных филиала: ${err.message}`);
        // Оставляем модальное окно открытым для исправления
    } finally {
        // --- Скрываем лоадер в любом случае ---
        hideLoader();
        console.log("[Save] handleSaveLocation: End");
    }
}

// --- Удаление Филиала ---
async function handleDeleteLocation(locationId, locationName) {
    console.log(`[Delete] handleDeleteLocation: Start deleting ID ${locationId} (${locationName})`);
    // Дополнительная проверка перед удалением (можно запросить пароль или код)
    // const confirmation = prompt(`Для подтверждения удаления филиала "${locationName}" введите "УДАЛИТЬ":`);
    // if (confirmation !== "УДАЛИТЬ") {
    //      alert("Удаление отменено.");
    //      return;
    // }
    
    showLoader();
    try {
        // TODO: Добавить эндпоинт DELETE /locations/{id} на бэкенд.
        // Пока имитируем или показываем заглушку.
        // await apiFetch(`/locations/${locationId}`, { method: 'DELETE' });
        
        console.warn(`[Delete] handleDeleteLocation: DELETE endpoint for locations not implemented yet. Deletion skipped for ID ${locationId}.`);
        alert(`Функция удаления филиала "${locationName}" пока не реализована на сервере.`);
        
        // alert(`Филиал "${locationName}" успешно удален.`); // Когда будет готово
        // await fetchAndRenderLocations(); // Обновить список после удаления

    } catch(err) { // Обработка ошибок от apiFetch
        console.error("[Delete] handleDeleteLocation: Error", err);
        alert(`Ошибка удаления филиала "${locationName}": ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Delete] handleDeleteLocation: End");
    }
}

// index.html (Внутри МОДУЛЬ: ФИЛИАЛЫ)

// --- НОВАЯ ФУНКЦИЯ: Обработчик клика по кнопке "Открыть/Закрыть смену" ---
async function handleShiftToggle(e) {
    const btn = e.target.closest('.toggle-shift-btn');
    if (!btn) return;
    
    const isActive = btn.dataset.isActive === 'true'; // Текущий статус смены
    const locationId = btn.dataset.locationId; // ID филиала, где происходит действие
    const shiftId = btn.dataset.shiftId; // ID смены (если открыта)
    
    if (isActive) {
        // СМЕНА ОТКРЫТА -> Владелец должен ее закрыть
        await handleForcedCloseShift(shiftId, locationId);
    } else {
        // СМЕНА ЗАКРЫТА -> Владелец открывает новую смену
        await showOpenShiftScreen(locationId);
    }
}

// --- НОВАЯ ФУНКЦИЯ: Принудительное закрытие смены Владельцем ---
async function handleForcedCloseShift(shiftId, locationId) {
    if (!shiftId) return alert("Ошибка: ID смены не найден.");
    
    // Владелец должен знать фактический остаток для закрытия 
    const closingCashStr = prompt(`Введите итоговую сумму наличных в кассе для закрытия смены #${shiftId} (филиал ID ${locationId}):`);
    
    if (closingCashStr === null || closingCashStr === '') {
        alert("Закрытие смены отменено.");
        return;
    }
    const closingCash = parseFloat(closingCashStr);
    if (isNaN(closingCash) || closingCash < 0) {
        alert("Некорректная сумма. Закрытие отменено.");
        return;
    }

    const password = prompt("Введите ваш пароль Владельца для подтверждения закрытия:");
    if (!password) return alert("Закрытие отменено.");
    
    showLoader();
    try {
        // Используем специальный эндпоинт для принудительного закрытия
        await apiFetch(`/api/shifts/${shiftId}/force_close`, {
            method: 'POST',
            body: JSON.stringify({ closing_cash: closingCash, password: password })
        });
        
        alert(`Смена #${shiftId} успешно закрыта!`);
        await fetchAndRenderLocations(); // Обновляем список филиалов
        
    } catch (err) {
        alert(`Ошибка закрытия смены: ${err.message}`);
    } finally {
        hideLoader();
    }
}

// --- ИЗМЕНЕНИЕ СУЩЕСТВУЮЩЕЙ ФУНКЦИИ: Привязка слушателя ---
function addLocationActionListeners() {
    // ... (код для кнопок редактирования/удаления)
    
    // Находим все кнопки открытия/закрытия смены
    listDiv.querySelectorAll('.toggle-shift-btn').forEach(btn => {
         const newBtn = btn.cloneNode(true);
         btn.parentNode.replaceChild(newBtn, btn);
         // !!! КРИТИЧЕСКАЯ ПРИВЯЗКА !!!
         newBtn.addEventListener('click', handleShiftToggle); 
    });
    console.log("[Listeners OK] Added action listeners to location list buttons.");
}

// Теперь вам нужно убедиться, что handleOpenShiftSubmit (в модалке) может принять locationId 
// и вызвать open_shift на бэкенде.
// Эту часть мы уже реализовывали в предыдущих шагах, она должна работать с locationId.

// =================================================================
// МОДУЛЬ: ПЕРСОНАЛ (Владелец) (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг вкладки "Персонал" ---
// Вызывается из initializeMainAppUI, если у Владельца есть права 'manage_employees'
async function renderEmployeesTab() {
    console.log("[Render] renderEmployeesTab: Start");
    const pane = document.getElementById('tab-employees');
    if (!pane) {
        console.warn("[Render] renderEmployeesTab: Pane #tab-employees not found.");
        return;
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md border">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold text-gray-800">Управление Персоналом</h2>
                <button id="add-employee-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 text-sm">➕ Добавить Сотрудника</button>
            </div>
            <div id="employees-list" class="space-y-3">Загрузка списка сотрудников...</div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addBtn = document.getElementById('add-employee-btn');
    const employeeListDiv = document.getElementById('employees-list');

    // Кнопка "Добавить Сотрудника"
    if (addBtn) {
        // Используем replaceWith(cloneNode) для удаления старых слушателей перед добавлением нового
        const newAddBtn = addBtn.cloneNode(true);
        addBtn.parentNode?.replaceChild(newAddBtn, addBtn);
        newAddBtn.addEventListener('click', () => openEmployeeModal()); // Добавляем к новой кнопке
        console.log("[Listener OK] Added click to #add-employee-btn");
    } else {
        console.error("!!! renderEmployeesTab: Element #add-employee-btn NOT FOUND after innerHTML.");
    }

    // Список сотрудников (для делегирования кликов по кнопкам Редакт/Уволить/Удалить)
    if (employeeListDiv) {
         const newEmployeeListDiv = employeeListDiv.cloneNode(false); // Клонируем пустой контейнер
         employeeListDiv.parentNode?.replaceChild(newEmployeeListDiv, employeeListDiv); // Заменяем старый
         newEmployeeListDiv.innerHTML = 'Загрузка списка сотрудников...'; // Восстанавливаем заглушку
         // Добавляем слушатель к НОВОМУ контейнеру
         newEmployeeListDiv.addEventListener('click', handleEmployeeActions);
         console.log("[Listener OK] Added click delegate listener to #employees-list");
    } else {
         console.error("!!! renderEmployeesTab: Element #employees-list NOT FOUND after innerHTML.");
    }
    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные
    await fetchAndRenderEmployees();
    console.log("[Render] renderEmployeesTab: End");
}

async function fetchAndRenderEmployees() {
    console.log("[Fetch] fetchAndRenderEmployees: Start");
    const listDiv = document.getElementById('employees-list'); // Ищем контейнер
    if (!listDiv) return console.error("!!! fetchAndRenderEmployees: listDiv #employees-list not found!");
    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка сотрудников...</p>';
    showLoader(); // Показываем лоадер

    try {
        // --- Предзагрузка Ролей и Филиалов (если нужны и кэш пуст) ---
        if (!currentUser.is_super_admin) {
             if (!companyLocations || companyLocations.length === 0 || !companyRoles || companyRoles.length === 0) {
                 console.log("[Fetch] fetchAndRenderEmployees: Preloading locations and roles...");
                 const results = await Promise.allSettled([
                     // КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ 1: ДОБАВЛЕН /api
                     (!companyLocations || companyLocations.length === 0) ? apiFetch('/api/locations') : Promise.resolve(companyLocations),
                     // КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ 2: ДОБАВЛЕН /api
                     (!companyRoles || companyRoles.length === 0) ? apiFetch('/api/roles') : Promise.resolve(companyRoles)
                 ]);
                 if (results[0].status === 'fulfilled') companyLocations = results[0].value; else console.warn("Failed to preload locations:", results[0].reason);
                 if (results[1].status === 'fulfilled') companyRoles = results[1].value; else console.warn("Failed to preload roles:", results[1].reason);
                 console.log("[Fetch] fetchAndRenderEmployees: Locations and roles loaded/updated.");
             } else {
                 console.log("[Fetch] fetchAndRenderEmployees: Using cached locations and roles.");
             }
        } else { // Для SuperAdmin эти кэши не нужны
             companyLocations = []; companyRoles = [];
        }

        // --- Загрузка списка сотрудников ---
        console.log("[Fetch] fetchAndRenderEmployees: Fetching employees list...");
        // КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ 3: ДОБАВЛЕН /api
        const employees = await apiFetch('/api/employees'); 
        console.log("[Fetch] fetchAndRenderEmployees: Received employees:", employees);

        // --- Рендеринг списка ---
        if (!employees || employees.length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">У вашей компании еще нет сотрудников (кроме Владельца).</p>';
        } else {
            listDiv.innerHTML = employees.map(emp => {
                // Ищем имя роли в кэше companyRoles (используем Optional Chaining `?.`)
                const roleName = companyRoles.find(r => r.id === emp.role_id)?.name || emp.role?.name || 'Неизвестная роль';
                // Ищем имя филиала в кэше companyLocations
                const locationName = companyLocations.find(loc => loc.id === emp.location_id)?.name || 'Неизвестный филиал';

                // Определяем доступные действия для текущего пользователя
                const canManage = currentUser.permissions?.includes('manage_employees');
                const isOwnerRole = roleName === 'Владелец'; // Нельзя уволить/удалить Владельца

                return `
                 <div class="p-3 ${emp.is_active ? 'bg-gray-50' : 'bg-red-50 opacity-70'} rounded-md border flex flex-wrap justify-between items-center gap-2 shadow-sm">
                     <div class="flex-grow min-w-[200px]">
                         <p class="font-bold text-lg text-gray-800">${emp.full_name}</p>
                         <p class="text-sm text-gray-600">${roleName} @ ${locationName}</p>
                         <p class="text-xs font-semibold ${emp.is_active ? 'text-green-600' : 'text-red-600'}">${emp.is_active ? 'АКТИВЕН' : 'УВОЛЕН'}</p>
                     </div>
                      <div class="flex-shrink-0 flex gap-2">
                          ${canManage ? `
                              <button data-employee-json='${JSON.stringify(emp)}' class="edit-employee-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded transition-colors duration-150">Редактировать</button>
                              ${!isOwnerRole ? `
                              <button data-employee-id="${emp.id}" data-employee-name="${emp.full_name}" data-is-active="${emp.is_active}" class="toggle-status-employee-btn text-sm ${emp.is_active ? 'bg-yellow-200 text-yellow-800 hover:bg-yellow-300' : 'bg-green-200 text-green-800 hover:bg-green-300'} px-3 py-1 rounded transition-colors duration-150">
                                  ${emp.is_active ? 'Уволить' : 'Восстановить'}
                              </button>
                              <button data-employee-id="${emp.id}" data-employee-name="${emp.full_name}" class="delete-employee-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded transition-colors duration-150" title="Полное удаление сотрудника (необратимо)">Удалить</button>
                              ` : '<span class="text-xs text-gray-400">(Действия недоступны)</span>'}
                          ` : ''} 
                      </div>
                 </div>
                `;}).join('');
            // Слушатели для кнопок уже добавлены на #employees-list через делегирование
        }
        console.log("[Fetch] fetchAndRenderEmployees: Success");
    } catch (e) {
        console.error("!!! [Fetch] fetchAndRenderEmployees: Error", e);
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки списка сотрудников: ${e.message}</p>`;
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Fetch] fetchAndRenderEmployees: End");
    }
}

// --- Открытие модального окна Сотрудника (для создания или редактирования) ---
function openEmployeeModal(employee = null) {
    console.log("[Modal] openEmployeeModal: Start", employee);
    const modal = document.getElementById('employee-modal');
    if (!modal) return console.error("!!! openEmployeeModal: Modal element #employee-modal not found!");
    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openEmployeeModal: Modal content not found!");

    const isEdit = employee !== null; // true, если переданы данные для редактирования

    // --- Проверка наличия кэшей Ролей и Филиалов ---
    if (!companyLocations || companyLocations.length === 0 || !companyRoles || companyRoles.length === 0) {
        console.error("!!! openEmployeeModal: Кэши companyLocations или companyRoles пусты! Попытка перезагрузить...");
        // Пытаемся перезагрузить данные и снова открыть модалку
        // Добавляем защиту от бесконечного цикла
        if (!window.openEmployeeModalRetry) {
             window.openEmployeeModalRetry = true; // Ставим флаг
             showLoader();
             Promise.allSettled([apiFetch('/api/locations'), apiFetch('/api/roles')])
                 .then(results => {
                      if (results[0].status === 'fulfilled') companyLocations = results[0].value;
                      if (results[1].status === 'fulfilled') companyRoles = results[1].value;
                      // Повторный вызов ПОСЛЕ загрузки
                      openEmployeeModal(employee);
                 })
                 .catch(err => alert(`Критическая ошибка: Не удалось загрузить данные для формы сотрудника: ${err.message}`))
                 .finally(() => {
                      hideLoader();
                      delete window.openEmployeeModalRetry; // Сбрасываем флаг
                 });
        } else {
             alert("Ошибка: Не удалось загрузить данные о филиалах или должностях даже после перезагрузки.");
        }
        return; // Выходим в любом случае, пока данные грузятся
    }
    // --- Конец проверки кэшей ---

    // Генерируем опции для select'ов, используя актуальные кэши
    const locationsOptions = companyLocations
        .map(loc => `<option value="${loc.id}" ${isEdit && employee.location_id === loc.id ? 'selected' : ''}>${loc.name}</option>`)
        .join('');
    // Исключаем роль Владельца из списка при создании/редактировании
    const rolesOptions = companyRoles
        .filter(role => role.name !== 'Владелец') // Нельзя назначить/изменить на Владельца
        .map(role => `<option value="${role.id}" ${isEdit && employee.role_id === role.id ? 'selected' : ''}>${role.name}</option>`)
        .join('');

    // Проверяем, есть ли вообще роли для выбора (кроме Владельца) при СОЗДАНИИ
    if (!rolesOptions && !isEdit) {
         alert("Ошибка: Нет доступных должностей для назначения.\n\nСначала создайте должность во вкладке 'Должности и Доступы'.");
         return; // Не открываем модалку
    }

    // --- Генерируем HTML для модального окна ---
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold text-gray-800">${isEdit ? 'Редактировать Сотрудника' : 'Добавить Нового Сотрудника'}</h3>
            <button onclick="closeModal('employee-modal')" class="text-2xl font-bold leading-none p-1 -m-1 text-gray-500 hover:text-gray-700">&times;</button>
        </div>
        <form id="employee-form" class="space-y-4">
            
            <input type="hidden" id="employee-id" value="${isEdit ? employee.id : ''}">
            
            <div>
                <label for="employee-name" class="block text-sm font-medium text-gray-700">ФИО *</label>
                <input type="text" id="employee-name" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" required value="${isEdit ? employee.full_name : ''}">
            </div>
            
            <div>
                <label for="employee-password" class="block text-sm font-medium text-gray-700">Пароль ${isEdit ? '' : '*'}</label>
                <input type="text" id="employee-password" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" ${isEdit ? 'placeholder="Оставьте пустым, чтобы не менять"' : 'required'}>
            </div>
            
            <div>
                <label for="employee-location" class="block text-sm font-medium text-gray-700">Филиал *</label>
                <select id="employee-location" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500" required ${isEdit && employee.role?.name === 'Владелец' ? 'disabled title="Филиал Владельца нельзя изменить"' : ''}>
                    ${locationsOptions || '<option disabled>Нет доступных филиалов</option>'}
                </select>
            </div>
            
            <div>
                <label for="employee-role" class="block text-sm font-medium text-gray-700">Должность *</label>
                 ${isEdit && employee.role?.name === 'Владелец'
                     ? `<input type="text" class="mt-1 w-full p-2 border rounded bg-gray-100 cursor-not-allowed" value="Владелец" disabled title="Роль Владельца нельзя изменить">
                        <input type="hidden" id="employee-role" value="${employee.role_id}">` // Скрытое поле с ID роли
                     : `<select id="employee-role" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500" required>${rolesOptions}</select>`
                 }
            </div>
             
             ${isEdit ? `
             <div class="border-t pt-4">
                  <label class="flex items-center">
                     <input type="checkbox" id="employee-is-active-modal" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" ${employee.is_active ? 'checked' : ''}>
                     <span class="ml-2 text-sm font-medium text-gray-700">Сотрудник Активен (Разрешен вход)</span>
                  </label>
             </div>` : ''}
             
            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('employee-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
            </div>
        </form>
    `;

    // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
    const formElement = document.getElementById('employee-form');
    if (formElement) {
        // Удаляем старые слушатели перед добавлением нового
        formElement.replaceWith(formElement.cloneNode(true));
        document.getElementById('employee-form').addEventListener('submit', handleSaveEmployee);
        console.log("[Modal Listener OK] Added submit to #employee-form");
    } else {
        console.error("!!! openEmployeeModal: Form #employee-form NOT FOUND after innerHTML!");
    }
    // --- Конец добавления слушателя ---

    openModal('employee-modal'); // Открываем модальное окно
    console.log("[Modal] openEmployeeModal: End");
}


// --- Сохранение данных Сотрудника (вызывается из модального окна) ---
async function handleSaveEmployee(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Save] handleSaveEmployee: Start");
    showLoader(); // Показываем лоадер

    // Считываем ID (для определения режима - создание/редактирование)
    const employeeId = document.getElementById('employee-id')?.value;
    const isEdit = !!employeeId; // true, если ID есть
    
    // !!! КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: ДОБАВЛЕНИЕ ПРЕФИКСА /api !!!
    const url = isEdit ? `/api/employees/${employeeId}` : '/api/employees'; 
    const method = isEdit ? 'PATCH' : 'POST'; 

    // Собираем данные из полей формы
    let payload = {
        full_name: document.getElementById('employee-name')?.value.trim(),
        location_id: parseInt(document.getElementById('employee-location')?.value),
        role_id: parseInt(document.getElementById('employee-role')?.value)
    };
    const password = document.getElementById('employee-password')?.value;
    
    // Добавляем пароль, если он введен ИЛИ если это создание нового сотрудника
    if (password || !isEdit) {
        payload.password = password; 
    }
    
    // Добавляем статус активности при редактировании (если чекбокс есть)
    if (isEdit) {
        const activeCheckbox = document.getElementById('employee-is-active-modal');
        if (activeCheckbox) payload.is_active = activeCheckbox.checked;
    }

    // Валидация: проверяем наличие обязательных полей
    if (!payload.full_name || isNaN(payload.location_id) || isNaN(payload.role_id) || (!payload.password && !isEdit)) {
        hideLoader();
        alert("Ошибка: Пожалуйста, заполните все обязательные поля (*): ФИО, Пароль (при создании), Филиал, Должность.");
        console.error("[Save] handleSaveEmployee: Validation failed. Payload:", payload, "isEdit:", isEdit);
        return; // Прерываем сохранение
    }

    try {
        // Отправляем запрос на сервер
        console.log(`[Save] handleSaveEmployee: Sending ${method} to ${url}`, payload);
        const result = await apiFetch(url, { method: method, body: JSON.stringify(payload) });
        console.log("[Save] handleSaveEmployee: Server response", result);

        // Обработка успеха
        alert(isEdit ? 'Данные сотрудника успешно обновлены!' : 'Новый сотрудник успешно создан!');
        closeModal('employee-modal'); // Закрываем модальное окно
        await fetchAndRenderEmployees(); // Обновляем список сотрудников на странице

    } catch(err) { // Обработка ошибок (от валидации или от apiFetch)
        console.error("!!! [Save] handleSaveEmployee: Error", err);
        alert(`Ошибка сохранения данных сотрудника: ${err.message}`);
        // Оставляем модальное окно открытым для исправления
    } finally {
        // --- Скрываем лоадер в любом случае ---
        hideLoader();
        console.log("[Save] handleSaveEmployee: End");
    }
}

// --- Обработка кликов в списке сотрудников (делегирование) ---
// Вызывается слушателем, добавленным в renderEmployeesTab
function handleEmployeeActions(e) {
    // Ищем ближайшую кнопку к месту клика
    const editButton = e.target.closest('.edit-employee-btn');
    const toggleStatusButton = e.target.closest('.toggle-status-employee-btn');
    const deleteButton = e.target.closest('.delete-employee-btn');

    // Обработка кнопки Редактировать
    if (editButton) {
        console.log("[Action] Edit employee button clicked");
        try {
            // Извлекаем данные сотрудника из data-атрибута
            const employeeData = JSON.parse(editButton.dataset.employeeJson);
            // Пытаемся дополнить данными роли из кэша (для отображения в модалке)
            employeeData.role = companyRoles.find(r => r.id === employeeData.role_id);
            if (!employeeData.role) console.warn("[Action] Role details not found in cache for employee:", employeeData);
            openEmployeeModal(employeeData); // Открываем модалку для редактирования
        } catch (err) {
            console.error("!!! [Action] Error parsing employee data for edit:", err);
            alert("Ошибка: Не удалось прочитать данные сотрудника для редактирования.");
        }
        return; // Прерываем, чтобы не сработали другие кнопки
    }

    // Обработка кнопки Уволить/Восстановить
    if (toggleStatusButton) {
        console.log("[Action] Toggle status employee button clicked");
        const employeeId = toggleStatusButton.dataset.employeeId;
        const employeeName = toggleStatusButton.dataset.employeeName;
        const isActive = toggleStatusButton.dataset.isActive === 'true'; // Преобразуем строку в boolean
        const actionText = isActive ? 'Уволить' : 'Восстановить';
        // Запрашиваем подтверждение
        if (confirm(`${actionText} сотрудника "${employeeName}"?`)) {
            handleToggleEmployeeStatus(employeeId, !isActive); // Вызываем функцию смены статуса
        }
        return; // Прерываем
    }

    // Обработка кнопки Полное Удаление
    if (deleteButton) {
        console.log("[Action] Delete employee button clicked");
        const employeeId = deleteButton.dataset.employeeId;
        const employeeName = deleteButton.dataset.employeeName;
         // Двойное подтверждение для опасной операции
        if (confirm(`ВНИМАНИЕ!\n\nВы собираетесь ПОЛНОСТЬЮ УДАЛИТЬ сотрудника "${employeeName}"?\n\nЭто действие удалит его смены, расходы и отвяжет от выданных им заказов.\n\nДЕЙСТВИЕ НЕОБРАТИМО!`)) {
             if (confirm(`ПОСЛЕДНЕЕ ПРЕДУПРЕЖДЕНИЕ:\n\nТОЧНО УДАЛИТЬ "${employeeName}"?`)){
                  handleDeleteEmployee(employeeId, employeeName); // Вызываем функцию удаления
             }
        }
        return; // Прерываем
    }
}

// --- Смена статуса (Уволить/Восстановить) через API ---
async function handleToggleEmployeeStatus(employeeId, newStatus /* true or false */) {
     const actionText = newStatus ? 'восстановлен' : 'уволен';
     console.log(`[Action] handleToggleEmployeeStatus: Setting status ${newStatus} for employee ID ${employeeId}`);
     showLoader(); // Показываем лоадер
     try {
         // Отправляем PATCH запрос только с полем is_active
         await apiFetch(`/api/employees/${employeeId}`, {
              method: 'PATCH',
              body: JSON.stringify({ is_active: newStatus })
         });
         console.log(`[Action] handleToggleEmployeeStatus: Success for employee ID ${employeeId}`);
         alert(`Сотрудник "${actionText}".`); // Краткое сообщение
         await fetchAndRenderEmployees(); // Обновляем список сотрудников
     } catch (err) { // Обработка ошибок от apiFetch
          console.error("!!! [Action] handleToggleEmployeeStatus: Error", err);
          alert(`Ошибка при попытке ${actionText.slice(0,-1)}ить сотрудника: ${err.message}`);
     } finally {
          hideLoader(); // Скрываем лоадер
          console.log(`[Action] handleToggleEmployeeStatus: End for employee ID ${employeeId}`);
     }
}

// --- Полное удаление сотрудника через API ---
async function handleDeleteEmployee(employeeId, employeeName) {
     console.log(`[Delete] handleDeleteEmployee: Start deleting ID ${employeeId} (${employeeName})`);
     showLoader(); // Показываем лоадер
     try {
         // TODO: Убедиться, что на бэкенде есть эндпоинт DELETE /employees/{id}
         //       и он корректно обрабатывает удаление (например, проверяет зависимости).

         // --- ВРЕМЕННАЯ ЗАГЛУШКА: Используем PATCH для деактивации ---
          console.warn(`[Delete] handleDeleteEmployee: Using PATCH to deactivate instead of DELETE (endpoint DELETE /employees/{id} should be implemented).`);
           await apiFetch(`/api/employees/${employeeId}`, {
                method: 'PATCH',
                body: JSON.stringify({ is_active: false }) // Просто деактивируем
           });
          alert(`Сотрудник "${employeeName}" был деактивирован (уволен).\n\nПримечание: Полное удаление данных пока не реализовано на сервере.`);
         // --- КОНЕЦ ЗАГЛУШКИ ---

         /* --- КОД ДЛЯ РЕАЛЬНОГО УДАЛЕНИЯ (когда будет готов бэкенд) ---
         console.log(`[Delete] Sending DELETE request for employee ID ${employeeId}`);
         await apiFetch(`/employees/${employeeId}`, { method: 'DELETE' });
         console.log(`[Delete] handleDeleteEmployee: Employee ID ${employeeId} deleted successfully.`);
         alert(`Сотрудник "${employeeName}" и все связанные с ним данные были успешно удалены.`);
         */

         await fetchAndRenderEmployees(); // Обновляем список сотрудников

     } catch (err) { // Обработка ошибок от apiFetch
          console.error("!!! [Delete] handleDeleteEmployee: Error", err);
          // Бэкенд может вернуть ошибку (400), если нельзя удалить сотрудника
          alert(`Ошибка удаления сотрудника "${employeeName}": ${err.message}`);
     } finally {
          hideLoader(); // Скрываем лоадер
          console.log("[Delete] handleDeleteEmployee: End");
     }
}

// === КОНЕЦ МОДУЛЯ ПЕРСОНАЛ ===

// =================================================================
// МОДУЛЬ: РОЛИ И ДОСТУПЫ (Владелец) (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг вкладки "Должности и Доступы" ---
// Вызывается из initializeMainAppUI, если у Владельца есть права 'manage_roles'
async function renderRolesTab() {
    console.log("[Render] renderRolesTab: Start");
    const pane = document.getElementById('tab-roles');
    if (!pane) {
        console.warn("[Render] renderRolesTab: Pane #tab-roles not found.");
        return; // Выходим, если контейнер вкладки не найден
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-1">
                <div class="bg-white p-6 rounded-lg shadow-md h-fit">
                    <h2 class="text-xl font-semibold mb-4">Добавить Новую Должность</h2>
                    <form id="add-role-form" class="space-y-3">
                        <label for="new-role-name" class="block text-sm font-medium text-gray-700">Название Должности *</label>
                        <input type="text" id="new-role-name" placeholder="Например: Менеджер, Кассир" class="w-full p-2 border rounded" required>
                        <button type="submit" class="w-full bg-indigo-600 text-white font-bold py-2 rounded-lg hover:bg-indigo-700">Создать Должность</button>
                    </form>
                </div>
            </div>
            <div class="md:col-span-2">
                 <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Существующие Должности</h2>
                    <div id="roles-list" class="space-y-3">Загрузка списка должностей...</div>
                </div>
            </div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addForm = document.getElementById('add-role-form');
    const rolesListDiv = document.getElementById('roles-list');

    if (addForm) {
        // Удаляем старые слушатели перед добавлением нового
        addForm.replaceWith(addForm.cloneNode(true));
        document.getElementById('add-role-form').addEventListener('submit', handleAddRole);
        console.log("[Listener OK] Added submit to #add-role-form");
    } else {
        console.error("!!! renderRolesTab: Element #add-role-form NOT FOUND after innerHTML.");
    }

    if (rolesListDiv) {
         // Используем делегирование событий для кнопок "Настроить"/"Удалить"
         const newRolesListDiv = rolesListDiv.cloneNode(false); // Клонируем пустой
         rolesListDiv.parentNode?.replaceChild(newRolesListDiv, rolesListDiv);
         newRolesListDiv.innerHTML = 'Загрузка списка должностей...'; // Восстанавливаем заглушку
         // Добавляем слушатель к НОВОМУ контейнеру
         newRolesListDiv.addEventListener('click', handleRoleActions);
         console.log("[Listener OK] Added click delegate listener to #roles-list");
    } else {
         console.error("!!! renderRolesTab: Element #roles-list NOT FOUND after innerHTML.");
    }
    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные
    await fetchAndRenderRoles();
    console.log("[Render] renderRolesTab: End");
}

// --- Загрузка и отображение списка Ролей и Прав ---
async function fetchAndRenderRoles() {
     console.log("[Fetch] fetchAndRenderRoles: Start");
     const listDiv = document.getElementById('roles-list'); // Ищем контейнер
     if (!listDiv) return;
     listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка должностей...</p>';
     // showLoader(); // Не используем глобальный лоадер

     try {
         // Загружаем Роли и Права ПАРАЛЛЕЛЬНО
         console.log("[Fetch] fetchAndRenderRoles: Fetching roles and permissions...");
         // Используем Promise.allSettled для надежности
         const results = await Promise.allSettled([
              apiFetch('/api/roles'), // Роли текущей компании
              // Права загружаем только если кэш пуст (они глобальные, но фильтруются на бэке)
              (!companyPermissions || companyPermissions.length === 0) ? apiFetch('/api/permissions') : Promise.resolve(companyPermissions)
         ]);

         // Обрабатываем результаты
         if (results[0].status === 'fulfilled') {
              companyRoles = results[0].value; // Обновляем кэш ролей
              console.log("[Fetch] fetchAndRenderRoles: Received roles:", companyRoles);
         } else {
               throw new Error(`Не удалось загрузить роли: ${results[0].reason?.message || results[0].reason}`);
         }
         if (results[1].status === 'fulfilled') {
              companyPermissions = results[1].value; // Обновляем кэш прав
              console.log("[Fetch] fetchAndRenderRoles: Received permissions:", companyPermissions);
         } else {
               // Не критично, если права не загрузились, но нужно предупредить
               console.warn(`[Fetch] fetchAndRenderRoles: Не удалось загрузить разрешения: ${results[1].reason?.message || results[1].reason}`);
               // Оставляем старый кэш прав, если он был
         }


         // Рендерим список ролей
         if (!companyRoles || companyRoles.length === 0) {
             listDiv.innerHTML = '<p class="text-gray-500">У вашей компании еще нет должностей (кроме "Владелец").</p>';
         } else {
             listDiv.innerHTML = companyRoles.map(role => `
                 <div class="p-3 bg-gray-50 rounded-md border flex flex-wrap justify-between items-center gap-2">
                     <p class="font-bold flex-grow text-lg">${role.name}</p>
                     <div class="flex-shrink-0 flex gap-2">
                         ${role.name !== 'Владелец' ? ` <button data-role-id="${role.id}" data-role-name="${role.name}" class="permissions-btn text-sm bg-blue-200 hover:bg-blue-300 text-blue-800 px-3 py-1 rounded">Настроить доступы</button>
                         <button data-role-id="${role.id}" data-role-name="${role.name}" class="delete-role-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded" title="Удалить должность">&times;</button>
                         ` : '<span class="text-sm text-gray-500">(Стандартная роль)</span>'}
                     </div>
                 </div>
             `).join('');
         }
         console.log("[Fetch] fetchAndRenderRoles: Success");
     } catch (e) {
         console.error("[Fetch] fetchAndRenderRoles: Error", e);
         listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки должностей: ${e.message}</p>`;
     } finally {
         // hideLoader();
     }
}

// --- Обработчик для формы "Добавить должность" ---
async function handleAddRole(e) {
    e.preventDefault(); // Предотвращаем перезагрузку
    console.log("[Role Action] handleAddRole: Start");
    const nameInput = document.getElementById('new-role-name');
    const roleName = nameInput ? nameInput.value.trim() : null;

    if (!roleName) {
        alert("Введите название для новой должности.");
        return;
    }
    showLoader(); // Показываем лоадер
    try {
        // Отправляем POST запрос на создание роли
        console.log(`[Role Action] Creating role: ${roleName}`);
        await apiFetch('/api/roles', {
            method: 'POST',
            body: JSON.stringify({ name: roleName }) // Отправляем только имя
        });
        console.log(`[Role Action] Role "${roleName}" created successfully.`);
        alert(`Должность "${roleName}" успешно создана!`);
        if(nameInput) nameInput.value = ''; // Очищаем поле ввода
        await fetchAndRenderRoles(); // Обновляем список ролей на странице
    } catch(err) { // Обработка ошибок от apiFetch
        console.error("[Role Action] handleAddRole: Error", err);
        alert(`Ошибка создания должности: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Role Action] handleAddRole: End");
    }
}

// --- Обработчик кликов по кнопкам в списке ролей (делегирование) ---
// Вызывается слушателем, добавленным в renderRolesTab
function handleRoleActions(e) {
     // Ищем ближайшую кнопку к месту клика
     const targetButton = e.target.closest('button');
     if (!targetButton) return; // Клик не по кнопке

     const roleId = targetButton.dataset.roleId;
     const roleName = targetButton.dataset.roleName;

     // Определяем действие по классу кнопки
     if (targetButton.classList.contains('permissions-btn')) {
         console.log(`[Role Action] Permissions button clicked for ID: ${roleId} (${roleName})`);
         openPermissionsModal(roleId, roleName); // Открываем окно настройки прав
     }
     else if (targetButton.classList.contains('delete-role-btn')) {
         console.log(`[Role Action] Delete button clicked for ID: ${roleId} (${roleName})`);
         // Запрашиваем подтверждение перед удалением
         if (confirm(`Вы уверены, что хотите удалить должность "${roleName}"?\n\nСотрудники с этой должностью потеряют доступ, соответствующий этой роли.`)) {
             handleDeleteRole(roleId, roleName); // Вызываем функцию удаления
         }
     }
}

// --- Функция удаления роли ---
async function handleDeleteRole(roleId, roleName) {
    console.log(`[Delete] handleDeleteRole: Start deleting ID ${roleId} (${roleName})`);
    showLoader();
    try {
        // Отправляем DELETE запрос на бэкенд
        await apiFetch(`/api/roles/${roleId}`, { method: 'DELETE' });
        console.log(`[Delete] handleDeleteRole: Role ID ${roleId} deleted successfully.`);
        alert(`Должность "${roleName}" успешно удалена.`);
        await fetchAndRenderRoles(); // Обновляем список ролей
    } catch(err) { // Обработка ошибок от apiFetch (включая 400, если роль используется)
        console.error("[Delete] handleDeleteRole: Error", err);
        alert(`Ошибка удаления должности "${roleName}": ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Delete] handleDeleteRole: End");
    }
}

// --- Открытие модального окна настройки прав доступа ---
async function openPermissionsModal(roleId, roleName) {
    console.log(`[Modal] openPermissionsModal: Start for Role ID ${roleId} (${roleName})`);
    const permissionsModal = document.getElementById('permissions-modal');
    if (!permissionsModal) return console.error("!!! openPermissionsModal: Modal element #permissions-modal not found!");
    const modalContent = permissionsModal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openPermissionsModal: Modal content not found!");

    modalContent.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка текущих прав...</p>';
    openModal('permissions-modal'); // Открываем модалку сразу с заглушкой
    // showLoader(); // Не используем глобальный лоадер

    try {
        // Проверяем наличие кэша прав, если нет - загружаем
        if (!companyPermissions || companyPermissions.length === 0) {
             console.log("[Modal] openPermissionsModal: Permissions cache empty, fetching...");
             companyPermissions = await apiFetch('/api/permissions');
             console.log("[Modal] openPermissionsModal: Permissions loaded:", companyPermissions);
             if (!companyPermissions || companyPermissions.length === 0) {
                   throw new Error("Не удалось загрузить список доступных разрешений.");
             }
        }

        // Получаем ТЕКУЩИЕ ID прав для ЭТОЙ роли
        console.log(`[Modal] openPermissionsModal: Fetching current permissions for Role ID ${roleId}...`);
        const currentPermissionIds = await apiFetch(`/api/roles/${roleId}/permissions`); // Бэкенд вернет массив ID
        const currentPermissionIdsSet = new Set(currentPermissionIds || []); // Создаем Set для быстрой проверки
        console.log(`[Modal] openPermissionsModal: Current permission IDs for Role ID ${roleId}:`, currentPermissionIdsSet);


        // Генерируем HTML для чекбоксов на основе кэша companyPermissions
        const permissionsHtml = companyPermissions.map(p => `
            <div class="flex items-center py-1">
                <input id="perm-${p.id}" type="checkbox" value="${p.id}"
                       class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 permission-checkbox"
                       ${currentPermissionIdsSet.has(p.id) ? 'checked' : ''}>
                <label for="perm-${p.id}" class="ml-3 block text-sm font-medium text-gray-700">${p.description}</label>
            </div>
        `).join('');

        // Устанавливаем HTML в модальное окно
        modalContent.innerHTML = `
            <div class="flex justify-between items-start mb-4">
                <h3 class="text-2xl font-bold">Настройка доступов для: <span class="text-indigo-600">${roleName}</span></h3>
                <button onclick="closeModal('permissions-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
            </div>
            <form id="permissions-form" data-role-id="${roleId}">
                <div class="space-y-2 max-h-[60vh] overflow-y-auto border rounded p-4 mb-4 bg-gray-50">
                     ${permissionsHtml || '<p class="text-gray-500">Нет доступных разрешений.</p>'}
                </div>
                <div class="flex gap-4 mt-6 border-t pt-4">
                    <button type="button" onclick="closeModal('permissions-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                    <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить Права</button>
                </div>
            </form>
        `;

        // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
        const formElement = document.getElementById('permissions-form');
        if (formElement) {
            formElement.replaceWith(formElement.cloneNode(true)); // Удаляем старые
            document.getElementById('permissions-form').addEventListener('submit', handleSavePermissions);
            console.log("[Modal Listener OK] Added submit to #permissions-form");
        } else {
            console.error("!!! openPermissionsModal: Form #permissions-form NOT FOUND after innerHTML!");
        }
        // --- Конец добавления слушателя ---

    } catch (err) { // Обработка ошибок загрузки прав
        console.error("[Modal] openPermissionsModal: Error loading permissions", err);
        modalContent.innerHTML = `
             <div class="flex justify-between items-start mb-4">
                 <h3 class="text-2xl font-bold">Ошибка</h3>
                 <button onclick="closeModal('permissions-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
             </div>
             <p class="text-red-500">Не удалось загрузить права доступа: ${err.message}</p>
             <div class="mt-4 text-right">
                  <button onclick="closeModal('permissions-modal')" class="bg-gray-200 py-2 px-4 rounded">Закрыть</button>
             </div>`;
    } finally {
        // hideLoader(); // Глобальный лоадер не используется
        console.log(`[Modal] openPermissionsModal: End for Role ID ${roleId}`);
    }
}

// --- Сохранение измененных прав доступа ---
async function handleSavePermissions(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Save Permissions] handleSavePermissions: Start");
    const form = e.target;
    const roleId = form.dataset.roleId;
    if (!roleId) {
         alert("Ошибка: Не удалось определить ID роли.");
         return;
    }

    // Собираем ID ВСЕХ отмеченных чекбоксов внутри формы
    const selectedPermissionIds = Array.from(form.querySelectorAll('.permission-checkbox:checked'))
                                     .map(checkbox => parseInt(checkbox.value));

    console.log(`[Save Permissions] Saving permissions for Role ID ${roleId}. Selected IDs:`, selectedPermissionIds);
    showLoader(); // Показываем лоадер

    try {
        // Отправляем PUT запрос на бэкенд со списком ID
        await apiFetch(`/api/roles/${roleId}/permissions`, {
            method: 'PUT',
            body: JSON.stringify({ permission_ids: selectedPermissionIds })
        });
        console.log(`[Save Permissions] Permissions saved successfully for Role ID ${roleId}.`);
        alert('Права доступа успешно обновлены!');
        closeModal('permissions-modal'); // Закрываем модальное окно
        // Перезагружать список ролей не нужно, так как мы меняли только права

    } catch(err) { // Обработка ошибок от apiFetch
        console.error("[Save Permissions] handleSavePermissions: Error", err);
        alert(`Ошибка сохранения прав доступа: ${err.message}`);
        // Оставляем модальное окно открытым для повторной попытки
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Save Permissions] handleSavePermissions: End");
    }
}

// =================================================================
// МОДУЛЬ: КЛИЕНТЫ (Владелец) (v4.1 - Rebuild)
// =================================================================

companyClients = []; // Кэш для хранения списка клиентов текущей компании

// --- Рендеринг вкладки "Клиенты" ---
// Вызывается из initializeMainAppUI, если у Владельца есть права 'manage_clients'
async function renderClientsTab() {
    console.log("[Render] renderClientsTab: Start");
    const pane = document.getElementById('tab-clients');
    if (!pane) {
        console.warn("[Render] renderClientsTab: Pane #tab-clients not found.");
        return; // Выходим, если контейнер вкладки не найден
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold text-gray-800">Клиенты Компании</h2>
                <div class="flex items-center gap-4">
                     <button id="client-tools-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg text-sm">🛠️ Инструменты</button>
                    <button id="add-client-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 text-sm">➕ Добавить клиента</button>
                </div>
            </div>
            <div class="mb-4">
                <input type="search" id="clients-search-input" placeholder="🔍 Поиск по имени, телефону, коду..." class="w-full p-2 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div id="clients-list" class="space-y-3">Загрузка списка клиентов...</div>
        </div>
        `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addBtn = document.getElementById('add-client-btn');
    const searchInput = document.getElementById('clients-search-input');
    const clientListDiv = document.getElementById('clients-list');
    const toolsBtn = document.getElementById('client-tools-btn');

    // Кнопка "Добавить клиента"
    if (addBtn) {
        addBtn.replaceWith(addBtn.cloneNode(true)); // Удаляем старые слушатели
        document.getElementById('add-client-btn').addEventListener('click', () => openClientModal()); // Открывает пустую модалку
        console.log("[Listener OK] Added click to #add-client-btn");
    } else {
        console.error("!!! renderClientsTab: Element #add-client-btn NOT FOUND.");
    }

    // Поле поиска
    if (searchInput) {
         searchInput.replaceWith(searchInput.cloneNode(true));
         document.getElementById('clients-search-input').addEventListener('input', handleClientsSearch); // Фильтрует список при вводе
         console.log("[Listener OK] Added input listener to #clients-search-input");
    } else {
         console.error("!!! renderClientsTab: Element #clients-search-input NOT FOUND.");
    }

    // Список клиентов (для кнопок Редакт/Удалить/ЛК через делегирование)
    if (clientListDiv) {
         const newClientListDiv = clientListDiv.cloneNode(false);
         clientListDiv.parentNode?.replaceChild(newClientListDiv, clientListDiv);
         newClientListDiv.innerHTML = 'Загрузка списка клиентов...';
         newClientListDiv.addEventListener('click', handleClientListActions); // Обрабатывает клики внутри списка
         console.log("[Listener OK] Added click delegate listener to #clients-list");
    } else {
         console.error("!!! renderClientsTab: Element #clients-list NOT FOUND.");
    }

    // Кнопка "Инструменты"
    if (toolsBtn) {
         toolsBtn.replaceWith(toolsBtn.cloneNode(true));
         document.getElementById('client-tools-btn').addEventListener('click', () => {
             // Очищаем результаты импорта и сбрасываем файл перед открытием
             const resultsDiv = document.getElementById('client-import-results');
             const fileInput = document.getElementById('client-excel-input');
             if (resultsDiv) resultsDiv.innerHTML = '';
             if (fileInput) fileInput.value = '';
             openModal('client-tools-modal'); // Открываем модальное окно инструментов
         });
         console.log("[Listener OK] Added click to #client-tools-btn");
    } else {
         console.error("!!! renderClientsTab: Element #client-tools-btn NOT FOUND.");
    }

    // Слушатель для кнопки "Импортировать" внутри модалки client-tools-modal
    // добавляется в initializeGlobalEventListeners, т.к. модалка статична.

    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные клиентов
    await fetchAndRenderClients();
    console.log("[Render] renderClientsTab: End");
}

// --- Загрузка и отображение списка Клиентов ---
async function fetchAndRenderClients() {
    console.log("[Fetch] fetchAndRenderClients: Start");
    const listDiv = document.getElementById('clients-list'); // Ищем контейнер
    if (!listDiv) return;
    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка клиентов...</p>';
    // showLoader(); // Не показываем глобальный лоадер

    try {
        // Запрашиваем клиентов текущей компании
        const clients = await apiFetch('/api/clients');
        companyClients = clients; // Обновляем кэш
        console.log("[Fetch] fetchAndRenderClients: Received clients:", clients);

        if (!clients || clients.length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">У вашей компании еще нет клиентов.</p>';
        } else {
            // Генерируем HTML для каждого клиента
            listDiv.innerHTML = clients.map(c => `
                <div class="client-list-item p-3 bg-gray-50 rounded-md border flex flex-wrap justify-between items-center gap-2"
                     data-client-name="${c.full_name}"
                     data-client-phone="${c.phone}"
                     data-client-code="${(c.client_code_prefix || '') + (c.client_code_num || '')}">
                    <div class="flex-grow min-w-[200px]"> <p class="font-bold text-lg">${c.full_name} (${c.client_code_prefix || ''}${c.client_code_num || 'Нет кода'})</p>
                        <p class="text-sm text-gray-600">${c.phone} ${c.telegram_chat_id ? '<span class="text-blue-500 font-bold text-xs" title="Telegram привязан"> (TG)</span>' : ''}</p>
                        <p class="text-xs text-gray-500">Статус: ${c.status || 'Розница'}</p>
                    </div>
                    <div class="flex-shrink-0 flex gap-2">
                        <button data-client-id="${c.id}" class="lk-link-client-btn text-sm bg-blue-100 hover:bg-blue-200 text-blue-800 px-3 py-1 rounded" title="Получить ссылку на Личный Кабинет">🔗ЛК</button>
                        <button data-client-id="${c.id}" data-client-json='${JSON.stringify(c)}' class="edit-client-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">Редакт.</button>
                        <button data-client-id="${c.id}" data-client-name="${c.full_name}" class="delete-client-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">Удалить</button>
                    </div>
                </div>
            `).join('');
            // Слушатели для кнопок добавляются через делегирование на #clients-list
        }
        console.log("[Fetch] fetchAndRenderClients: Success");
    } catch (e) {
        console.error("[Fetch] fetchAndRenderClients: Error", e);
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки клиентов: ${e.message}</p>`;
    } finally {
        // hideLoader();
    }
}

// --- Открытие модального окна Клиента (для создания или редактирования) ---
function openClientModal(client = null) {
    console.log("[Modal] openClientModal: Start", client);
    const modal = document.getElementById('client-modal');
    if (!modal) return console.error("!!! openClientModal: Modal element #client-modal not found!");
    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openClientModal: Modal content not found!");

    const isEdit = client !== null; // true, если переданы данные для редактирования

    // Генерируем HTML для модального окна
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold">${isEdit ? 'Редактировать клиента' : 'Добавить нового клиента'}</h3>
            <button onclick="closeModal('client-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
        </div>
        <form id="client-form-inner" class="space-y-4">
             <input type="hidden" id="modal-client-id" value="${isEdit ? client.id : ''}">
            <div>
                <label for="modal-client-full_name" class="block text-sm font-medium text-gray-700">ФИО *</label>
                <input type="text" id="modal-client-full_name" value="${isEdit ? client.full_name : ''}" class="mt-1 w-full p-2 border rounded" required>
            </div>
            <div>
                <label for="modal-client-phone" class="block text-sm font-medium text-gray-700">Телефон *</label>
                <input type="text" id="modal-client-phone" value="${isEdit ? client.phone : ''}" placeholder="Например: 996555123456 или 0555123456" class="mt-1 w-full p-2 border rounded" required>
            </div>
            <div class="grid grid-cols-3 gap-2">
                <div>
                    <label for="modal-client-prefix" class="block text-sm font-medium text-gray-700">Префикс Кода</label>
                    <input type="text" id="modal-client-prefix" value="${isEdit ? (client.client_code_prefix || '') : (currentCompany?.company_code || 'KB')}" class="mt-1 w-full p-2 border rounded uppercase" maxlength="5">
                </div>
                <div class="col-span-2">
                    <label for="modal-client-code" class="block text-sm font-medium text-gray-700">Номер Кода</label>
                    <input type="number" id="modal-client-code" value="${isEdit ? (client.client_code_num || '') : ''}" class="mt-1 w-full p-2 border rounded" placeholder="${isEdit ? 'Можно менять' : 'Авто (если пусто)'}">
                    <p class="text-xs text-gray-500 mt-1">Оставьте пустым при создании для авто-генерации.</p>
                </div>
            </div>
             <div>
                <label for="modal-client-status" class="block text-sm font-medium text-gray-700">Статус клиента</label>
                <input type="text" id="modal-client-status" value="${isEdit ? (client.status || 'Розница') : 'Розница'}" class="mt-1 w-full p-2 border rounded" placeholder="Например: Розница, Опт">
            </div>
             ${isEdit ? `
             <div class="text-sm ${client.telegram_chat_id ? 'text-green-600 font-semibold' : 'text-gray-500'}">
                <span class="font-medium">Telegram:</span> ${client.telegram_chat_id ? `Привязан (${client.telegram_chat_id})` : 'Не привязан (клиент должен привязать сам в боте)'}
                ${client.telegram_chat_id ? '<button type="button" id="modal-client-unlink-tg" class="ml-2 text-xs text-red-500 underline hover:text-red-700">Отвязать</button>' : ''}
             </div>` : ''}
            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('client-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
            </div>
        </form>
    `;

    // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
    const formElement = document.getElementById('client-form-inner');
    if (formElement) {
        formElement.replaceWith(formElement.cloneNode(true)); // Удаляем старые
        document.getElementById('client-form-inner').addEventListener('submit', handleSaveClient);
        console.log("[Modal Listener OK] Added submit to #client-form-inner");
        // Добавляем слушатель для кнопки отвязки TG, если она есть
        const unlinkBtn = document.getElementById('modal-client-unlink-tg');
        if (unlinkBtn) {
            unlinkBtn.addEventListener('click', () => handleUnlinkTelegram(client?.id));
        }
    } else {
        console.error("!!! openClientModal: Form #client-form-inner NOT FOUND after innerHTML!");
    }
    // --- Конец добавления слушателя ---

    openModal('client-modal'); // Открываем модальное окно
    console.log("[Modal] openClientModal: End");
}

// --- Сохранение данных Клиента (вызывается из модального окна) ---

async function handleSaveClient(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Save] handleSaveClient: Start");
    showLoader(); // Показываем лоадер

    // Считываем ID (для определения режима - создание/редактирование)
    const clientId = document.getElementById('modal-client-id')?.value;
    const isEdit = !!clientId; // true, если ID есть
    
    // !!! КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: ДОБАВЛЕНИЕ ПРЕФИКСА /api !!!
    // Создание: /api/clients (POST)
    // Редактирование: /api/clients/{id} (PATCH)
    const url = isEdit ? `/api/clients/${clientId}` : '/api/clients'; 
    const method = isEdit ? 'PATCH' : 'POST'; 
    // ... (Остальной код остается)
    
    // Собираем данные из полей модального окна
    const payload = {
        full_name: document.getElementById('modal-client-full_name')?.value.trim(),
        phone: document.getElementById('modal-client-phone')?.value.trim(),
        // Префикс: берем введенный ИЛИ код компании ИЛИ 'KB'
        client_code_prefix: document.getElementById('modal-client-prefix')?.value.trim().toUpperCase() || (currentCompany?.company_code) || 'KB',
        // Номер кода: null если пусто или 0
        client_code_num: parseInt(document.getElementById('modal-client-code')?.value) || null,
        // Вы указали "Оптовик" — статус передается как есть
        status: document.getElementById('modal-client-status')?.value.trim() || 'Розница' 
    };

    // Удаляем номер кода из payload при СОЗДАНИИ, если он null (чтобы сработала авто-генерация на бэке)
     if (!isEdit && payload.client_code_num === null) {
         delete payload.client_code_num;
     }

    // Валидация: проверяем наличие ФИО и Телефона
    if (!payload.full_name || !payload.phone) {
         hideLoader();
         alert("ФИО и Телефон обязательны для заполнения.");
         return; 
    }

    try {
        // Отправляем запрос на сервер
        console.log(`[Save] handleSaveClient: Sending ${method} to ${url}`, payload);
        const result = await apiFetch(url, { method: method, body: JSON.stringify(payload) });
        console.log("[Save] handleSaveClient: Server response", result);

        // Обработка успеха
        alert(isEdit ? 'Данные клиента успешно обновлены!' : 'Новый клиент успешно создан!');
        closeModal('client-modal'); // Закрываем модальное окно
        await fetchAndRenderClients(); // Обновляем список клиентов на странице

    } catch(err) { // Обработка ошибок (от валидации или от apiFetch)
        console.error("!!! [Save] handleSaveClient: Error", err);
        alert(`Ошибка сохранения данных клиента: ${err.message}`);
        // Оставляем модальное окно открытым для исправления
    } finally {
        // --- Скрываем лоадер в любом случае ---
        hideLoader();
        console.log("[Save] handleSaveClient: End");
    }
}

// --- Обработка кликов в списке клиентов (делегирование) ---
// Вызывается слушателем, добавленным в renderClientsTab
function handleClientListActions(e) {
    const targetButton = e.target.closest('button'); // Ищем ближайшую кнопку
    if (!targetButton) return; // Клик не по кнопке

    const clientId = targetButton.dataset.clientId; // ID клиента из data-атрибута

    // Определяем действие по классу кнопки
    if (targetButton.classList.contains('edit-client-btn')) {
        console.log(`[Action] Edit client button clicked for ID: ${clientId}`);
        try {
             // Извлекаем данные клиента из data-атрибута кнопки Редактировать
             const clientData = JSON.parse(targetButton.dataset.clientJson);
             openClientModal(clientData); // Открываем модалку для редактирования
        } catch (err) {
             console.error("Error parsing client data for edit:", err);
             // Пытаемся найти в кэше как запасной вариант
              const clientToEdit = companyClients.find(c => c.id == clientId);
              if (clientToEdit) {
                  openClientModal(clientToEdit);
              } else {
                  alert("Ошибка: Не удалось прочитать данные клиента для редактирования.");
              }
        }
    }
    else if (targetButton.classList.contains('delete-client-btn')) {
        console.log(`[Action] Delete client button clicked for ID: ${clientId}`);
        const clientName = targetButton.dataset.clientName;
        // Запрашиваем подтверждение
        if (confirm(`Удалить клиента "${clientName}"?\n\nВНИМАНИЕ: Это действие необратимо! Заказы клиента останутся в системе, но будут отвязаны.`)) {
            handleDeleteClient(clientId, clientName); // Вызываем функцию удаления
        }
    }
     else if (targetButton.classList.contains('lk-link-client-btn')) {
        console.log(`[Action] LK link button clicked for ID: ${clientId}`);
        handleGenerateLkLink(clientId); // Вызываем функцию генерации ссылки ЛК
    }
}

// --- Функция удаления клиента ---
async function handleDeleteClient(clientId, clientName) {
    console.log(`[Delete] handleDeleteClient: Start deleting ID ${clientId} (${clientName})`);
    showLoader();
    try {
        // Отправляем DELETE запрос на бэкенд
        await apiFetch(`/api/clients/${clientId}`, { method: 'DELETE' });
        console.log(`[Delete] handleDeleteClient: Client ID ${clientId} deleted successfully.`);
        alert(`Клиент "${clientName}" успешно удален.`);
        await fetchAndRenderClients(); // Обновляем список клиентов
    } catch (err) { // Обработка ошибок от apiFetch (включая 400, если есть активные заказы)
        console.error("[Delete] handleDeleteClient: Error", err);
        alert(`Ошибка удаления клиента "${clientName}": ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Delete] handleDeleteClient: End");
    }
}

// --- Функция генерации и показа ссылки на ЛК ---
async function handleGenerateLkLink(clientId) {
     console.log(`[Action] handleGenerateLkLink: Start for Client ID ${clientId}`);
     showLoader();
     try {
         // Отправляем POST запрос (как указано в main.py)
         const response = await apiFetch(`/api/clients/${clientId}/generate_lk_link`, { method: 'POST' });
         console.log(`[Action] handleGenerateLkLink: Received link: ${response.link}`);
         // Показываем ссылку в prompt для удобного копирования
         // prompt() может блокировать интерфейс, можно заменить на показ в модальном окне или просто копирование в буфер
         prompt(`Ссылка на Личный Кабинет клиента (Нажмите Ctrl+C / Cmd+C для копирования):`, response.link);
         // navigator.clipboard.writeText(response.link).then(() => alert("Ссылка скопирована в буфер обмена!"), () => alert("Не удалось скопировать ссылку.")); // Вариант с копированием
     } catch (err) { // Обработка ошибок от apiFetch
         console.error("[Action] handleGenerateLkLink: Error", err);
         alert(`Ошибка генерации ссылки на Личный Кабинет: ${err.message}`);
     } finally {
         hideLoader(); // Скрываем лоадер
         console.log(`[Action] handleGenerateLkLink: End for Client ID ${clientId}`);
     }
 }

// --- Функция отвязки Telegram ID ---
async function handleUnlinkTelegram(clientId) {
     if (!clientId) return;
     console.log(`[Action] handleUnlinkTelegram: Start for Client ID ${clientId}`);
     if (confirm("Вы уверены, что хотите отвязать Telegram аккаунт этого клиента?\nОн сможет привязать его снова через бота.")) {
          showLoader();
          try {
               // Отправляем PATCH запрос, устанавливая telegram_chat_id в null
               await apiFetch(`/api/clients/${clientId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ telegram_chat_id: null })
               });
               console.log(`[Action] handleUnlinkTelegram: Success for Client ID ${clientId}`);
               alert("Telegram аккаунт успешно отвязан.");
               closeModal('client-modal'); // Закрываем модалку
               await fetchAndRenderClients(); // Обновляем список
          } catch (err) {
               console.error("[Action] handleUnlinkTelegram: Error", err);
               alert(`Ошибка отвязки Telegram: ${err.message}`);
          } finally {
               hideLoader();
          }
     }
}


// --- Функция поиска клиентов (фильтрует отображение списка) ---
function handleClientsSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim(); // Получаем поисковый запрос
    console.log(`[Search] handleClientsSearch: Term = "${searchTerm}"`);
    const clientItems = document.querySelectorAll('#clients-list .client-list-item'); // Находим все элементы списка

    clientItems.forEach(item => {
        // Извлекаем данные для поиска из data-атрибутов элемента
        const name = item.dataset.clientName?.toLowerCase() || '';
        const phone = item.dataset.clientPhone?.toLowerCase() || '';
        const code = item.dataset.clientCode?.toLowerCase() || '';

        // Проверяем, содержит ли хотя бы одно поле поисковый запрос
        const isMatch = name.includes(searchTerm) ||
                        phone.includes(searchTerm) ||
                        code.includes(searchTerm);

        // Показываем или скрываем элемент в зависимости от результата поиска
        item.style.display = isMatch ? 'flex' : 'none'; // Используем 'flex', так как в CSS используется flexbox
    });
    console.log(`[Search] handleClientsSearch: Filtering complete.`);
}


// --- Обработка импорта клиентов из Excel ---
// Вызывается слушателем, добавленным в initializeGlobalEventListeners
async function handleClientExcelImport() {
    console.log("[Import] handleClientExcelImport: Start");
    const fileInput = document.getElementById('client-excel-input');
    const resultsDiv = document.getElementById('client-import-results');
    if (!resultsDiv) return console.error("!!! Import Error: resultsDiv #client-import-results not found!");

    resultsDiv.innerHTML = '<p class="text-blue-600 animate-pulse">Обработка файла...</p>';

    // Проверяем, выбран ли файл
    if (!fileInput || fileInput.files.length === 0) {
        resultsDiv.innerHTML = '<p class="text-red-500">Ошибка: Выберите Excel-файл.</p>';
        return;
    }
    const file = fileInput.files[0];
    console.log(`[Import] Selected file: ${file.name}, size: ${file.size} bytes`);
    showLoader(); // Показываем глобальный лоадер

    try {
        // --- Шаг 1: Чтение данных из Excel файла ---
        console.log("[Import] Reading Excel file...");
        const jsonData = await readExcelFile(file); // Используем утилиту
        console.log(`[Import] Excel read successfully. Found ${jsonData.length} rows.`);

        if (jsonData.length === 0) {
            resultsDiv.innerHTML = '<p class="text-yellow-600">Файл пуст или не содержит данных на первом листе.</p>';
            return; // Выходим, если данных нет
        }

        // --- Шаг 2: Проверка наличия обязательных колонок ---
        const firstRow = jsonData[0];
        if (!firstRow || !firstRow.hasOwnProperty('full_name') || !firstRow.hasOwnProperty('phone')) {
             console.error("[Import] Validation failed: Missing 'full_name' or 'phone' column.");
             resultsDiv.innerHTML = '<p class="text-red-500">Ошибка: Файл должен содержать колонки "full_name" и "phone". Проверьте названия заголовков (регистр не важен).</p>';
             return;
        }
        console.log("[Import] Required columns found.");

        // --- Шаг 3: Подготовка данных для отправки ---
        resultsDiv.innerHTML = `<p class="text-blue-600">Подготовка ${jsonData.length} записей для отправки...</p>`;
        const dataToSend = jsonData.map(row => ({
            // Преобразуем к строке, удаляем пробелы, берем null если поле отсутствует
            full_name: String(row.full_name || '').trim() || null,
            phone: String(row.phone || '').trim() || null,
            // client_code передаем как есть (строкой), бэкенд разберет
            client_code: row.client_code ? String(row.client_code).trim() : null
        })).filter(item => item.full_name && item.phone); // Отфильтровываем строки без имени или телефона

        if (dataToSend.length === 0) {
             console.warn("[Import] No valid rows found after filtering.");
             resultsDiv.innerHTML = '<p class="text-yellow-600">Не найдено корректных строк с ФИО и телефоном для импорта.</p>';
             return;
        }
        console.log(`[Import] Prepared ${dataToSend.length} valid records for sending.`);

        // --- Шаг 4: Отправка данных на БЭКЕНД ---
        resultsDiv.innerHTML = `<p class="text-blue-600 animate-pulse">Отправка ${dataToSend.length} записей на сервер... Это может занять некоторое время.</p>`;
        const response = await apiFetch('/api/clients/bulk_import', {
            method: 'POST',
            body: JSON.stringify(dataToSend) // Отправляем массив объектов
        });
        console.log("[Import] Server response:", response);

        // --- Шаг 5: Отображение результата ---
        let resultHtml = `<p class="text-green-600 font-semibold"><strong>Импорт завершен! Успешно создано: ${response.created_clients || 0}</strong></p>`;
        // Добавляем предупреждения (например, о дубликатах)
        if (response.warnings && response.warnings.length > 0) {
             resultHtml += `<p class="text-yellow-600 mt-2 font-semibold"><strong>Предупреждения (${response.warnings.length}):</strong></p><ul class="list-disc list-inside text-xs">${response.warnings.map(w => `<li>${w}</li>`).join('')}</ul>`;
        }
        // Добавляем ошибки (например, невалидные данные)
        if (response.errors && response.errors.length > 0) {
            resultHtml += `<p class="text-red-600 mt-2 font-semibold"><strong>Ошибки (${response.errors.length}):</strong></p><ul class="list-disc list-inside text-xs">${response.errors.map(er => `<li>${er}</li>`).join('')}</ul>`;
        }
        resultsDiv.innerHTML = resultHtml; // Показываем результат в модальном окне

        // --- Шаг 6: Обновление списка клиентов на основной вкладке ---
        if (response.created_clients > 0) {
             console.log("[Import] Refreshing client list...");
             await fetchAndRenderClients(); // Перезагружаем список
        }

    } catch (error) { // Обработка ошибок чтения файла или запроса к API
        console.error("!!! [Import] handleClientExcelImport: CRITICAL ERROR", error);
        resultsDiv.innerHTML = `<p class="text-red-500"><b>Критическая ошибка импорта:</b> ${error.message}</p>`;
    } finally {
        hideLoader(); // Прячем общий лоадер
        if (fileInput) fileInput.value = ''; // Сбрасываем выбор файла в любом случае
        console.log("[Import] handleClientExcelImport: End");
    }
}

// === КОНЕЦ МОДУЛЯ КЛИЕНТЫ ===

// =================================================================
// МОДУЛЬ: ЗАКАЗЫ (Владелец) (v4.1 - Rebuild - Полная версия)
// =================================================================

companyOrders = []; // Кэш для заказов компании (обновляется при загрузке/фильтрации)
// let orderStatuses = ["В обработке", ...]; // Уже определен глобально
// let availablePartyDates = []; // Уже определен глобально

// --- Рендеринг основной вкладки Заказов ---
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ renderOrdersTab)

async function renderOrdersTab() {
    console.log("[Render] renderOrdersTab: Start");
    const pane = document.getElementById('tab-orders');
    if (!pane) {
        console.warn("[Render] renderOrdersTab: Pane #tab-orders not found.");
        return;
    }

    // Загружаем статусы, даты партий И ФИЛИАЛЫ ПЕРЕД рендерингом HTML
    try {
        console.log("[Render] renderOrdersTab: Preloading party dates and locations...");
        // Используем Promise.allSettled для надежности
        const results = await Promise.allSettled([
            Promise.resolve(orderStatuses), // Статусы из глоб. переменной
            // Загружаем даты партий, если кэш пуст
            (!availablePartyDates || availablePartyDates.length === 0) ? apiFetch('/api/orders/parties') : Promise.resolve(availablePartyDates),
            // Загружаем филиалы, если кэш пуст (нужны для фильтра)
            (!companyLocations || companyLocations.length === 0) ? apiFetch('/api/locations') : Promise.resolve(companyLocations)
        ]);

        if (results[0].status === 'fulfilled') orderStatuses = results[0].value;
        if (results[1].status === 'fulfilled') availablePartyDates = results[1].value; else console.warn("[Render] renderOrdersTab: Failed to preload party dates:", results[1].reason);
        if (results[2].status === 'fulfilled') companyLocations = results[2].value; else console.warn("[Render] renderOrdersTab: Failed to preload locations:", results[2].reason);

        console.log("[Render] renderOrdersTab: Data loaded/updated.");
    } catch (e) {
        console.error("[Render] renderOrdersTab: Error preloading data:", e);
        // Не прерываем рендеринг, но фильтр филиалов может быть недоступен
    }

    // --- Генерируем HTML для фильтра филиалов (только для Владельца) ---
    let locationFilterHtml = '';
    // Показываем, если Владелец И филиалов БОЛЬШЕ одного
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            `<option value="${loc.id}">${loc.name}</option>`
        ).join('');
        
        locationFilterHtml = `
            <div class="p-2 bg-gray-100 rounded-md shadow-sm relative">
                <label for="orders-location-filter" class="text-xs font-medium text-gray-700 mr-2">Филиал:</label>
                <select id="orders-location-filter" class="rounded-md border-gray-300 p-1.5 text-xs bg-white shadow-sm w-36"> {/* Задаем ширину */}
                    <option value="">-- Все филиалы --</option> 
                    ${locationOptions}
                </select>
            </div>
        `;
        console.log("[Render] renderOrdersTab: Location filter HTML generated.");
    } else {
         console.log("[Render] renderOrdersTab: Location filter not needed or not enough locations.");
    }
    // --- КОНЕЦ ГЕНЕРАЦИИ ФИЛЬТРА ФИЛИАЛОВ ---

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <div class="lg:col-span-1 space-y-6">
                
                 <div class="bg-white p-6 rounded-lg shadow-md h-fit border">
                    <h2 class="text-xl font-semibold mb-4 text-gray-800">Добавить заказ</h2>
                    <form id="add-order-form" class="space-y-4">
                        <div class="relative">
                            <label for="order-client-search-input" class="block text-sm font-medium text-gray-700">Клиент (поиск)</label>
                            <input type="text" id="order-client-search-input" autocomplete="off" placeholder="Имя, телефон или код..." class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500">
                            <input type="hidden" id="order-selected-client-id">
                            <div id="order-client-search-results" class="absolute hidden top-full left-0 right-0 bg-white border mt-1 rounded-md shadow-lg z-20 max-h-48 overflow-y-auto"></div>
                        </div>
                        <div> <label for="order-track-code" class="block text-sm font-medium text-gray-700">Трек-код</label> <input type="text" id="order-track-code" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" placeholder="Обязательно для Доставки"> </div>
                        <div> <label for="order-party-date" class="block text-sm font-medium text-gray-700">Дата Партии</label> <input type="date" id="order-party-date" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500"> </div>
                        <div> <label for="order-purchase-type" class="block text-sm font-medium text-gray-700">Тип заказа</label> <select id="order-purchase-type" required class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500"> <option value="Доставка" selected>Доставка</option> <option value="Выкуп">Выкуп</option> </select> </div>
                    ${currentUser.role === 'Владелец' && companyLocations.length > 0 ? `
                    <div>
                        <label for="order-location-select" class="block text-sm font-medium text-gray-700">Филиал *</label>
                        <select id="order-location-select" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500">
                                ${companyLocations.map(loc => `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`).join('')}
                        </select>
                        <p class="text-xs text-gray-500 mt-1">Выберите филиал, к которому относится заказ.</p>
                    </div>
                    ` : ''}
                        <div id="order-buyout-fields" class="hidden space-y-3 border-t pt-4 mt-4"> <h4 class="text-sm font-semibold text-gray-600">Данные для выкупа:</h4> <div> <label for="order-buyout-cost" class="block text-xs font-medium text-gray-600">Стоимость товара (CNY)</label> <input type="number" step="any" id="order-buyout-cost" class="mt-1 w-full p-2 border rounded text-sm"> </div> <div> <label for="order-buyout-rate" class="block text-xs font-medium text-gray-600">Курс для клиента (сом/юань)</label> <input type="number" step="any" id="order-buyout-rate" class="mt-1 w-full p-2 border rounded text-sm"> </div> <div> <label for="order-buyout-commission" class="block text-xs font-medium text-gray-600">Комиссия (%)</label> <input type="number" step="1" id="order-buyout-commission" value="10" class="mt-1 w-full p-2 border rounded text-sm"> </div> </div>
                        <div> <label for="order-comment" class="block text-sm font-medium text-gray-700">Комментарий</label> <textarea id="order-comment" class="mt-1 w-full p-2 border rounded h-16 focus:ring-indigo-500 focus:border-indigo-500" placeholder="Цвет, размер, особенности..."></textarea> </div>
                        <button type="submit" class="w-full bg-green-600 text-white font-bold py-2 rounded hover:bg-green-700 transition-colors duration-150">Создать Заказ</button>
                    </form>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md h-fit border">
                     <h2 class="text-xl font-semibold mb-4 text-gray-800">Импорт заказов из Excel</h2>
                     <p class="text-xs text-gray-600 mb-1">Колонки: <strong>track_code</strong>*, <strong>client_code</strong> (или <strong>phone</strong>).</p> <p class="text-xs text-gray-600 mb-4">Необязательно: <strong>comment</strong>, <strong>purchase_type</strong>, <strong>buyout_item_cost_cny</strong>, <strong>buyout_rate_for_client</strong>, <strong>buyout_commission_percent</strong>.</p>
                     <div class="space-y-3 mb-4"> <label for="import-order-party-date" class="block text-sm font-medium text-gray-700">Общая Дата партии (если нет в файле)</label> <input type="date" id="import-order-party-date" class="mt-1 w-full p-2 border rounded"> </div>
                     ${currentUser.role === 'Владелец' && companyLocations.length > 0 ? `
                     <div class="space-y-3 mb-4">
                         <label for="import-location-select" class="block text-sm font-medium text-gray-700">Импортировать в филиал *</label>
                         <select id="import-location-select" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500">
                             ${companyLocations.map(loc => `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`).join('')}
                         </select>
                     </div>
                     ` : ''}
                     <label for="order-excel-input" class="block text-sm font-medium text-gray-700 mb-2">Выберите файл (.xlsx, .xls)</label> <input type="file" id="order-excel-input" accept=".xlsx, .xls" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 cursor-pointer"/> <button id="import-orders-btn" class="mt-4 w-full bg-blue-600 text-white font-bold py-2 rounded-lg hover:bg-blue-700 transition-colors duration-150">Импортировать Заказы</button> <div id="order-import-results" class="mt-4 text-xs max-h-40 overflow-y-auto border p-2 bg-gray-50 rounded"></div>
                 </div>
            </div>

            
            <div class="lg:col-span-2 bg-white p-6 rounded-lg shadow-md border">
                
                 <div id="orders-action-header" class="sticky top-0 bg-white py-3 mb-4 border-b -mx-6 px-6 flex flex-wrap justify-between items-center gap-2 z-10">
                    <div class="flex items-center gap-2 flex-wrap">
                        
                        <button id="orders-toggle-select-mode-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-indigo-600 hover:bg-indigo-100 text-sm transition-colors duration-150" title="Включить/выключить режим выбора заказов">✅ Выбрать</button>
                        
                        <div class="relative"> <button id="orders-toggle-party-filter-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-indigo-600 hover:bg-indigo-100 text-sm transition-colors duration-150">🗳️ Партии</button> <div id="orders-party-filter-container" class="hidden absolute top-full mt-2 bg-white border rounded-lg shadow-lg p-3 w-60 z-30"> <p class="font-semibold mb-2 text-sm text-gray-700">Фильтр по партиям:</p> <div id="orders-party-list" class="space-y-1 max-h-60 overflow-y-auto mb-2 text-sm">Загрузка...</div> <div class="flex gap-2"> <button id="orders-apply-party-filter" class="flex-1 bg-indigo-600 text-white text-xs py-1.5 rounded hover:bg-indigo-700">Применить</button> <button id="orders-reset-party-filter" class="flex-1 bg-gray-300 text-black text-xs py-1.5 rounded hover:bg-gray-400">Сброс</button> </div> </div> </div>
                        
                        <div class="relative"> <button id="orders-toggle-status-filter-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-indigo-600 hover:bg-indigo-100 text-sm transition-colors duration-150">🟢 Статусы</button> <div id="orders-status-filter-container" class="hidden absolute top-full mt-2 bg-white border rounded-lg shadow-lg p-3 w-60 z-30"> <p class="font-semibold mb-2 text-sm text-gray-700">Фильтр по статусам:</p> <div id="orders-status-list" class="space-y-1 max-h-60 overflow-y-auto mb-2 text-sm">Загрузка...</div> <div class="flex gap-2"> <button id="orders-apply-status-filter" class="flex-1 bg-indigo-600 text-white text-xs py-1.5 rounded hover:bg-indigo-700">Применить</button> <button id="orders-reset-status-filter" class="flex-1 bg-gray-300 text-black text-xs py-1.5 rounded hover:bg-gray-400">Сброс</button> </div> </div> </div>
                        
                        
                        ${locationFilterHtml} 
                        
                        
                        <button id="orders-export-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-green-600 hover:bg-green-100 text-sm transition-colors duration-150" title="Экспортировать отфильтрованные заказы в Excel">📥 Экспорт</button>
                    </div>
                    
                    <button id="refresh-orders-btn" title="Обновить список заказов" class="text-2xl text-gray-500 hover:text-indigo-600 transition-colors duration-150">&circlearrowright;</button>
                 </div>
                 
                 <div class="mb-4"> <input type="search" id="orders-search-input" placeholder="🔍 Поиск по клиенту, телефону, трек-коду, комментарию..." class="w-full p-2 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500"> </div>
                 
                 <div id="orders-bulk-action-bar" class="hidden p-3 bg-indigo-50 rounded-lg mb-4 border border-indigo-200 space-y-3">
                     <div class="flex items-center gap-4 flex-wrap"> <span id="orders-selected-count" class="font-bold text-indigo-700 text-sm">Выбрано: 0</span> <div class="flex items-center gap-2 border-l border-indigo-200 pl-3"> <label for="orders-bulk-status-select" class="text-xs font-medium text-gray-700">Статус:</label> <select id="orders-bulk-status-select" class="rounded-md border-gray-300 p-1.5 text-xs bg-white shadow-sm"></select> <button id="orders-bulk-update-status-btn" class="bg-indigo-600 text-white font-bold py-1.5 px-3 rounded-lg text-xs hover:bg-indigo-700">Применить</button> </div> <div class="flex items-center gap-2 border-l border-indigo-200 pl-3"> <label for="orders-bulk-party-date-input" class="text-xs font-medium text-gray-700">Дата:</label> <input type="date" id="orders-bulk-party-date-input" class="p-1.5 border rounded text-xs bg-white shadow-sm"> <button id="orders-bulk-update-date-btn" class="bg-orange-500 text-white font-bold py-1.5 px-3 rounded-lg text-xs hover:bg-orange-600">Применить</button> </div> <button id="orders-bulk-buyout-btn" class="hidden bg-purple-600 text-white font-bold py-1.5 px-3 rounded-lg text-xs hover:bg-purple-700">Выкупить отмеченное</button> </div>
                     <div class="border-t border-indigo-200 pt-2"> <button id="orders-bulk-delete-btn" class="bg-red-600 text-white font-bold py-1.5 px-3 rounded-lg text-xs hover:bg-red-700">Удалить выбранное</button> </div>
                 </div>
                 
                  <div id="orders-select-all-container" class="hidden flex items-center p-2 border-b"> <input type="checkbox" id="orders-select-all-checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"> <label for="orders-select-all-checkbox" class="ml-3 block text-sm font-bold text-gray-700">Выбрать все видимые заказы</label> </div>
                 
                 <div id="orders-list-container" class="space-y-4 mt-4"> <p class="text-gray-500 animate-pulse">Загрузка заказов...</p> </div>
            </div>
        </div>
    `;

    // --- Добавляем слушатели к элементам ---
    console.log("[Render] renderOrdersTab: Adding listeners...");
    // (Используем replaceAndListen для всех, чтобы избежать дублирования при перерисовке)
    const replaceAndListen = (id, event, handler) => {
        const element = document.getElementById(id);
        if (element) {
            const newElement = element.cloneNode(true);
            element.parentNode?.replaceChild(newElement, element);
            newElement.addEventListener(event, handler);
            console.log(`[Listener OK] Added ${event} to #${id}`);
        } else {
             console.warn(`!!! renderOrdersTab: Element #${id} NOT FOUND during listener attachment.`);
        }
    };

    // Форма добавления
    replaceAndListen('add-order-form', 'submit', handleAddOrderSubmit);
    replaceAndListen('order-client-search-input', 'input', handleOrderClientSearch);
    replaceAndListen('order-purchase-type', 'change', toggleOrderBuyoutFields);
    const today = new Date().toISOString().split('T')[0]; 
    const partyDateInputAdd = document.getElementById('order-party-date');
    if (partyDateInputAdd) partyDateInputAdd.value = today;

    // Форма импорта
    replaceAndListen('import-orders-btn', 'click', handleOrderExcelImport);

    // Панель действий и фильтров
    replaceAndListen('refresh-orders-btn', 'click', fetchAndRenderOrders);
    replaceAndListen('orders-toggle-select-mode-btn', 'click', toggleOrdersSelectMode);
    replaceAndListen('orders-toggle-party-filter-btn', 'click', toggleOrdersPartyFilter);
    replaceAndListen('orders-toggle-status-filter-btn', 'click', toggleOrdersStatusFilter);
    replaceAndListen('orders-apply-party-filter', 'click', applyOrdersFiltersAndFetch);
    replaceAndListen('orders-reset-party-filter', 'click', resetOrdersPartyFilter);
    replaceAndListen('orders-apply-status-filter', 'click', applyOrdersFiltersAndFetch);
    replaceAndListen('orders-reset-status-filter', 'click', resetOrdersStatusFilter);
    replaceAndListen('orders-export-btn', 'click', handleExportOrders);
    // НОВЫЙ СЛУШАТЕЛЬ ДЛЯ ФИЛЬТРА ФИЛИАЛОВ
    replaceAndListen('orders-location-filter', 'change', fetchAndRenderOrders); 

    // Поиск
    replaceAndListen('orders-search-input', 'input', handleOrdersSearch);

    // Массовые действия
    replaceAndListen('orders-select-all-checkbox', 'change', handleOrdersSelectAll);
    replaceAndListen('orders-bulk-update-status-btn', 'click', handleBulkUpdateStatus);
    replaceAndListen('orders-bulk-update-date-btn', 'click', handleBulkUpdatePartyDate);
    replaceAndListen('orders-bulk-delete-btn', 'click', handleBulkDeleteOrders);
    replaceAndListen('orders-bulk-buyout-btn', 'click', openBuyoutModal); 

    // Список заказов (делегирование)
    const listContainer = document.getElementById('orders-list-container');
    if (listContainer) {
         const newListContainer = listContainer.cloneNode(false);
         listContainer.parentNode?.replaceChild(newListContainer, listContainer);
         newListContainer.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка заказов...</p>';
         newListContainer.addEventListener('change', handleOrderCheckboxChange); // Чекбоксы
         newListContainer.addEventListener('click', handleOrderListClick);      // Кнопки Редакт.
         console.log("[Listener OK] Added change & click delegate listeners to #orders-list-container");
    } else {
         console.error("!!! renderOrdersTab: Element #orders-list-container NOT FOUND.");
    }

    // --- Инициализация фильтров и загрузка данных ---
    populateStatusFilter(); 
    populatePartyFilter(); 
    await fetchAndRenderOrders(); // Загружаем заказы с учетом нового фильтра
    console.log("[Render] renderOrdersTab: End");
}


// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ fetchAndRenderOrders)

async function fetchAndRenderOrders(filters = {}) {
    console.log("[Fetch] fetchAndRenderOrders: Start");
    const listContainer = document.getElementById('orders-list-container');
    if (!listContainer) return console.error("!!! fetchAndRenderOrders: listContainer #orders-list-container not found!");
    listContainer.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка заказов...</p>';
    showLoader(); 

    // Собираем параметры для запроса из фильтров
    const params = new URLSearchParams();
    const selectedParties = Array.from(document.querySelectorAll('#orders-party-list input:checked')).map(cb => cb.value);
    selectedParties.forEach(date => params.append('party_dates', date));
    const selectedStatuses = Array.from(document.querySelectorAll('#orders-status-list input:checked')).map(cb => cb.value);
    selectedStatuses.forEach(status => params.append('statuses', status));

    // Если фильтр по статусам пуст, по умолчанию НЕ показываем "Выдан"
    if (selectedStatuses.length === 0 && orderStatuses.length > 0) {
        orderStatuses.filter(s => s !== 'Выдан').forEach(status => params.append('statuses', status));
    }
    
    // --- ИСПРАВЛЕНИЕ: Передача выбранного location_id для Владельца ---
    if (currentUser.role === 'Владелец') {
        const locationFilterSelect = document.getElementById('orders-location-filter');
        if (locationFilterSelect && locationFilterSelect.value) { // Если select существует и выбрано значение
            params.append('location_id', locationFilterSelect.value);
            console.log("[Fetch Orders] Filtering by location_id:", locationFilterSelect.value);
        } else {
             console.log("[Fetch Orders] Owner viewing all locations.");
        }
    }
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    // Формируем URL с параметрами (префикс /api уже должен быть)
    const url = `/api/orders?${params.toString()}`;
    console.log("[Fetch] fetchAndRenderOrders: Requesting with params:", params.toString());

    try {
        // Запрашиваем заказы
        const orders = await apiFetch(url); 
        companyOrders = orders; // Обновляем кэш
        console.log("[Fetch] fetchAndRenderOrders: Received orders:", orders);

        if (!orders || orders.length === 0) {
            listContainer.innerHTML = '<p class="text-gray-500">Заказы по заданным фильтрам не найдены.</p>';
        } else {
            // --- Группировка заказов по клиенту ---
            const groupedOrders = orders.reduce((acc, order) => {
                const clientId = order.client?.id || 'unknown'; 
                if (!acc[clientId]) {
                    acc[clientId] = { client: order.client, orders: [] };
                }
                acc[clientId].orders.push(order);
                return acc;
            }, {});
            console.log("[Fetch] fetchAndRenderOrders: Orders grouped by client:", groupedOrders);

            // --- Рендеринг сгруппированных заказов ---
            listContainer.innerHTML = Object.values(groupedOrders).map(group => {
                group.orders.sort((a, b) => b.id - a.id); // Новые вверху
                const client = group.client || { full_name: 'Неизвестный клиент', phone: '', client_code_prefix: '', client_code_num: '' }; 
                const clientCode = `${client.client_code_prefix || ''}${client.client_code_num || 'Нет кода'}`;
                const ordersHtml = group.orders.map(o => renderOrderListItem(o)).join(''); 
                const groupSearchData = `
                    data-client-name="${client.full_name?.toLowerCase() || ''}"
                    data-client-phone="${client.phone || ''}"
                    data-client-code="${clientCode.toLowerCase()}"
                    data-tracks="${group.orders.map(o => o.track_code?.toLowerCase() || '').join(' ')}"
                `;
                return `
                    <div class="client-order-group border rounded-lg overflow-hidden mb-4 shadow-sm bg-white" ${groupSearchData}>
                        <div class="bg-gray-100 p-3 flex flex-wrap justify-between items-center border-b gap-2">
                             <div>
                                <p class="font-bold text-lg text-gray-800">${client.full_name} (${clientCode})</p>
                                <p class="text-sm text-gray-600">${client.phone}</p>
                             </div>
                             <span class="text-sm font-medium text-gray-500">${group.orders.length} зак.</span>
                        </div>
                        <div class="p-4 space-y-3">
                             ${ordersHtml}
                        </div>
                    </div>
                `;
            }).join('');
            console.log("[Fetch] fetchAndRenderOrders: Grouped HTML rendered.");
        }
        hideBulkActionBar(); // Сбрасываем панель массовых действий

    } catch (e) {
        console.error("!!! [Fetch] fetchAndRenderOrders: Error", e);
        listContainer.innerHTML = `<p class="text-red-500">Ошибка загрузки списка заказов: ${e.message}</p>`;
    } finally {
        hideLoader(); 
        console.log("[Fetch] fetchAndRenderOrders: End");
    }
}


// Рендерит HTML для ОДНОГО заказа в списке (без обертки клиента)
function renderOrderListItem(order) {
    // Проверка на случай отсутствия данных клиента (маловероятно после группировки)
    const client = order.client || { full_name: '?', phone: '?', client_code_prefix: '', client_code_num: '?' };
    const clientCode = `${client.client_code_prefix || ''}${client.client_code_num || '?'}`;
    const statusColor = getStatusColor(order.status); // Получаем цвет для статуса

    // Data-атрибуты для поиска по этому конкретному заказу
    const itemSearchData = `
         data-track="${order.track_code?.toLowerCase() || ''}"
         data-client-name="${client.full_name?.toLowerCase() || ''}"
         data-client-phone="${client.phone || ''}"
         data-client-code="${clientCode.toLowerCase()}"
         data-comment="${(order.comment || '').toLowerCase()}"
     `;

    // Генерируем HTML самого заказа
    return `
        <div class="order-list-item border rounded-lg p-3 hover:bg-gray-50 transition-colors duration-100 shadow-sm" ${itemSearchData}>
            <div class="flex flex-wrap justify-between items-start gap-2 mb-2">
                 <div class="flex items-center gap-3">
                      <input type="checkbox" data-order-id="${order.id}" class="order-checkbox hidden h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                      <div>
                           <span class="font-bold text-md text-gray-800 break-all">${order.track_code || 'N/A'}</span>
                           <span class="ml-2 px-2 py-0.5 rounded-full text-xs font-semibold ${statusColor}">${order.status || '?'}</span>
                      </div>
                 </div>
                 ${order.party_date ? `<span class="text-xs text-gray-500 font-medium">${order.party_date}</span>` : ''}
            </div>

            <div class="text-xs text-gray-700 space-y-1 pl-8">
                ${order.comment ? `<p><strong class="font-medium">Коммент:</strong> ${order.comment}</p>` : ''}
                ${order.purchase_type === 'Выкуп' ? `
                    <p class="text-purple-700"><strong class="font-medium">Выкуп:</strong> ${order.buyout_item_cost_cny || '?'} CNY | Курс(К): ${order.buyout_rate_for_client || '?'} | Ком: ${order.buyout_commission_percent}% ${order.buyout_actual_rate ? `| Курс(Р): ${order.buyout_actual_rate}` : ''}</p>
                ` : ''}
                ${order.calculated_final_cost_som ? `<p class="text-blue-700 font-semibold"><strong class="font-medium">Расчет:</strong> ${order.calculated_final_cost_som.toFixed(0)} сом (${order.calculated_weight_kg || '?'} кг @ ${order.calculated_price_per_kg_usd || '?'} USD, ${order.calculated_exchange_rate_usd || '?'} сом/USD)</p>` : ''}
                 ${order.status === 'Выдан' && order.issued_at ? `<p class="text-green-700 font-bold"><strong class="font-medium">Выдан (${new Date(order.issued_at).toLocaleDateString()}):</strong> ${order.final_cost_som?.toFixed(0) || '?'} сом (${order.weight_kg || '?'} кг)</p>` : ''}
            </div>

             <div class="mt-2 flex justify-end">
                <button data-order-id="${order.id}" class="edit-order-btn text-xs bg-gray-200 hover:bg-gray-300 text-gray-800 px-2 py-1 rounded transition-colors duration-150">Редактировать</button>
             </div>
        </div>
    `;
}

// --- Вспомогательная функция для получения CSS классов цвета статуса ---
// Возвращает строку с Tailwind CSS классами для фона и текста
function getStatusColor(status) {
    switch (status) {
        case 'В обработке':
            return 'bg-gray-100 text-gray-800'; // Серый
        case 'Ожидает выкупа':
            return 'bg-yellow-100 text-yellow-800'; // Желтый
        case 'Выкуплен':
            return 'bg-purple-100 text-purple-800'; // Фиолетовый
        case 'На складе в Китае':
            return 'bg-orange-100 text-orange-800'; // Оранжевый
        case 'В пути':
            return 'bg-blue-100 text-blue-800'; // Синий
        case 'На складе в КР':
            return 'bg-teal-100 text-teal-800'; // Бирюзовый
        case 'Готов к выдаче':
            return 'bg-lime-100 text-lime-800'; // Лаймовый
        case 'Выдан':
            return 'bg-green-100 text-green-800'; // Зеленый
        default: // Для неизвестных статусов
            return 'bg-gray-100 text-gray-800';
    }
}


// --- Функции для формы Добавления Заказа ---

// Поиск клиента при добавлении заказа (с debounce)
function handleOrderClientSearch(e) {
    const input = e.target; // Поле ввода, куда печатает пользователь
    const resultsDiv = document.getElementById('order-client-search-results'); // Div для показа результатов
    const selectedClientIdInput = document.getElementById('order-selected-client-id'); // Скрытое поле для ID
    const searchTerm = input.value; // Текст, введенный пользователем

    // Если поле поиска пустое или слишком короткое, скрываем результаты и сбрасываем ID
    if (!searchTerm || searchTerm.length < 1) { // Ищем хотя бы от 1 символа
        if(resultsDiv) resultsDiv.innerHTML = '';
        if(resultsDiv) resultsDiv.classList.add('hidden');
        if(selectedClientIdInput) selectedClientIdInput.value = ''; // Сбрасываем ID выбранного клиента
        return; // Выходим из функции
    }

    // --- Механизм "Debounce" ---
    // Очищаем предыдущий таймер, если пользователь продолжает печатать
    clearTimeout(input.debounceTimer);
    // Устанавливаем новый таймер: выполнить поиск через 300 мс после последней нажатой клавиши
    input.debounceTimer = setTimeout(async () => {
        console.log(`[Client Search] Searching for: "${searchTerm}"`);
        if(!resultsDiv || !selectedClientIdInput) return; // Доп. проверка

        resultsDiv.innerHTML = '<div class="p-2 text-sm text-gray-500 animate-pulse">Поиск...</div>'; // Показываем индикатор поиска
        resultsDiv.classList.remove('hidden'); // Показываем контейнер результатов

        try {
            // Выполняем запрос к API для поиска клиентов
            const clients = await apiFetch(`/api/clients/search?q=${encodeURIComponent(searchTerm)}`);
            console.log(`[Client Search] Found ${clients.length} clients.`);

            if (clients.length > 0) {
                // Если клиенты найдены, генерируем HTML для списка результатов
                 resultsDiv.innerHTML = clients.map(c => `
                    <div class="p-2 hover:bg-gray-100 cursor-pointer text-sm search-result-item"
                         data-client-id="${c.id}"
                         data-client-name="${c.full_name} (${c.client_code_prefix || ''}${c.client_code_num || 'Нет кода'})">
                        ${c.full_name} (${c.client_code_prefix || ''}${c.client_code_num || 'Нет кода'}) - ${c.phone}
                    </div>
                 `).join('');

                 // Добавляем обработчики клика на каждый элемент результата
                 resultsDiv.querySelectorAll('.search-result-item').forEach(item => {
                     item.addEventListener('click', () => {
                         const clientId = item.dataset.clientId;
                         const clientName = item.dataset.clientName;
                         console.log(`[Client Search] Client selected: ID=${clientId}, Name=${clientName}`);
                         input.value = clientName; // Показываем выбранное имя в поле ввода
                         selectedClientIdInput.value = clientId; // Сохраняем ID клиента в скрытое поле
                         resultsDiv.innerHTML = ''; // Очищаем список результатов
                         resultsDiv.classList.add('hidden'); // Скрываем список результатов
                     });
                 });
            } else {
                 // Если клиенты не найдены
                 resultsDiv.innerHTML = '<div class="p-2 text-sm text-gray-500">Клиенты не найдены.</div>';
            }
        } catch (error) { // Обработка ошибок при поиске
             console.error("[Client Search] Error:", error);
             resultsDiv.innerHTML = `<div class="p-2 text-sm text-red-500">Ошибка поиска: ${error.message}</div>`;
        }
    }, 300); // Задержка debounce в 300 миллисекунд
}

// Показать/Скрыть поля Выкупа при смене типа заказа в форме добавления
function toggleOrderBuyoutFields(e) {
    const purchaseType = e.target.value; // Получаем выбранный тип ("Доставка" или "Выкуп")
    const buyoutFieldsDiv = document.getElementById('order-buyout-fields'); // Находим div с полями выкупа

    if (!buyoutFieldsDiv) return; // Выходим, если div не найден

    if (purchaseType === 'Выкуп') {
        console.log("[Add Order Form] Purchase type changed to 'Выкуп'. Showing buyout fields.");
        buyoutFieldsDiv.classList.remove('hidden'); // Показываем поля
    } else {
        console.log("[Add Order Form] Purchase type changed to 'Доставка'. Hiding buyout fields.");
        buyoutFieldsDiv.classList.add('hidden'); // Скрываем поля
    }
}

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ handleAddOrderSubmit)

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ handleAddOrderSubmit)

async function handleAddOrderSubmit(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку формы
    console.log("[Add Order] handleAddOrderSubmit: Start");
    showLoader(); // Показываем индикатор загрузки

    // Получаем ID выбранного клиента из скрытого поля
    const clientId = document.getElementById('order-selected-client-id')?.value;
    // Проверяем, выбран ли клиент
    if (!clientId) {
        hideLoader(); // Прячем лоадер перед alert
        alert('Ошибка: Клиент не выбран из поиска.');
        console.warn("[Add Order] Submit failed: Client not selected.");
        return; // Прерываем выполнение функции
    }

    // Считываем значения из полей формы
    let track_code = document.getElementById('order-track-code')?.value.trim(); // Считываем трек-код и убираем пробелы
    const purchase_type = document.getElementById('order-purchase-type')?.value; // Получаем тип заказа
    const party_date = document.getElementById('order-party-date')?.value || null; // Дата партии (или null, если не выбрана)
    const comment = document.getElementById('order-comment')?.value.trim() || null; // Комментарий (или null, если пустой)

    // Генерируем временный трек-код, если поле пустое И тип заказа "Выкуп"
    if (!track_code && purchase_type === 'Выкуп') {
        const timestamp = Date.now(); // Текущее время в миллисекундах
        track_code = `PENDING-${timestamp}`; // Генерируем код вида PENDING-1678886400000
        console.log("[Add Order] Сгенерирован временный трек-код для выкупа:", track_code);
    }

    // Проверяем, есть ли трек-код ПОСЛЕ возможной генерации
    if (!track_code) {
        hideLoader();
        alert("Трек-код обязателен для заполнения (для типа 'Доставка').");
        console.warn("[Add Order] Submit failed: Track code is missing for 'Доставка'.");
        return; // Прерываем
    }

    // Собираем основной payload
    const payload = {
        client_id: parseInt(clientId),
        track_code: track_code,
        party_date: party_date,
        purchase_type: purchase_type,
        comment: comment
        // location_id будет добавлен ниже
    };

    // Добавляем location_id для Владельца
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('order-location-select');
        if (locationSelect && locationSelect.value) {
            payload.location_id = parseInt(locationSelect.value);
        } else if (currentUser.location_id) {
             payload.location_id = currentUser.location_id;
        } else {
             console.warn("[Add Order] Owner location_id could not be determined.");
        }
    }

    // Добавляем поля выкупа, если нужно
    if (payload.purchase_type === 'Выкуп') {
        payload.buyout_item_cost_cny = parseFloat(document.getElementById('order-buyout-cost')?.value) || null;
        payload.buyout_rate_for_client = parseFloat(document.getElementById('order-buyout-rate')?.value) || null;
        payload.buyout_commission_percent = parseFloat(document.getElementById('order-buyout-commission')?.value) || 10.0;
    }

    // Отправка данных на сервер
    console.log("[Add Order] Sending payload to server:", payload);
    try {
        const newOrder = await apiFetch('/api/orders', {
            method: 'POST',
            body: JSON.stringify(payload)
        });
        console.log("[Add Order] Server response (new order):", newOrder);
        alert(`Заказ #${newOrder.id} (${newOrder.track_code}) успешно создан!`);
        
        const addOrderForm = document.getElementById('add-order-form');
        if(addOrderForm) addOrderForm.reset();  

        // --- ИСПРАВЛЕННЫЙ БЛОК СБРОСА ПОЛЕЙ ---
        // Дополнительно сбрасываем/очищаем поля, которые не сбрасываются методом reset()
        const clientSearchInput = document.getElementById('order-client-search-input');
        if (clientSearchInput) clientSearchInput.value = ''; // Используем if проверку

        const selectedClientIdInput = document.getElementById('order-selected-client-id');
        if (selectedClientIdInput) selectedClientIdInput.value = ''; // Используем if проверку

        const buyoutFieldsDiv = document.getElementById('order-buyout-fields');
        if (buyoutFieldsDiv) buyoutFieldsDiv.classList.add('hidden'); // Используем if проверку
        // --- КОНЕЦ ИСПРАВЛЕННОГО БЛОКА ---

        // Устанавливаем сегодняшнюю дату по умолчанию для партии после сброса
        const today = new Date().toISOString().split('T')[0];
        const partyDateInput = document.getElementById('order-party-date');
        if (partyDateInput) partyDateInput.value = today;
        // Сбрасываем выбор филиала на основной филиал Владельца (если он есть)
        const locationSelect = document.getElementById('order-location-select');
        if (locationSelect && currentUser.location_id) {
             locationSelect.value = currentUser.location_id;
        }
        console.log("[Add Order] Form reset complete.");

        // Обновляем список заказов на странице
        await fetchAndRenderOrders();

    } catch (err) { 
        console.error("!!! [Add Order] Ошибка при создании заказа:", err);
        alert(`Ошибка создания заказа: ${err.message}`); 
    } finally {
        hideLoader(); 
        console.log("[Add Order] handleAddOrderSubmit: End");
    }
}

// === КОНЕЦ ФУНКЦИЙ ДЛЯ ФОРМЫ ДОБАВЛЕНИЯ ЗАКАЗА ===

// --- Функции для Импорта Заказов ---
// index.html (Полностью заменяет handleOrderExcelImport)

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ handleOrderExcelImport)

async function handleOrderExcelImport() {
    console.log("[Import Orders] handleOrderExcelImport: Start");
    const fileInput = document.getElementById('order-excel-input');
    const resultsDiv = document.getElementById('order-import-results');
    const partyDateInput = document.getElementById('import-order-party-date');
    const partyDate = partyDateInput ? partyDateInput.value : null;

    // --- ДОБАВЛЕНИЕ: Считываем выбранный location_id из select'а импорта ---
    let importLocationId = null;
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('import-location-select');
        if (locationSelect && locationSelect.value) {
            importLocationId = parseInt(locationSelect.value); // Владелец выбрал
             console.log("[Import Orders] Owner selected location_id for import:", importLocationId);
        } else if (currentUser.location_id) {
             // Используем location_id Владельца по умолчанию, если select недоступен или не выбран
             importLocationId = currentUser.location_id; 
             console.log("[Import Orders] Owner using default location_id for import:", importLocationId);
        } else {
             // Если у Владельца нет location_id и нет select'а, бэкенд назначит первый
             console.warn("[Import Orders] Owner location_id for import could not be determined. Backend will assign default.");
        }
    }
    // Для обычного сотрудника location_id будет определен на бэкенде
    // --- КОНЕЦ ДОБАВЛЕНИЯ ---

    if (!resultsDiv) return console.error("!!! Import Orders Error: resultsDiv #order-import-results not found!");
    resultsDiv.innerHTML = '<p class="text-blue-600 animate-pulse">Обработка файла...</p>';

    if (!fileInput || fileInput.files.length === 0) {
        resultsDiv.innerHTML = '<p class="text-red-500">Ошибка: Выберите Excel-файл для импорта.</p>';
        return;
    }
    const file = fileInput.files[0];
    console.log(`[Import Orders] Selected file: ${file.name}, size: ${file.size} bytes`);
    showLoader(); // Показываем глобальный лоадер

    try {
        // --- Шаг 1: Чтение Excel ---
        console.log("[Import Orders] Reading Excel file...");
        const jsonData = await readExcelFile(file); 
        console.log(`[Import Orders] Excel read successfully. Found ${jsonData.length} rows.`);

        if (!jsonData || jsonData.length === 0) {
            resultsDiv.innerHTML = '<p class="text-yellow-600">Файл пуст.</p>';
            hideLoader(); return; 
        }

        // --- Шаг 2: Проверка колонок ---
        const firstRow = jsonData[0];
        if (!firstRow || !firstRow.hasOwnProperty('track_code') || (!firstRow.hasOwnProperty('client_code') && !firstRow.hasOwnProperty('phone'))) {
            resultsDiv.innerHTML = '<p class="text-red-500">Ошибка: Файл должен содержать <strong>track_code</strong> и (<strong>client_code</strong> или <strong>phone</strong>).</p>';
            hideLoader(); return;
        }
        console.log("[Import Orders] Required columns found.");

        // --- Шаг 3: Подготовка данных ---
        resultsDiv.innerHTML = `<p class="text-blue-600">Подготовка ${jsonData.length} записей...</p>`;
        const dataToSend = jsonData.map(row => ({
            track_code: String(row.track_code || '').trim() || null,
            client_code: row.client_code ? String(row.client_code).trim() : null,
            phone: row.phone ? String(row.phone).trim() : null,
            comment: row.comment ? String(row.comment).trim() : null,
            purchase_type: String(row.purchase_type || 'Доставка').trim(),
            buyout_item_cost_cny: parseFloat(row.buyout_item_cost_cny) || null,
            buyout_rate_for_client: parseFloat(row.buyout_rate_for_client) || null,
            buyout_commission_percent: parseFloat(row.buyout_commission_percent) || 10.0
        })).filter(item => item.track_code); // Отфильтровываем строки без трек-кода

        if (dataToSend.length === 0) {
            resultsDiv.innerHTML = '<p class="text-yellow-600">Нет строк с трек-кодом для импорта.</p>';
            hideLoader(); return;
        }
        console.log(`[Import Orders] Prepared ${dataToSend.length} valid records for sending.`);

        // --- Шаг 4: Отправка данных на БЭКЕНД ---
        // Формируем payload с датой партии, списком заказов И location_id
        const payload = {
            party_date: partyDate, 
            orders_data: dataToSend, 
            location_id: importLocationId // <-- ПЕРЕДАЕМ location_id
        };
        resultsDiv.innerHTML = `<p class="text-blue-600 animate-pulse">Отправка ${dataToSend.length} заказов на сервер...</p>`;
        console.log("[Import Orders] Sending payload to /api/orders/bulk_import:", payload);

        const response = await apiFetch('/api/orders/bulk_import', {
            method: 'POST',
            body: JSON.stringify(payload) 
        });
        console.log("[Import Orders] Server response:", response);

        // --- Шаг 5: Отображение результата ---
        let resultHtml = `<p class="text-green-600 font-semibold"><strong>Импорт завершен! Успешно создано: ${response.created_clients || 0}</strong></p>`; // Используем поле created_clients
        if (response.warnings && response.warnings.length > 0) {
            resultHtml += `<p class="text-yellow-600 mt-2 font-semibold"><strong>Предупреждения (${response.warnings.length}):</strong></p><ul class="list-disc list-inside text-xs">${response.warnings.map(w => `<li>${w}</li>`).join('')}</ul>`;
        }
        if (response.errors && response.errors.length > 0) {
            resultHtml += `<p class="text-red-600 mt-2 font-semibold"><strong>Ошибки (${response.errors.length}):</strong></p><ul class="list-disc list-inside text-xs">${response.errors.map(er => `<li>${er}</li>`).join('')}</ul>`;
        }
        resultsDiv.innerHTML = resultHtml; // Показываем результат

        // --- Шаг 6: Обновление списка заказов и дат партий ---
        if (response.created_clients > 0 || partyDate || importLocationId) { 
            console.log("[Import Orders] Refreshing orders list and party dates...");
            await fetchAndRenderOrders(); 
            availablePartyDates = await apiFetch('/api/orders/parties');
            populatePartyFilter(); 
        }

    } catch (error) { // Обработка ошибок чтения файла или API
        console.error("!!! [Import Orders] CRITICAL ERROR", error);
        resultsDiv.innerHTML = `<p class="text-red-500"><b>Критическая ошибка импорта заказов:</b> ${error.message}</p>`;
    } finally {
        hideLoader(); // Прячем лоадер
        if (fileInput) fileInput.value = ''; // Сбрасываем выбор файла
        console.log("[Import Orders] handleOrderExcelImport: End");
    }
}


// --- Функции для Фильтров ---

// Заполняет HTML списка статусов в выпадающем фильтре
function populateStatusFilter() {
    console.log("[Filters] populateStatusFilter: Start");
    const listDiv = document.getElementById('orders-status-list');
    if (!listDiv) return console.warn("[Filters] populateStatusFilter: Element #orders-status-list not found.");

    // Проверяем, есть ли статусы в глоб. переменной
    if (!orderStatuses || orderStatuses.length === 0) {
        listDiv.innerHTML = '<p class="text-xs text-red-500">Ошибка: Список статусов не загружен.</p>';
        console.error("!!! [Filters] populateStatusFilter: orderStatuses array is empty!");
        return;
    }

    // Генерируем HTML для чекбоксов статусов
    // Отмечаем все, кроме "Выдан", по умолчанию
    listDiv.innerHTML = orderStatuses.map(s => `
        <div class="flex items-center">
            <input type="checkbox" id="status-filter-${s.replace(/\s+/g, '-')}" value="${s}"
                   class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 status-filter-checkbox"
                   ${s !== 'Выдан' ? 'checked' : ''}>
            <label for="status-filter-${s.replace(/\s+/g, '-')}" class="ml-2 text-sm text-gray-700">${s}</label>
        </div>
    `).join('');
    console.log("[Filters] populateStatusFilter: Status filter populated.");
}

// Заполняет HTML списка дат партий в выпадающем фильтре
function populatePartyFilter() {
     console.log("[Filters] populatePartyFilter: Start");
     const listDiv = document.getElementById('orders-party-list');
     if (!listDiv) return console.warn("[Filters] populatePartyFilter: Element #orders-party-list not found.");

     // Проверяем наличие дат в кэше
     if (!availablePartyDates || availablePartyDates.length === 0) {
          listDiv.innerHTML = '<p class="text-sm text-gray-500">Дат партий не найдено.</p>';
          console.log("[Filters] populatePartyFilter: No party dates available.");
          return;
     }

     // Генерируем HTML для чекбоксов дат партий
     // Отмечаем все по умолчанию
     listDiv.innerHTML = availablePartyDates.map(p => `
         <div class="flex items-center">
             <input type="checkbox" id="party-filter-${p}" value="${p}"
                    class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 party-filter-checkbox" checked>
             <label for="party-filter-${p}" class="ml-2 text-sm text-gray-700">${p}</label>
         </div>
     `).join('');
     console.log("[Filters] populatePartyFilter: Party date filter populated.");
 }


// Показать/Скрыть выпадающее окно фильтра статусов
function toggleOrdersStatusFilter() {
    console.log("[Filters] toggleOrdersStatusFilter called.");
    const statusContainer = document.getElementById('orders-status-filter-container');
    const partyContainer = document.getElementById('orders-party-filter-container');
    if (!statusContainer) return;

    // Перезаполняем список статусов перед показом (на случай изменений)
    if (statusContainer.classList.contains('hidden')) {
        populateStatusFilter();
    }
    statusContainer.classList.toggle('hidden'); // Показываем/скрываем
    // Скрываем другой фильтр, если он был открыт
    if(partyContainer) partyContainer.classList.add('hidden');
}

// Показать/Скрыть выпадающее окно фильтра партий (с обновлением дат)
async function toggleOrdersPartyFilter() {
     console.log("[Filters] toggleOrdersPartyFilter called.");
     const partyContainer = document.getElementById('orders-party-filter-container');
     const statusContainer = document.getElementById('orders-status-filter-container');
     if (!partyContainer) return;

     const listDiv = document.getElementById('orders-party-list');
     if (!listDiv) return;

     // Если контейнер скрыт, значит мы его открываем
     if (partyContainer.classList.contains('hidden')) {
          console.log("[Filters] Opening party filter. Refreshing dates...");
          listDiv.innerHTML = '<p class="text-sm text-gray-500 animate-pulse">Обновление дат...</p>';
          showLoader(); // Показываем глобальный лоадер на время запроса
          try {
                // Запрашиваем АКТУАЛЬНЫЕ даты партий с сервера
                const freshPartyDates = await apiFetch('/api/orders/parties');
                availablePartyDates = freshPartyDates; // Обновляем кэш
                console.log("[Filters] Fresh party dates received:", availablePartyDates);
                populatePartyFilter(); // Заполняем список свежими датами
                partyContainer.classList.remove('hidden'); // Показываем контейнер
          } catch(e) { // Обработка ошибки загрузки дат
                console.error("!!! [Filters] Error refreshing party dates:", e);
                listDiv.innerHTML = `<p class="text-sm text-red-500">Ошибка: ${e.message}</p>`;
                // Оставляем контейнер видимым, чтобы показать ошибку
                partyContainer.classList.remove('hidden');
          } finally {
               hideLoader(); // Скрываем лоадер
          }
     } else {
          // Если контейнер уже был открыт, просто скрываем его
          console.log("[Filters] Closing party filter.");
          partyContainer.classList.add('hidden');
     }
     // Скрываем другой фильтр (статусов), если он был открыт
     if(statusContainer) statusContainer.classList.add('hidden');
}

// Применить выбранные фильтры (закрывает окна и перезагружает список заказов)
function applyOrdersFiltersAndFetch() {
    console.log("[Filters] applyOrdersFiltersAndFetch called.");
    // Скрываем оба окна фильтров
    document.getElementById('orders-status-filter-container')?.classList.add('hidden');
    document.getElementById('orders-party-filter-container')?.classList.add('hidden');
    // Вызываем функцию перезагрузки списка заказов (она сама считает выбранные фильтры)
    fetchAndRenderOrders();
}

// Сбросить фильтр статусов (выбирает все, кроме "Выдан") и применить
function resetOrdersStatusFilter() {
     console.log("[Filters] resetOrdersStatusFilter called.");
     // Находим все чекбоксы статусов
     document.querySelectorAll('.status-filter-checkbox').forEach(cb => {
         // Отмечаем, если статус НЕ "Выдан"
         cb.checked = (cb.value !== 'Выдан');
     });
     applyOrdersFiltersAndFetch(); // Применяем сброшенные фильтры
}

// Сбросить фильтр партий (выбирает все доступные даты) и применить
function resetOrdersPartyFilter() {
     console.log("[Filters] resetOrdersPartyFilter called.");
     // Находим все чекбоксы дат
     document.querySelectorAll('.party-filter-checkbox').forEach(cb => {
         cb.checked = true; // Отмечаем все
     });
     applyOrdersFiltersAndFetch(); // Применяем сброшенные фильтры
}

// --- Функция Поиска по заказам (фильтрует отображение списка) ---
// Вызывается при вводе текста в поле #orders-search-input
function handleOrdersSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim(); // Получаем поисковый запрос (без пробелов по краям)
    console.log(`[Order Search] Term = "${searchTerm}"`);
    // Находим все ГРУППЫ клиентов в списке заказов
    const groupItems = document.querySelectorAll('#orders-list-container .client-order-group');

    groupItems.forEach(group => {
        // Извлекаем данные для поиска по всей группе из data-атрибутов
        const clientName = group.dataset.clientName || '';
        const clientPhone = group.dataset.clientPhone || '';
        const clientCode = group.dataset.clientCode || '';
        const groupTracks = group.dataset.tracks || ''; // Строка со всеми треками группы

        // Проверяем, совпадает ли поисковый запрос с данными КЛИЕНТА группы
        const clientMatch = clientName.includes(searchTerm) ||
                            clientPhone.includes(searchTerm) ||
                            clientCode.includes(searchTerm);

        let hasVisibleOrderInGroup = false; // Флаг, есть ли видимые заказы ВНУТРИ группы

        // Проходим по КАЖДОМУ заказу ВНУТРИ этой группы
        const orderItems = group.querySelectorAll('.order-list-item');
        orderItems.forEach(item => {
             // Извлекаем данные для поиска по конкретному заказу
             const itemTrack = item.dataset.track || '';
             const itemComment = item.dataset.comment || '';
             // Проверяем, совпадает ли запрос с треком или комментарием ЗАКАЗА
             const itemMatch = itemTrack.includes(searchTerm) || itemComment.includes(searchTerm);

             // Показываем заказ, если:
             // 1) Запрос совпал с данными клиента всей группы (clientMatch)
             // ИЛИ
             // 2) Запрос совпал с треком/комментарием этого конкретного заказа (itemMatch)
             if (clientMatch || itemMatch) {
                 item.style.display = 'block'; // Показываем элемент заказа
                 hasVisibleOrderInGroup = true; // Отмечаем, что в группе есть видимый заказ
             } else {
                 item.style.display = 'none'; // Скрываем элемент заказа
             }
        });

        // Показываем или скрываем ВСЮ ГРУППУ
        // Группа видна, если поисковый запрос пуст ИЛИ если внутри нее есть хотя бы один видимый заказ
        if (searchTerm === '' || hasVisibleOrderInGroup) {
            group.style.display = 'block'; // Показываем группу
        } else {
            group.style.display = 'none'; // Скрываем группу
        }
    });
    console.log(`[Order Search] Filtering complete.`);
    // После фильтрации нужно обновить состояние чекбокса "Выбрать все"
    updateSelectAllCheckboxState();
}


// --- Функции для Массовых Действий ---

// Переключает режим выбора заказов (показывает/скрывает чекбоксы и панель "Выбрать все")
function toggleOrdersSelectMode() {
    console.log("[Bulk Actions] Toggling select mode...");
    // Находим все чекбоксы заказов
    const checkboxes = document.querySelectorAll('.order-checkbox');
    // Находим контейнер "Выбрать все"
    const selectAllContainer = document.getElementById('orders-select-all-container');
    // Определяем, был ли режим выбора УЖЕ включен (по видимости первого чекбокса)
    const wasSelecting = checkboxes.length > 0 && !checkboxes[0].classList.contains('hidden');

    // Переключаем видимость для КАЖДОГО чекбокса заказа
    checkboxes.forEach(cb => cb.classList.toggle('hidden'));
    // Переключаем видимость контейнера "Выбрать все"
    if (selectAllContainer) selectAllContainer.classList.toggle('hidden');

    if (wasSelecting) {
        // Если режим выбора ВЫКЛЮЧАЕТСЯ, скрываем панель массовых действий
        console.log("[Bulk Actions] Select mode OFF. Hiding bulk action bar.");
        hideBulkActionBar();
    } else {
         // Если режим выбора ВКЛЮЧАЕТСЯ, просто показываем чекбоксы
         console.log("[Bulk Actions] Select mode ON.");
         // Заполняем select статусов для массовой смены (если еще не заполнен)
         const bulkStatusSelect = document.getElementById('orders-bulk-status-select');
         if (bulkStatusSelect && bulkStatusSelect.options.length <= 1) { // Проверяем, что опций мало
             bulkStatusSelect.innerHTML = '<option value="">-- Выберите статус --</option>' + // Добавляем пустую опцию
                                          orderStatuses.map(s => `<option value="${s}">${s}</option>`).join('');
             console.log("[Bulk Actions] Bulk status select populated.");
         }
         updateBulkActionBar(); // Обновляем панель (она может остаться скрытой, если ничего не выбрано)
         updateSelectAllCheckboxState(); // Обновляем состояние чекбокса "Выбрать все"
    }
}

// Скрывает панель массовых действий и сбрасывает все чекбоксы
function hideBulkActionBar() {
    console.log("[Bulk Actions] Hiding bulk action bar and resetting selection.");
    const actionBar = document.getElementById('orders-bulk-action-bar');
    const selectAllCheckbox = document.getElementById('orders-select-all-checkbox');

    if (actionBar) actionBar.classList.add('hidden'); // Скрываем панель
    if (selectAllCheckbox) selectAllCheckbox.checked = false; // Снимаем галочку "Выбрать все"
    // Снимаем галочки со всех чекбоксов заказов
    document.querySelectorAll('.order-checkbox').forEach(cb => cb.checked = false);
}

// Обработчик изменения чекбокса "Выбрать все видимые"
function handleOrdersSelectAll(e) {
    const isChecked = e.target.checked; // Получаем состояние главного чекбокса
    console.log(`[Bulk Actions] Select all checkbox changed to: ${isChecked}`);
    // Находим все чекбоксы заказов, которые ВИДИМЫ в данный момент
    document.querySelectorAll('#orders-list-container .order-list-item:not([style*="display: none"]) .order-checkbox').forEach(cb => {
        cb.checked = isChecked; // Устанавливаем им то же состояние
    });
    updateBulkActionBar(); // Обновляем счетчик и видимость панели массовых действий
}

// index.html (Внутри МОДУЛЬ: ЗАКАЗЫ)

function handleOrderCheckboxChange(e) {
    if (e.target.classList.contains('order-checkbox')) {
        const bar = document.getElementById('orders-bulk-action-bar');
        const selected = document.querySelectorAll('.order-checkbox:checked');
        const bulkStatusBlock = document.getElementById('orders-bulk-status-select').closest('div.flex');
        const bulkDateBlock = document.getElementById('orders-bulk-party-date-input').closest('div.flex');
        const buyoutBtn = document.getElementById('orders-bulk-buyout-btn'); // Кнопка выкупа

        if (selected.length > 0) {
            bar.classList.remove('hidden');
            document.getElementById('orders-selected-count').textContent = `Выбрано: ${selected.length}`;
            
            // --- КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ ЛОГИКИ ВЫКУПА ---
            const selectedOrders = Array.from(selected).map(cb => companyOrders.find(o => o.id == cb.dataset.orderId));
            // Проверяем, что ВСЕ выбранные заказы имеют статус "Ожидает выкупа"
            const allAwaitingBuyout = selectedOrders.every(o => o.status === 'Ожидает выкупа');

            if (allAwaitingBuyout) {
                // Если все готовы к выкупу, показываем ТОЛЬКО кнопку выкупа
                buyoutBtn.classList.remove('hidden'); 
                if (bulkStatusBlock) bulkStatusBlock.classList.add('hidden'); // Скрываем статус
                if (bulkDateBlock) bulkDateBlock.classList.add('hidden'); // Скрываем дату
            } else {
                // Иначе показываем стандартные массовые действия
                buyoutBtn.classList.add('hidden'); 
                if (bulkStatusBlock) bulkStatusBlock.classList.remove('hidden'); 
                if (bulkDateBlock) bulkDateBlock.classList.remove('hidden'); 
            }
            // --- КОНЕЦ КРИТИЧЕСКОГО ИСПРАВЛЕНИЯ ---
            
        } else {
            bar.classList.add('hidden');
        }
    }
    updateSelectAllCheckboxState();
}

// Обновляет состояние чекбокса "Выбрать все" (отмечен/не отмечен/промежуточный)
function updateSelectAllCheckboxState() {
     const selectAllCheckbox = document.getElementById('orders-select-all-checkbox');
     if (!selectAllCheckbox) return;

     // Находим все ВИДИМЫЕ чекбоксы заказов
     const allVisibleCheckboxes = Array.from(
          document.querySelectorAll('#orders-list-container .order-list-item:not([style*="display: none"]) .order-checkbox')
     );

     if (allVisibleCheckboxes.length === 0) {
          // Если видимых чекбоксов нет, снимаем галочку и делаем неактивным? (пока просто снимаем)
          selectAllCheckbox.checked = false;
          selectAllCheckbox.indeterminate = false;
          return;
     }

     const checkedVisibleCount = allVisibleCheckboxes.filter(cb => cb.checked).length; // Считаем отмеченные среди видимых

     if (checkedVisibleCount === 0) {
          // Если ни один не отмечен
          selectAllCheckbox.checked = false;
          selectAllCheckbox.indeterminate = false; // Нет промежуточного состояния
     } else if (checkedVisibleCount === allVisibleCheckboxes.length) {
          // Если ВСЕ видимые отмечены
          selectAllCheckbox.checked = true;
          selectAllCheckbox.indeterminate = false; // Нет промежуточного состояния
     } else {
          // Если отмечена только ЧАСТЬ видимых
          selectAllCheckbox.checked = false; // Галочку снимаем
          selectAllCheckbox.indeterminate = true; // Устанавливаем промежуточное состояние (тире)
     }
     console.log(`[Bulk Actions] Select all state updated: checked=${selectAllCheckbox.checked}, indeterminate=${selectAllCheckbox.indeterminate}`);
}


// Обновляет счетчик выбранных и показывает/скрывает панель массовых действий
function updateBulkActionBar() {
    // Считаем ВСЕ отмеченные чекбоксы (даже если они скрыты поиском)
    const selectedCheckboxes = document.querySelectorAll('.order-checkbox:checked');
    const count = selectedCheckboxes.length;
    const actionBar = document.getElementById('orders-bulk-action-bar');
    const countSpan = document.getElementById('orders-selected-count');

    console.log(`[Bulk Actions] updateBulkActionBar: Selected count = ${count}`);

    if (count > 0 && actionBar) {
        // Если выбран хотя бы один заказ, показываем панель
        actionBar.classList.remove('hidden');
        if(countSpan) countSpan.textContent = `Выбрано: ${count}`; // Обновляем счетчик
    } else if (actionBar) {
        // Если ни один не выбран, скрываем панель
        actionBar.classList.add('hidden');
    }
}

// Выполнить массовое обновление статуса
async function handleBulkUpdateStatus() {
    // Получаем ID всех отмеченных заказов
    const selectedIds = Array.from(document.querySelectorAll('.order-checkbox:checked'))
                           .map(cb => parseInt(cb.dataset.orderId));
    // Получаем выбранный новый статус из select'а
    const bulkStatusSelect = document.getElementById('orders-bulk-status-select');
    const newStatus = bulkStatusSelect ? bulkStatusSelect.value : null;

    // Проверки
    if (selectedIds.length === 0) {
        alert("Не выбраны заказы для смены статуса.");
        return;
    }
    if (!newStatus) { // Проверяем, выбран ли статус (не пустая ли опция "-- Выберите статус --")
         alert("Пожалуйста, выберите новый статус из списка.");
         return;
    }

    console.log(`[Bulk Action] handleBulkUpdateStatus: Attempting to set status '${newStatus}' for ${selectedIds.length} orders:`, selectedIds);
    showLoader(); // Показываем лоадер

    try {
        // Отправляем запрос на бэкенд
        const response = await apiFetch('/api/orders/bulk_action', {
            method: 'POST',
            body: JSON.stringify({
                action: 'update_status', // Указываем действие
                order_ids: selectedIds,   // Передаем массив ID
                new_status: newStatus     // Передаем новый статус
            })
        });
        console.log("[Bulk Action] handleBulkUpdateStatus: Server response:", response);
        alert(response.message || `Статус успешно обновлен для ${selectedIds.length} заказов.`);
        // Перезагружаем список заказов, чтобы увидеть изменения
        // При перезагрузке выбор и панель автоматически сбросятся
        await fetchAndRenderOrders();

    } catch (err) { // Обработка ошибок от apiFetch
        console.error("!!! [Bulk Action] handleBulkUpdateStatus: Error", err);
        alert(`Ошибка массового обновления статуса: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Bulk Action] handleBulkUpdateStatus: End");
    }
}

// Выполнить массовое обновление даты партии
async function handleBulkUpdatePartyDate() {
    // Получаем ID всех отмеченных заказов
    const selectedIds = Array.from(document.querySelectorAll('.order-checkbox:checked'))
                           .map(cb => parseInt(cb.dataset.orderId));
    // Получаем выбранную дату из поля ввода
    const partyDateInput = document.getElementById('orders-bulk-party-date-input');
    const newDate = partyDateInput ? partyDateInput.value : null;

    // Проверки
    if (selectedIds.length === 0) {
        alert("Не выбраны заказы для смены даты партии."); return;
    }
    if (!newDate) {
        alert("Пожалуйста, выберите новую дату партии."); return;
    }

    // Запрашиваем пароль Владельца для подтверждения (т.к. это изменение данных)
    const ownerPassword = prompt(`Введите ваш пароль для подтверждения смены даты партии на ${newDate} для ${selectedIds.length} заказов:`);
    if (ownerPassword === null) { // Пользователь нажал Отмена
         console.log("[Bulk Action] Смена даты партии отменена пользователем.");
         return;
    }
    if (ownerPassword === "") { // Пароль не введен
         alert("Пароль не введен. Смена даты отменена.");
         return;
    }


    console.log(`[Bulk Action] handleBulkUpdatePartyDate: Attempting to set date '${newDate}' for ${selectedIds.length} orders.`);
    showLoader(); // Показываем лоадер

    try {
        // Отправляем запрос на бэкенд
        const response = await apiFetch('/api/orders/bulk_action', {
            method: 'POST',
            body: JSON.stringify({
                action: 'update_party_date', // Указываем действие
                order_ids: selectedIds,      // Передаем массив ID
                new_party_date: newDate,     // Передаем новую дату
                password: ownerPassword      // Передаем введенный пароль
            })
        });
        console.log("[Bulk Action] handleBulkUpdatePartyDate: Server response:", response);
        alert(response.message || `Дата партии успешно обновлена для ${selectedIds.length} заказов.`);

        // Обновляем список заказов
        await fetchAndRenderOrders();
        // Обновляем кэш и фильтр дат партий
        console.log("[Bulk Action] Refreshing party dates after update...");
        availablePartyDates = await apiFetch('/api/orders/parties');
        populatePartyFilter();

    } catch (err) { // Обработка ошибок (включая неверный пароль - 403)
        console.error("!!! [Bulk Action] handleBulkUpdatePartyDate: Error", err);
        alert(`Ошибка массовой смены даты партии: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Bulk Action] handleBulkUpdatePartyDate: End");
    }
}

// Выполнить массовое удаление заказов
async function handleBulkDeleteOrders() {
    // Получаем ID всех отмеченных заказов
    const selectedIds = Array.from(document.querySelectorAll('.order-checkbox:checked'))
                           .map(cb => parseInt(cb.dataset.orderId));

    // Проверка
    if (selectedIds.length === 0) {
        alert("Не выбраны заказы для удаления."); return;
    }

    // Запрашиваем пароль Владельца для подтверждения (опасная операция)
    const ownerPassword = prompt(`ВНИМАНИЕ! Вы собираетесь удалить ${selectedIds.length} заказ(ов). Это действие НЕОБРАТИМО.\n\nВведите ваш пароль для подтверждения:`);
    if (ownerPassword === null) {
         console.log("[Bulk Action] Массовое удаление отменено пользователем.");
         return;
    }
     if (ownerPassword === "") {
         alert("Пароль не введен. Удаление отменено.");
         return;
    }

    console.log(`[Bulk Action] handleBulkDeleteOrders: Attempting to delete ${selectedIds.length} orders.`);
    showLoader(); // Показываем лоадер

    try {
        // Отправляем запрос на бэкенд
        const response = await apiFetch('/api/orders/bulk_action', {
            method: 'POST',
            body: JSON.stringify({
                action: 'delete',        // Указываем действие
                order_ids: selectedIds,  // Передаем массив ID
                password: ownerPassword  // Передаем введенный пароль
            })
        });
        console.log("[Bulk Action] handleBulkDeleteOrders: Server response:", response);
        alert(response.message || `Успешно удалено ${selectedIds.length} заказов.`);

        // Обновляем список заказов
        await fetchAndRenderOrders();
        // Обновляем кэш и фильтр дат партий (могли удалиться все заказы с какой-то датой)
        console.log("[Bulk Action] Refreshing party dates after delete...");
        availablePartyDates = await apiFetch('/api/orders/parties');
        populatePartyFilter();

    } catch (err) { // Обработка ошибок (включая неверный пароль - 403)
        console.error("!!! [Bulk Action] handleBulkDeleteOrders: Error", err);
        alert(`Ошибка массового удаления заказов: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Bulk Action] handleBulkDeleteOrders: End");
    }
}

// --- ФУНКЦИЯ: Открывает модальное окно для ввода курса выкупа ---
function openBuyoutModal() {
    const modal = document.getElementById('buyout-modal');
    const selectedCheckboxes = document.querySelectorAll('.order-checkbox:checked');
    const selectedOrders = Array.from(selectedCheckboxes).map(cb => companyOrders.find(o => o.id == cb.dataset.orderId));

    if (selectedOrders.length === 0) return; // На всякий случай

    const ordersHtml = selectedOrders.map(o => `<li class="text-sm">${o.track_code} - ${o.buyout_item_cost_cny ?? '?'} CNY</li>`).join('');

    modal.querySelector('.modal-content').innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold">Массовый выкуп (${selectedOrders.length} заказов)</h3>
            <button onclick="closeModal('buyout-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
        </div>
        <p class="text-sm mb-2">Выбраны следующие заказы (статус будет изменен на "Выкуплен"):</p>
        <ul class="list-disc list-inside mb-4 max-h-40 overflow-y-auto p-2 bg-gray-50 rounded-md">${ordersHtml}</ul>
        <form id="buyout-form">
            <div>
                <label for="buyout-actual-rate-input" class="block text-sm font-medium text-gray-700">Введите реальный курс выкупа (сом/юань) *</label>
                <input type="number" step="any" id="buyout-actual-rate-input" class="mt-1 w-full p-2 border rounded" required placeholder="Например: 12.55">
            </div>
            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('buyout-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300">Отмена</button>
                <button type="submit" class="w-full bg-purple-600 text-white py-2 rounded hover:bg-purple-700">Подтвердить выкуп</button>
            </div>
        </form>
    `;
    openModal('buyout-modal');
    document.getElementById('buyout-form').addEventListener('submit', handleBulkBuyout);
}


// --- ФУНКЦИЯ: Обработка сохранения выкупа ---
async function handleBulkBuyout(e) {
    e.preventDefault();
    const rateInput = document.getElementById('buyout-actual-rate-input');
    const rate = parseFloat(rateInput?.value);
    
    if (isNaN(rate) || rate <= 0) {
        alert("Пожалуйста, введите корректный положительный курс.");
        return;
    }
    
    const ids = Array.from(document.querySelectorAll('.order-checkbox:checked')).map(cb => parseInt(cb.dataset.orderId));
    
    showLoader(); // Показываем лоадер

    try {
        const url = '/api/orders/bulk_action'; // Используем эндпоинт массовых действий
        const payload = { 
            action: 'buyout', 
            order_ids: ids, 
            buyout_actual_rate: rate 
        };

        const r = await apiFetch(url, {
            method: 'POST',
            body: JSON.stringify(payload)
        });

        console.log("[Bulk Buyout] Server response:", r);
        alert(r.message || `Выкуп успешно обработан для ${ids.length} заказов!`);
        
        closeModal('buyout-modal');
        await fetchAndRenderOrders(); // Обновляем список, чтобы увидеть статус "Выкуплен"
        toggleOrdersSelectMode(); // Выходим из режима выбора

    } catch (err) {
        console.error("!!! [Bulk Buyout] Error:", err);
        alert(`Ошибка при массовом выкупе: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
    }
}
// === КОНЕЦ ФУНКЦИЙ ПОИСКА И МАССОВЫХ ДЕЙСТВИЙ ===

// --- Функции для Редактирования Заказа ---

// Обработчик клика в списке заказов (делегирование)
// Ищет кнопку 'edit-order-btn' и вызывает openEditOrderModal
function handleOrderListClick(e) {
    // Ищем ближайший родительский элемент с классом 'edit-order-btn'
    const editButton = e.target.closest('.edit-order-btn');
    // Если кнопка найдена, получаем ID заказа и открываем модальное окно
    if (editButton) {
        const orderId = editButton.dataset.orderId;
        console.log(`[Order Action] Edit button clicked for Order ID: ${orderId}`);
        openEditOrderModal(orderId); // Вызываем функцию открытия модалки
    }
    // Здесь можно добавить обработку других кнопок внутри заказа, если они появятся
}

// Открывает модальное окно для Редактирования Заказа
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ openEditOrderModal)

function openEditOrderModal(orderId) {
    console.log(`[Modal] openEditOrderModal: Start for Order ID ${orderId}`);
    // Находим данные заказа в кэше companyOrders по ID
    const order = companyOrders.find(o => o.id == orderId); // Используем '=='

    // Проверяем, найден ли заказ и есть ли у него клиент
    if (!order) {
        console.error(`!!! openEditOrderModal: Order with ID ${orderId} not found in cache.`);
        alert("Ошибка: Не удалось найти данные заказа для редактирования.");
        return;
    }
     if (!order.client) {
         console.error(`!!! openEditOrderModal: Client data missing for Order ID ${orderId}.`);
         alert("Ошибка: Отсутствуют данные клиента для этого заказа.");
         return;
     }

    const modal = document.getElementById('edit-order-modal');
    if (!modal) return console.error("!!! openEditOrderModal: Modal element #edit-order-modal not found!");
    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openEditOrderModal: Modal content not found!");

    // --- Генерируем HTML для содержимого модального окна ---

    // Генерируем опции для select'а статусов
     const statusOptions = orderStatuses.map(s =>
         `<option value="${s}" ${order.status === s ? 'selected' : ''}>${s}</option>`
     ).join('');

    // --- HTML для выбора филиала (только Владелец) ---
    let locationSelectHtml = '';
    // Проверяем роль И наличие загруженных филиалов
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 0) {
        const locationOptions = companyLocations.map(loc =>
            // Отмечаем текущий филиал заказа
            `<option value="${loc.id}" ${loc.id === order.location_id ? 'selected' : ''}>${loc.name}</option>`
        ).join('');
        locationSelectHtml = `
            <div>
                <label for="modal-order-location" class="block text-sm font-medium text-gray-700">Филиал</label>
                <select id="modal-order-location" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500">
                    ${locationOptions}
                </select>
            </div>
        `;
    } else {
         // Для сотрудника или если филиалов нет, просто показываем текущий
         const currentLocationName = companyLocations.find(loc => loc.id === order.location_id)?.name || 'Неизвестный';
         locationSelectHtml = `
             <div>
                <label class="block text-sm font-medium text-gray-700">Филиал</label>
                <input type="text" class="mt-1 w-full p-2 border rounded bg-gray-100 cursor-not-allowed" value="${currentLocationName}" readonly title="Филиал заказа">
             </div>
         `;
    }
    // --- КОНЕЦ HTML для выбора филиала ---

    // Поля выкупа (если нужно)
    let buyoutHtml = '';
    if (order.purchase_type === 'Выкуп') {
        buyoutHtml = `
            <h4 class="text-md font-semibold mt-4 border-t pt-4 text-gray-700">Данные для Выкупа</h4>
             <div class="grid grid-cols-2 gap-4">
                 <div>
                     <label for="modal-order-buyout-cost" class="block text-sm font-medium text-gray-600">Стоимость (CNY)</label>
                     <input type="number" step="any" id="modal-order-buyout-cost" class="mt-1 w-full p-2 border rounded text-sm" value="${order.buyout_item_cost_cny || ''}">
                 </div>
                 <div>
                     <label for="modal-order-buyout-commission" class="block text-sm font-medium text-gray-600">Комиссия (%)</label>
                     <input type="number" step="1" id="modal-order-buyout-commission" value="${order.buyout_commission_percent ?? 10}" class="mt-1 w-full p-2 border rounded text-sm">
                 </div>
                 <div>
                     <label for="modal-order-buyout-rate" class="block text-sm font-medium text-gray-600">Курс для клиента</label>
                     <input type="number" step="any" id="modal-order-buyout-rate" class="mt-1 w-full p-2 border rounded text-sm" value="${order.buyout_rate_for_client || ''}">
                 </div>
                  <div>
                     <label for="modal-order-buyout-actual-rate" class="block text-sm font-medium text-gray-600">Реальный курс</label>
                     <input type="number" step="any" id="modal-order-buyout-actual-rate" class="mt-1 w-full p-2 border rounded text-sm" value="${order.buyout_actual_rate || ''}">
                 </div>
            </div>
        `;
    }

    // Собираем весь HTML модального окна
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold text-gray-800">Редактировать Заказ #${order.id}</h3>
            <button onclick="closeModal('edit-order-modal')" class="text-2xl font-bold leading-none p-1 -m-1 text-gray-500 hover:text-gray-700">&times;</button>
        </div>
        <form id="edit-order-form" data-order-id="${orderId}" class="space-y-4">
             <div class="grid grid-cols-2 gap-4">
                 <div>
                     <label for="modal-order-track-code" class="block text-sm font-medium text-gray-700">Трек-код *</label>
                     <input type="text" id="modal-order-track-code" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" required value="${order.track_code || ''}">
                 </div>
                 <div>
                     <label for="modal-order-status" class="block text-sm font-medium text-gray-700">Статус</label>
                     <select id="modal-order-status" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500">${statusOptions}</select>
                 </div>
            </div>
             <div class="grid grid-cols-2 gap-4">
                 <div>
                     <label for="modal-order-party-date" class="block text-sm font-medium text-gray-700">Дата Партии</label>
                     <input type="date" id="modal-order-party-date" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" value="${order.party_date || ''}">
                 </div>
                 ${locationSelectHtml}
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">Тип заказа</label>
                <input type="text" id="modal-order-purchase-type" class="mt-1 w-full p-2 border rounded bg-gray-100 cursor-not-allowed" value="${order.purchase_type || '?'}" readonly title="Тип заказа нельзя изменить после создания">
            </div>
            <div>
                <label for="modal-order-client-search" class="block text-sm font-medium text-gray-700">Клиент</label>
                <div class="relative">
                     <input type="text" id="modal-order-client-search" placeholder="Начните ввод для смены клиента..."
                            class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500"
                            value="${order.client.full_name} (${order.client.client_code_prefix || ''}${order.client.client_code_num || 'Нет кода'})">
                     <input type="hidden" id="modal-order-new-client-id" value="${order.client.id}">
                     <div id="modal-order-client-results" class="absolute hidden top-full left-0 right-0 bg-white border mt-1 rounded-md shadow-lg z-20 max-h-48 overflow-y-auto"></div>
                </div>
            </div>
            <div>
                <label for="modal-order-comment" class="block text-sm font-medium text-gray-700">Комментарий</label>
                <textarea id="modal-order-comment" class="mt-1 w-full p-2 border rounded h-16 focus:ring-indigo-500 focus:border-indigo-500" placeholder="Цвет, размер...">${order.comment || ''}</textarea>
            </div>

            ${buyoutHtml} 

            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('edit-order-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить Изменения</button>
            </div>
        </form>
    `;

    // --- ПРИВЯЗКА СЛУШАТЕЛЕЙ ПОСЛЕ ГЕНЕРАЦИИ HTML ---

    // Привязываем слушатель submit к форме
    const formElement = document.getElementById('edit-order-form');
    if (formElement) {
        // Используем replaceWith для удаления старых слушателей
        formElement.replaceWith(formElement.cloneNode(true));
        document.getElementById('edit-order-form').addEventListener('submit', handleSaveOrderChanges);
        console.log("[Modal Listener OK] Added submit to #edit-order-form");
    } else {
        console.error("!!! openEditOrderModal: Form #edit-order-form NOT FOUND!");
    }

    // Привязываем слушатель input к полю поиска клиента
    const clientSearchInput = document.getElementById('modal-order-client-search');
    if (clientSearchInput) {
        // Используем replaceWith для удаления старых слушателей
        clientSearchInput.replaceWith(clientSearchInput.cloneNode(true));
        document.getElementById('modal-order-client-search').addEventListener('input', (e) => {
            const resultsDiv = document.getElementById('modal-order-client-results');
            const selectedIdInput = document.getElementById('modal-order-new-client-id');
            handleGenericClientSearch(e.target, resultsDiv, (client) => {
                e.target.value = `${client.full_name} (${client.client_code_prefix || ''}${client.client_code_num || 'Нет кода'})`;
                if(selectedIdInput) selectedIdInput.value = client.id;
            });
        });
        console.log("[Modal Listener OK] Added input listener to #modal-order-client-search");
    } else {
        console.error("!!! openEditOrderModal: Input #modal-order-client-search NOT FOUND!");
    }
    // --- КОНЕЦ ПРИВЯЗКИ СЛУШАТЕЛЕЙ ---

    openModal('edit-order-modal');
    console.log(`[Modal] openEditOrderModal: End for Order ID ${orderId}`);
}
// --- Сохранение изменений Заказа (вызывается из модального окна редактирования) ---
// index.html (Полностью заменяет handleSaveOrderChanges)

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ handleSaveOrderChanges)

async function handleSaveOrderChanges(e) {
    e.preventDefault(); 
    console.log("[Save Order Changes] handleSaveOrderChanges: Start");
    showLoader(); 
    const form = e.target;
    const orderId = form.dataset.orderId; 

    if (!orderId) { 
        hideLoader(); 
        alert("Критическая ошибка: Не удалось определить ID редактируемого заказа."); 
        console.error("!!! handleSaveOrderChanges: Order ID not found in form data-attribute.");
        return; 
    }
    
    const newClientId = document.getElementById('modal-order-new-client-id')?.value;
    if (!newClientId || isNaN(parseInt(newClientId))) { 
        hideLoader(); 
        alert("Ошибка: Не удалось определить ID клиента. Пожалуйста, выберите клиента из поиска."); 
        console.error("!!! handleSaveOrderChanges: New Client ID is invalid or missing.");
        return; 
    }

    // Собираем данные ИЗ ПОЛЕЙ МОДАЛЬНОГО ОКНА
    const payload = {
        track_code: document.getElementById('modal-order-track-code')?.value.trim(),
        status: document.getElementById('modal-order-status')?.value,
        party_date: document.getElementById('modal-order-party-date')?.value || null, 
        client_id: parseInt(newClientId), 
        comment: document.getElementById('modal-order-comment')?.value.trim() || null, 
        // Поля выкупа
        buyout_item_cost_cny: parseFloat(document.getElementById('modal-order-buyout-cost')?.value) || null,
        // ИСПРАВЛЕНИЕ: Используем || вместо ??
        buyout_commission_percent: parseFloat(document.getElementById('modal-order-buyout-commission')?.value) || 10.0, 
        buyout_rate_for_client: parseFloat(document.getElementById('modal-order-buyout-rate')?.value) || null,
        buyout_actual_rate: parseFloat(document.getElementById('modal-order-buyout-actual-rate')?.value) || null,
        // location_id будет добавлен ниже
    };

    // --- ДОБАВЛЕНИЕ ЛОГИКИ LOCATION_ID (только если Владелец может редактировать) ---
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('modal-order-location');
        if (locationSelect && locationSelect.value) {
            payload.location_id = parseInt(locationSelect.value); 
            console.log("[Save Order Changes] Sending location_id:", payload.location_id);
        } else {
            console.log("[Save Order Changes] Location select not found or no value selected for Owner.");
        }
    }
    // --- КОНЕЦ ЛОГИКИ LOCATION_ID ---

    // Валидация
    if (!payload.track_code) { 
        hideLoader(); 
        alert("Трек-код не может быть пустым."); 
        console.warn("[Save Order Changes] Validation failed: track_code missing.");
        return; 
    }

    console.log(`[Save Order Changes] Sending PATCH to /api/orders/${orderId}. Payload:`, payload);
    try {
        const updatedOrder = await apiFetch(`/api/orders/${orderId}`, {
            method: 'PATCH',
            body: JSON.stringify(payload)
        });
        console.log("[Save Order Changes] Server response (updated order):", updatedOrder);
        alert(`Заказ #${orderId} успешно обновлен!`);
        closeModal('edit-order-modal'); 
        await fetchAndRenderOrders(); 

    } catch (err) { 
        console.error("!!! [Save Order Changes] Error:", err);
        alert(`Ошибка обновления заказа #${orderId}: ${err.message}`);
    } finally {
        hideLoader(); 
        console.log("[Save Order Changes] handleSaveOrderChanges: End");
    }
}


// --- Общие вспомогательные функции (Универсальный поиск клиента и Экспорт) ---

// Универсальная функция поиска клиента (используется в Нескольких местах)
// inputElement - поле ввода текста
// resultsDivElement - div для отображения результатов
// onSelectCallback - функция, вызываемая при выборе клиента (получает объект client)
function handleGenericClientSearch(inputElement, resultsDivElement, onSelectCallback) {
     if (!inputElement || !resultsDivElement || !onSelectCallback) {
          console.error("[Client Search Util] Missing arguments for handleGenericClientSearch.");
          return;
     }
     const searchTerm = inputElement.value; // Текущий текст в поле ввода

     // Скрываем результаты, если поле пустое
     if (!searchTerm || searchTerm.length < 1) {
         resultsDivElement.innerHTML = '';
         resultsDivElement.classList.add('hidden');
         return;
     }

     // Debounce: ждем 300мс после последнего ввода перед поиском
     clearTimeout(inputElement.debounceTimer); // Сбрасываем предыдущий таймер
     inputElement.debounceTimer = setTimeout(async () => {
         console.log(`[Client Search Util] Searching for: "${searchTerm}"`);
         resultsDivElement.innerHTML = '<div class="p-2 text-sm text-gray-500 animate-pulse">Поиск...</div>'; // Индикатор
         resultsDivElement.classList.remove('hidden'); // Показываем
         try {
             // Запрос к API
             const clients = await apiFetch(`/api/clients/search?q=${encodeURIComponent(searchTerm)}`);
             console.log(`[Client Search Util] Found ${clients.length} clients.`);

             if (clients && clients.length > 0) {
                 // Генерируем HTML для найденных клиентов
                 resultsDivElement.innerHTML = clients.map(c => `
                     <div class="p-2 hover:bg-indigo-50 cursor-pointer text-sm search-result-item border-b last:border-b-0"
                          data-client-json='${JSON.stringify(c)}'>
                         ${c.full_name} (${c.client_code_prefix || ''}${c.client_code_num || 'Нет кода'}) - ${c.phone}
                     </div>
                 `).join('');
                 // Добавляем обработчики клика к результатам
                 resultsDivElement.querySelectorAll('.search-result-item').forEach(item => {
                     item.addEventListener('click', () => {
                         try {
                              const clientData = JSON.parse(item.dataset.clientJson); // Извлекаем данные
                              console.log(`[Client Search Util] Client selected:`, clientData);
                              onSelectCallback(clientData); // Вызываем callback с выбранным клиентом
                              resultsDivElement.innerHTML = ''; // Очищаем результаты
                              resultsDivElement.classList.add('hidden'); // Скрываем список
                         } catch (e) {
                              console.error("[Client Search Util] Error parsing client data from click:", e);
                              alert("Ошибка выбора клиента.");
                         }
                     });
                 });
             } else {
                 resultsDivElement.innerHTML = '<div class="p-2 text-sm text-gray-500">Клиенты не найдены.</div>';
             }
         } catch (error) { // Обработка ошибок поиска
             console.error("[Client Search Util] Error:", error);
             resultsDivElement.innerHTML = `<div class="p-2 text-sm text-red-500">Ошибка поиска: ${error.message}</div>`;
         }
     }, 300); // Задержка debounce
 }

// Функция экспорта отфильтрованных заказов в Excel
function handleExportOrders() {
     console.log("[Export Orders] handleExportOrders: Start");
     // Используем текущий кэш заказов (companyOrders), который отражает примененные фильтры
     if (!companyOrders || companyOrders.length === 0) {
         alert('Нет данных для экспорта. Пожалуйста, сначала загрузите или отфильтруйте заказы.');
         return;
     }
     // Проверяем наличие библиотеки XLSX
     if (typeof XLSX === 'undefined') {
         alert("Ошибка: Библиотека XLSX для экспорта не загружена.");
         return;
     }

     console.log(`[Export Orders] Preparing to export ${companyOrders.length} orders...`);
     showLoader(); // Показываем лоадер на время подготовки файла

     try {
         // Преобразуем данные заказов в формат для листа Excel
         const dataToExport = companyOrders.map(order => ({
             'Дата Партии': order.party_date || '',
             'Трек-код': order.track_code || '',
             'Статус': order.status || '',
             'Клиент ФИО': order.client?.full_name || '?',
             'Клиент Телефон': order.client?.phone || '?',
             'Клиент Код': `${order.client?.client_code_prefix || ''}${order.client?.client_code_num || ''}`,
             'Комментарий': order.comment || '',
             'Тип': order.purchase_type || '',
             'Цена CNY': order.buyout_item_cost_cny ?? '', // Используем ?? для пустых значений вместо null/undefined
             'Курс Клиент': order.buyout_rate_for_client ?? '',
             'Комиссия %': order.buyout_commission_percent ?? '',
             'Реал. Курс': order.buyout_actual_rate ?? '',
             'Расчет Вес': order.calculated_weight_kg ?? '',
             'Расчет Сумма': order.calculated_final_cost_som ?? '',
             'Дата Выдачи': order.issued_at ? new Date(order.issued_at).toLocaleString('ru-RU') : '', // Форматируем дату
             'Факт Вес': order.weight_kg ?? '',
             'Факт Сумма': order.final_cost_som ?? ''
             // Можно добавить любые другие поля из объекта order
         }));
         console.log("[Export Orders] Data prepared for sheet.");

         // Создаем новый лист Excel из подготовленных данных
         const worksheet = XLSX.utils.json_to_sheet(dataToExport);
         console.log("[Export Orders] Worksheet created.");

         // Создаем новую книгу Excel
         const workbook = XLSX.utils.book_new();

         // Добавляем лист в книгу
         XLSX.utils.book_append_sheet(workbook, worksheet, 'Заказы'); // Имя листа "Заказы"
         console.log("[Export Orders] Worksheet appended to workbook.");

         // Генерируем имя файла с датой и названием компании
         const today = new Date().toISOString().split('T')[0];
         const companyName = currentCompany ? currentCompany.name.replace(/\s+/g, '_') : 'SuperAdmin';
         const filename = `Экспорт_Заказов_${companyName}_${today}.xlsx`;
         console.log(`[Export Orders] Generated filename: ${filename}`);

         // Запускаем скачивание файла браузером
         XLSX.writeFile(workbook, filename);
         console.log("[Export Orders] Download initiated.");
         alert(`Экспорт ${companyOrders.length} заказов в файл "${filename}" начат.`);

     } catch (e) { // Обработка ошибок при создании Excel
          console.error("!!! [Export Orders] Error creating Excel file:", e);
          alert("Не удалось создать Excel файл для экспорта. Подробности в консоли.");
     } finally {
          hideLoader(); // Скрываем лоадер
          console.log("[Export Orders] handleExportOrders: End");
     }
 }
// === КОНЕЦ МОДУЛЯ ЗАКАЗЫ ===

// =================================================================
// МОДУЛЬ: ВЫДАЧА (Issuance) (v4.1 - Rebuild)
// =================================================================

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ renderIssueTab)

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ renderIssueTab)

async function renderIssueTab() {
    console.log("[Render] renderIssueTab: Start");
    const pane = document.getElementById('tab-issue');
    if (!pane) {
         console.warn("[Render] renderIssueTab: Pane #tab-issue not found.");
         return;
    }

    // --- ГЕНЕРИРУЕМ HTML ДЛЯ ФИЛЬТРА ФИЛИАЛОВ (ТОЛЬКО ДЛЯ ВЛАДЕЛЬЦА) ---
    let locationFilterHtml = '';
    // Показываем, если Владелец И филиалов БОЛЬШЕ одного И филиалы загружены
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            // Предварительно выбираем основной филиал Владельца, если он есть
            `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`
        ).join('');

        locationFilterHtml = `
            <div class="p-2 bg-gray-100 rounded-md shadow-sm relative">
                <label for="issue-location-filter" class="text-xs font-medium text-gray-700 mr-2">Филиал:</label>
                <select id="issue-location-filter" class="rounded-md border-gray-300 p-1.5 text-xs bg-white shadow-sm w-36">
                    <option value="">-- Все филиалы --</option>
                    ${locationOptions}
                </select>
            </div>
        `;
        console.log("[Render] renderIssueTab: Location filter HTML generated.");
    } else {
         console.warn("[Render] renderIssueTab: Location filter NOT generated. Role:", currentUser.role, "Locations:", companyLocations?.length);
    }
    // --- КОНЕЦ ГЕНЕРАЦИИ ФИЛЬТРА ---

    // Генерируем основной HTML для вкладки "Выдача"
    pane.innerHTML = `
        <div id="issue-container" class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold text-gray-800">Заказы, готовые к выдаче</h2>
                <div class="flex items-center gap-4 flex-wrap"> 
                    
                    ${locationFilterHtml} 
                    
                    <button id="show-issued-history-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded text-sm">История выданных</button>
                    <button id="refresh-issue-list-btn" title="Обновить список" class="text-2xl ml-auto text-gray-500 hover:text-indigo-600">&circlearrowright;</button> 
                </div>
            </div>
            <div class="mb-4">
                <input type="search" id="issue-search-input" placeholder="🔍 Поиск по клиенту, телефону, трек-коду..." class="w-full p-2 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div id="issue-list" class="space-y-4">
                <p class="text-gray-500 animate-pulse">Загрузка заказов для выдачи...</p>
            </div>
        </div>
    `;

    // --- Привязываем слушатели ---
    const containerDiv = document.getElementById('issue-container');
    if (containerDiv) {
        document.getElementById('show-issued-history-btn')?.addEventListener('click', showIssuedHistory);
        document.getElementById('refresh-issue-list-btn')?.addEventListener('click', fetchAndRenderIssueList);
        document.getElementById('issue-search-input')?.addEventListener('input', handleIssueSearch);
        
        // Привязываем слушатель к фильтру филиалов, ЕСЛИ ОН БЫЛ СОЗДАН
        const locationFilterSelect = document.getElementById('issue-location-filter');
        if (locationFilterSelect) {
            const newSelect = locationFilterSelect.cloneNode(true);
            locationFilterSelect.parentNode?.replaceChild(newSelect, locationFilterSelect);
            newSelect.addEventListener('change', fetchAndRenderIssueList); 
            console.log("[Listener OK] Added change to #issue-location-filter");
        }
        
        // Список заказов (делегирование)
        const issueListDiv = document.getElementById('issue-list');
        if (issueListDiv) {
            const newListDiv = issueListDiv.cloneNode(false); 
            issueListDiv.parentNode?.replaceChild(newListDiv, issueListDiv);
            newListDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка заказов...</p>'; 
            newListDiv.addEventListener('change', handleIssueCheckboxChange);
            newListDiv.addEventListener('click', handleIssueButtonClick);
            console.log("[Listener OK] Added delegate listeners to #issue-list");
        }

        await fetchAndRenderIssueList(); 
        
    } else {
        console.error("!!! renderIssueTab: #issue-container not found.");
    }
    console.log("[Render] renderIssueTab: End");
}


async function fetchAndRenderIssueList() {
    console.log("[Fetch] fetchAndRenderIssueList: Start");
    const listDiv = document.getElementById('issue-list');
    if (!listDiv) return;

    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка заказов...</p>';
    showLoader();

    // --- ИСПРАВЛЕНИЕ: Считываем выбранный location_id для Владельца ---
    const params = new URLSearchParams();
    if (currentUser.role === 'Владелец') {
        const locationFilterSelect = document.getElementById('issue-location-filter');
        // Проверяем, что select существует И в нем выбрано НЕ пустое значение ("-- Все филиалы --")
        if (locationFilterSelect && locationFilterSelect.value) {
            params.append('location_id', locationFilterSelect.value);
            console.log("[Fetch Issue List] Filtering by location_id:", locationFilterSelect.value);
        } else {
             console.log("[Fetch Issue List] Owner viewing all locations.");
        }
    }
    // Обычный сотрудник НЕ передает location_id, бэкенд отфильтрует сам
    const url = `/api/orders/ready_for_issue?${params.toString()}`; // Добавляем параметры к URL
    console.log("[Fetch Issue List] Requesting URL:", url);
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    try {
        // Запрашиваем заказы со статусом "Готов к выдаче"
        const ordersReady = await apiFetch(url); // Используем URL с параметрами

        // Группируем по клиенту (код остается)
        const ordersByClient = ordersReady.reduce((acc, order) => {
            const client_id = order.client?.id || 'unknown';
            if (!acc[client_id]) {
                acc[client_id] = { client: order.client, orders: [] };
            }
            acc[client_id].orders.push(order);
            return acc;
        }, {});

        listDiv.innerHTML = ''; // Очищаем перед рендерингом
        if (Object.keys(ordersByClient).length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">Нет заказов, готовых к выдаче (с учетом фильтра).</p>';
            return;
        }

        // Рендерим группы (код остается)
        for (const clientId in ordersByClient) {
            const group = ordersByClient[clientId];
            const client = group.client || { full_name: '?', phone: '?', client_code_prefix: '', client_code_num: '?' };
            const clientCode = `${client.client_code_prefix || ''}${client.client_code_num || '?'}`;

            const ordersHtml = group.orders.map(o => `
                <li class="flex items-center gap-2">
                    <input type="checkbox" class="issue-order-checkbox h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                           data-order-id="${o.id}" data-client-id="${clientId}" data-track-code="${o.track_code}">
                    <span>${o.track_code} ${o.comment ? `(${o.comment})` : ''}</span>
                    ${o.calculated_final_cost_som ? `<span class="text-xs text-blue-600 ml-auto">${o.calculated_final_cost_som.toFixed(0)} сом</span>` : ''}
                </li>
            `).join('');

            const clientDiv = document.createElement('div');
            clientDiv.className = 'client-group p-4 bg-gray-50 rounded-lg shadow-sm border';
            clientDiv.dataset.clientName = client.full_name?.toLowerCase() || '';
            clientDiv.dataset.clientCode = clientCode.toLowerCase();
            clientDiv.dataset.clientPhone = client.phone || '';
            clientDiv.dataset.trackCodes = group.orders.map(o => o.track_code?.toLowerCase() || '').join(',');

            clientDiv.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <div class="flex items-center gap-3">
                        <input type="checkbox" class="select-all-client-orders h-5 w-5 rounded border-gray-400 text-indigo-600 focus:ring-indigo-500"
                               data-client-id="${clientId}" title="Выбрать все заказы клиента">
                        <div>
                            <h3 class="font-bold text-lg">${client.full_name} (${clientCode})</h3>
                            <p class="text-sm text-gray-600">${client.phone}</p>
                        </div>
                    </div>
                    <button class="issue-btn bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                            data-client-id="${clientId}" disabled>Выдать выбранное</button>
                </div>
                <ul class="mt-2 space-y-1 pl-8">${ordersHtml}</ul>
            `;
            listDiv.appendChild(clientDiv);
        }
        console.log("[Fetch] fetchAndRenderIssueList: Render complete.");

    } catch (error) {
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки: ${error.message}</p>`;
    } finally {
        hideLoader();
    }
}

// --- Обработчик изменения чекбоксов на вкладке Выдача ---
function handleIssueCheckboxChange(e) {
    const target = e.target;
    let clientId = target.dataset.clientId;

    // Обработка "Выбрать все" для клиента
    if (target.classList.contains('select-all-client-orders')) {
        const isChecked = target.checked;
        document.querySelectorAll(`.issue-order-checkbox[data-client-id="${clientId}"]`).forEach(cb => cb.checked = isChecked);
    } 
    // Обработка одиночного чекбокса (обновляем "Выбрать все", если нужно)
    else if (target.classList.contains('issue-order-checkbox')) {
        clientId = target.dataset.clientId; // Переопределяем на всякий случай
        const allCheckboxes = document.querySelectorAll(`.issue-order-checkbox[data-client-id="${clientId}"]`);
        const checkedCount = document.querySelectorAll(`.issue-order-checkbox[data-client-id="${clientId}"]:checked`).length;
        const selectAll = document.querySelector(`.select-all-client-orders[data-client-id="${clientId}"]`);
        
        if (selectAll) {
             if (checkedCount === 0) {
                 selectAll.checked = false;
                 selectAll.indeterminate = false;
             } else if (checkedCount === allCheckboxes.length) {
                 selectAll.checked = true;
                 selectAll.indeterminate = false;
             } else {
                 selectAll.checked = false;
                 selectAll.indeterminate = true;
             }
        }
    } else {
         return; // Выходим, если клик не по чекбоксу
    }
    
    // Обновляем состояние кнопки "Выдать" для этого клиента
    const issueBtn = document.querySelector(`.issue-btn[data-client-id="${clientId}"]`);
    if (issueBtn) {
        const anyChecked = document.querySelector(`.issue-order-checkbox[data-client-id="${clientId}"]:checked`);
        issueBtn.disabled = !anyChecked; // Кнопка активна, если выбран хотя бы 1 заказ
    }
}

// --- Обработчик клика по кнопке "Выдать" ---
function handleIssueButtonClick(e) {
    const target = e.target.closest('.issue-btn');
    if (target && !target.disabled) {
        const clientId = target.dataset.clientId;
        const selectedCheckboxes = document.querySelectorAll(`.issue-order-checkbox[data-client-id="${clientId}"]:checked`);
        const ordersToIssue = Array.from(selectedCheckboxes).map(cb => ({
            id: parseInt(cb.dataset.orderId),
            track_code: cb.dataset.trackCode
        }));

        if (ordersToIssue.length > 0) {
            renderIssueModal(ordersToIssue); // Открываем модальное окно выдачи
        }
    }
}

// --- Рендеринг Модального Окна Выдачи ---
async function renderIssueModal(ordersToIssue) {
    const issueModal = document.getElementById('issue-modal');
    const modalContent = issueModal.querySelector('.modal-content');
    modalContent.innerHTML = '<p>Загрузка данных для выдачи...</p>';
    openModal('issue-modal');
    showLoader();

    try {
        // Получаем полные данные заказов из кэша (для предрасчитанной суммы)
        const fullOrderData = ordersToIssue.map(o => companyOrders.find(co => co.id === o.id)).filter(Boolean);
        let preCalculatedTotal = 0;
        fullOrderData.forEach(o => preCalculatedTotal += o.calculated_final_cost_som || 0);

        const ordersHtml = ordersToIssue.map(o => `
            <div class="flex justify-between items-center border-b pb-2 mb-2">
                <span class="font-semibold text-sm">${o.track_code}</span>
                <input type="number" step="any" placeholder="Вес (кг)" class="issue-weight-input w-24 p-1 border rounded text-sm" 
                       data-order-id="${o.id}" required>
            </div>
        `).join('');
        
        // Получаем курсы и цену по умолчанию из ТЕКУЩЕЙ АКТИВНОЙ смены
        let defaultPrice = 5.5; 
        let defaultRate = 87.5;
        if (activeShift) { // Используем данные активной смены, если она есть
             defaultPrice = activeShift.price_per_kg_usd || defaultPrice;
             defaultRate = activeShift.exchange_rate_usd || defaultRate;
        }

        modalContent.innerHTML = `
            <div class="flex justify-between items-start mb-4">
                 <h3 class="text-2xl font-bold">Оформление выдачи (${ordersToIssue.length} зак.)</h3>
                 <button onclick="closeModal('issue-modal')" class="text-2xl font-bold">&times;</button>
            </div>
            <form id="issue-form">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="space-y-4">
                        <div class="p-3 bg-blue-50 rounded-lg">
                            <label class="block text-sm font-medium">Общий вес (кг)</label>
                            <input type="number" step="any" id="total-weight-input" placeholder="Для авто-распределения" class="mt-1 w-full p-2 border rounded-md">
                        </div>
                        <div class="max-h-60 overflow-y-auto pr-2">${ordersHtml}</div>
                        <div class="p-3 bg-gray-100 rounded-lg space-y-2">
                            <div> <label class="block text-sm">Цена за кг ($)</label> <input type="number" step="0.1" id="issue-price-per-kg" value="${defaultPrice}" class="w-full p-2 border rounded"> </div>
                            <div> <label class="block text-sm">Курс USD (сом)</label> <input type="number" step="0.1" id="issue-exchange-rate" value="${defaultRate}" class="w-full p-2 border rounded"> </div>
                        </div>
                    </div>
                    <div class="space-y-4">
                        <div> <label class="block text-sm font-medium">Способ оплаты</label> <select id="payment-method-select" class="w-full mt-1 p-2 border rounded-md bg-white"> <option value="cash">Наличные</option> <option value="card">Картой</option> <option value="mixed">Смешанный</option> </select> </div>
                        <div id="payment-fields-container" class="space-y-3"></div>
                        <div class="p-4 bg-indigo-50 rounded-lg text-right space-y-2">
                            ${preCalculatedTotal > 0 ? `<div class="text-sm text-gray-600">Предварительная сумма: ${preCalculatedTotal.toFixed(2)} сом</div>` : ''}
                            <div class="text-lg">Итого к оплате (факт): <span id="total-cost-display" class="font-bold">0.00 сом</span></div>
                            <div class="text-md">Всего оплачено: <span id="total-paid-display" class="font-bold">0.00 сом</span></div>
                            <div class="text-xl text-green-600">Сдача: <span id="change-display" class="font-bold">0.00 сом</span></div>
                        </div>
                    </div>
                </div>
                <div class="mt-6 flex justify-end gap-4">
                    <button type="button" onclick="closeModal('issue-modal')" class="bg-gray-300 hover:bg-gray-400 text-black font-bold py-2 px-6 rounded-lg">Отмена</button>
                    <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg">Выдать</button>
                </div>
            </form>
        `;
        
        // Добавляем логику для полей оплаты и расчета
        setupIssueModalLogic(); 

    } catch (error) {
         modalContent.innerHTML = `<p class="text-red-500">Ошибка подготовки к выдаче: ${error.message}</p>`;
    } finally {
         hideLoader();
    }
}

// --- Логика модального окна выдачи (расчет, поля оплаты) ---
function setupIssueModalLogic() {
    const form = document.getElementById('issue-form');
    const paymentMethodSelect = document.getElementById('payment-method-select');
    const paymentFieldsContainer = document.getElementById('payment-fields-container');
    const totalWeightInput = document.getElementById('total-weight-input');
    const individualWeightInputs = document.querySelectorAll('.issue-weight-input');
    const priceInput = document.getElementById('issue-price-per-kg');
    const rateInput = document.getElementById('issue-exchange-rate');
    let totalCost = 0; // Глобальная (в рамках модалки) переменная для итоговой стоимости

    const updateTotals = () => {
        const price = parseFloat(priceInput.value) || 0;
        const rate = parseFloat(rateInput.value) || 0;
        let totalWeight = 0;
        individualWeightInputs.forEach(input => { totalWeight += parseFloat(input.value) || 0; });
        totalCost = totalWeight * price * rate;
        document.getElementById('total-cost-display').textContent = `${totalCost.toFixed(2)} сом`;
        updatePaymentFields(); // Пересчитываем оплату, т.к. изменилась итоговая сумма
    };

    const updatePaymentFields = () => {
        const method = paymentMethodSelect.value;
        let cashPaid = parseFloat(document.getElementById('issue-paid-cash')?.value) || 0;
        let cardPaid = parseFloat(document.getElementById('issue-paid-card')?.value) || 0;
        
        // Если выбрана оплата картой, поле карты заполняется автоматически
        if (method === 'card') {
            cardPaid = totalCost;
            cashPaid = 0; // Наличных нет
             const cardInput = document.getElementById('issue-paid-card');
             if (cardInput) cardInput.value = cardPaid.toFixed(2);
        }
        
        let totalPaid = cashPaid + cardPaid;
        let change = totalPaid > totalCost ? totalPaid - totalCost : 0;
        
        document.getElementById('total-paid-display').textContent = `${totalPaid.toFixed(2)} сом`;
        document.getElementById('change-display').textContent = `${change.toFixed(2)} сом`;
    };

    const renderPaymentFields = () => {
        const method = paymentMethodSelect.value;
        paymentFieldsContainer.innerHTML = '';
        const cashField = `<div><label class="block text-sm">Наличными (сом)</label><input type="number" id="issue-paid-cash" value="0" step="any" class="w-full p-2 border rounded"></div>`;
        // Поле карты делаем readonly только если выбрана оплата ТОЛЬКО картой
        const cardField = `<div><label class="block text-sm">Картой (сом)</label><input type="number" id="issue-paid-card" value="0.00" step="any" class="w-full p-2 border rounded" ${method === 'card' ? 'readonly' : ''}></div>`;
        // Типы карт - TODO: Загрузить из config на сервере?
        const cardTypes = ["MBank", "Optima", "DemirBank", "Другое"]; 
        const cardTypeField = `<div><label class="block text-sm">Тип карты</label><select id="issue-card-type" class="w-full p-2 border rounded bg-white">${cardTypes.map(t => `<option value="${t}">${t}</option>`).join('')}</select></div>`;

        if (method === 'cash') paymentFieldsContainer.innerHTML = cashField;
        if (method === 'card') paymentFieldsContainer.innerHTML = cardField + cardTypeField;
        if (method === 'mixed') paymentFieldsContainer.innerHTML = cashField + cardField + cardTypeField;

        // Добавляем слушатели к полям оплаты ПОСЛЕ их создания
        document.getElementById('issue-paid-cash')?.addEventListener('input', () => {
            // В смешанном режиме авто-заполняем карту остатком
            if (method === 'mixed') {
                const cashAmount = parseFloat(document.getElementById('issue-paid-cash').value) || 0;
                const remainder = totalCost - cashAmount;
                document.getElementById('issue-paid-card').value = (remainder > 0 ? remainder : 0).toFixed(2);
            }
            updatePaymentFields(); // Пересчитываем общую оплату и сдачу
        });
        document.getElementById('issue-paid-card')?.addEventListener('input', updatePaymentFields);
        
        updateTotals(); // Вызываем один раз для инициализации и расчета при card/cash
    };

    renderPaymentFields(); // Рендерим поля оплаты при инициализации
    paymentMethodSelect.addEventListener('change', renderPaymentFields); // Перерендериваем при смене способа
    [priceInput, rateInput].forEach(el => el.addEventListener('input', updateTotals)); // Слушатели цены/курса
    
    // Слушатель общего веса
    totalWeightInput.addEventListener('input', () => {
        const totalWeight = parseFloat(totalWeightInput.value) || 0;
        if (totalWeight >= 0 && individualWeightInputs.length > 0) {
            const weightPerItem = (totalWeight / individualWeightInputs.length).toFixed(3);
            individualWeightInputs.forEach(input => { input.value = weightPerItem; });
        } else { individualWeightInputs.forEach(input => { input.value = ''; }); }
        updateTotals(); // Пересчитываем итог
    });
    
    // Слушатели индивидуальных весов
    individualWeightInputs.forEach(input => {
        input.addEventListener('input', () => {
            totalWeightInput.value = ''; // Сбрасываем общий вес
            updateTotals(); // Пересчитываем итог
        });
    });
    
    // Слушатель отправки формы
    form.addEventListener('submit', handleIssueSubmit);
}

// --- Обработчик отправки формы выдачи ---
async function handleIssueSubmit(e) {
    e.preventDefault();
    const ordersPayload = Array.from(document.querySelectorAll('.issue-weight-input')).map(input => ({
        order_id: parseInt(input.dataset.orderId),
        weight_kg: parseFloat(input.value)
    }));
    
    // Валидация веса
    if (ordersPayload.some(o => !o.weight_kg || o.weight_kg <= 0)) {
        alert('Ошибка: Вес должен быть указан (больше нуля) для всех заказов.');
        return;
    }
    
    const method = document.getElementById('payment-method-select').value;
    const paidCash = (method === 'cash' || method === 'mixed') ? (parseFloat(document.getElementById('issue-paid-cash')?.value) || 0) : 0;
    const paidCard = (method === 'card' || method === 'mixed') ? (parseFloat(document.getElementById('issue-paid-card')?.value) || 0) : 0;
    
    // Простая проверка суммы оплаты (можно улучшить, сравнив с totalCost)
    if (paidCash < 0 || paidCard < 0) {
        alert("Суммы оплаты не могут быть отрицательными."); return;
    }

    const payload = {
        orders: ordersPayload,
        price_per_kg_usd: parseFloat(document.getElementById('issue-price-per-kg').value),
        exchange_rate_usd: parseFloat(document.getElementById('issue-exchange-rate').value),
        paid_cash: paidCash,
        paid_card: paidCard,
        card_payment_type: (method === 'card' || method === 'mixed') ? document.getElementById('issue-card-type')?.value : null
    };

    // Валидация цены и курса
    if (!payload.price_per_kg_usd || payload.price_per_kg_usd <= 0 || !payload.exchange_rate_usd || payload.exchange_rate_usd <= 0) {
        alert("Пожалуйста, укажите корректные цену и курс."); return;
    }

    showLoader(); 
    try {
        const response = await apiFetch('/api/orders/issue', { // Используем /api
            method: 'POST',
            body: JSON.stringify(payload)
        });
        
        alert(response.message || 'Заказы успешно выданы!');
        closeModal('issue-modal');
        await fetchAndRenderIssueList(); // Обновляем список готовых к выдаче
        
    } catch (error) {
        alert(`Ошибка при выдаче: ${error.message}`);
    } finally {
        hideLoader(); 
    }
}

// --- Функции для Истории Выданных ---

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ showIssuedHistory)

async function showIssuedHistory() {
    const issuedHistoryModal = document.getElementById('issued-history-modal');
    const modalContent = issuedHistoryModal.querySelector('.modal-content');
    const today = new Date().toISOString().split('T')[0];

    // --- HTML для фильтра филиалов (только Владелец) ---
    let locationFilterHistoryHtml = '';
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`
        ).join('');
        locationFilterHistoryHtml = `
            <div class="flex-shrink-0">
                <label for="history-location-filter" class="block text-sm font-medium text-gray-700">Филиал:</label>
                <select id="history-location-filter" class="mt-1 p-2 border rounded-md bg-white text-sm w-40">
                    <option value="">-- Все филиалы --</option>
                    ${locationOptions}
                </select>
            </div>
        `;
    }
    // --- КОНЕЦ HTML ФИЛЬТРА ---

    modalContent.innerHTML = `
        <div class="flex justify-between items-center mb-4">
             <h3 class="text-2xl font-bold">История выданных заказов</h3>
             <button onclick="closeModal('issued-history-modal')" class="text-2xl font-bold">&times;</button>
        </div>
        <div class="flex flex-wrap gap-4 items-end p-4 bg-gray-50 rounded-lg mb-4 border">
            
            <div> <label for="history-start-date" class="block text-sm font-medium">С</label> <input type="date" id="history-start-date" value="${today}" class="mt-1 p-2 border rounded-md"> </div>
            <div> <label for="history-end-date" class="block text-sm font-medium">По</label> <input type="date" id="history-end-date" value="${today}" class="mt-1 p-2 border rounded-md"> </div>
            
            ${locationFilterHistoryHtml}
            
            <button id="filter-history-btn" class="bg-blue-600 text-white py-2 px-4 rounded-md ml-auto">Показать</button>
        </div>
        <div id="history-content" class="overflow-y-auto max-h-[60vh]">
            <p class="animate-pulse">Загрузка истории...</p>
        </div>
    `;
    openModal('issued-history-modal');

    // Привязываем слушатель к кнопке "Показать" и фильтру филиалов
    document.getElementById('filter-history-btn')?.addEventListener('click', fetchAndRenderHistory);
    document.getElementById('history-location-filter')?.addEventListener('change', fetchAndRenderHistory); // Добавляем слушатель
    
    // Сразу загружаем историю за сегодня
    await fetchAndRenderHistory();
}

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ fetchAndRenderHistory)

async function fetchAndRenderHistory() {
    const contentDiv = document.getElementById('history-content');
    const startDate = document.getElementById('history-start-date')?.value;
    const endDate = document.getElementById('history-end-date')?.value;
    if (!contentDiv || !startDate || !endDate) return;

    contentDiv.innerHTML = '<p class="animate-pulse">Загрузка истории...</p>';
    showLoader(); 

    // --- ДОБАВЛЕНИЕ: Считываем и передаем location_id ---
    const params = new URLSearchParams({
        start_date: startDate,
        end_date: endDate
    });
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('history-location-filter');
        if (locationSelect && locationSelect.value) {
            params.append('location_id', locationSelect.value);
            console.log("[Fetch History] Filtering history by location_id:", locationSelect.value);
        }
    }
    const url = `/api/orders/issued?${params.toString()}`;
    console.log("[Fetch History] Requesting URL:", url);
    // --- КОНЕЦ ДОБАВЛЕНИЯ ---

    try {
        const issuedOrders = await apiFetch(url); // Используем URL с параметрами

        if (!issuedOrders || issuedOrders.length === 0) {
            contentDiv.innerHTML = '<p class="text-gray-500">Выданных заказов за этот период (с учетом фильтра) нет.</p>';
            return;
        }

        const tableRows = issuedOrders.map(o => `
            <tr class="border-b hover:bg-gray-50 text-sm">
                <td class="p-2">${new Date(o.issued_at).toLocaleString()}</td>
                <td class="p-2">${o.client?.full_name || '?'} (${o.client?.client_code_prefix || ''}${o.client?.client_code_num || '?'})</td>
                <td class="p-2">${o.track_code}</td>
                <td class="p-2">${o.weight_kg?.toFixed(3) || '-'} кг</td>
                <td class="p-2">${o.final_cost_som?.toFixed(2) || '-'} сом</td>
                <td class="p-2">
                    <button class="revert-status-btn text-xs bg-yellow-400 hover:bg-yellow-500 text-yellow-900 px-2 py-1 rounded" 
                            data-order-id="${o.id}">Вернуть</button>
                </td>
            </tr>
        `).join('');

        contentDiv.innerHTML = `
            <div class="mb-4">
                 <input type="search" id="history-search-input" placeholder="🔍 Поиск по клиенту, трек-коду..." class="w-full p-2 border rounded-lg">
            </div>
            <div class="overflow-y-auto max-h-[50vh]">
                <table class="w-full text-left" id="history-table">
                    <thead class="bg-gray-100 sticky top-0">
                        <tr class="text-xs font-semibold uppercase text-gray-600">
                           <th class="p-2">Дата выдачи</th>
                           <th class="p-2">Клиент</th>
                           <th class="p-2">Трек-код</th>
                           <th class="p-2">Вес</th>
                           <th class="p-2">Сумма</th>
                           <th class="p-2">Действие</th>
                        </tr>
                    </thead>
                    <tbody>${tableRows}</tbody>
                </table>
            </div>
        `;

        // Привязываем слушатели
        document.getElementById('history-search-input')?.addEventListener('input', handleHistorySearch);
        contentDiv.querySelector('#history-table tbody')?.addEventListener('click', e => {
            const revertBtn = e.target.closest('.revert-status-btn');
            if (revertBtn) {
                const orderId = revertBtn.dataset.orderId;
                if (confirm('Вы уверены, что хотите вернуть этот заказ? Оплата будет отменена.')) {
                    handleRevertStatus(orderId);
                }
            }
        });

    } catch (error) {
        contentDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки истории: ${error.message}</p>`;
    } finally {
        hideLoader(); 
    }
}

// Поиск по истории выданных
function handleHistorySearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim();
    document.querySelectorAll('#history-table tbody tr').forEach(row => {
        const rowContent = row.textContent?.toLowerCase() || '';
        row.style.display = rowContent.includes(searchTerm) ? '' : 'none';
    });
}

// Обработка возврата статуса
async function handleRevertStatus(orderId) {
    console.log(`[Revert] Reverting order ID: ${orderId}`);
    showLoader(); 
    try {
        // Вызываем PATCH /api/orders/{id}/revert_status
        await apiFetch(`/api/orders/${orderId}/revert_status`, { method: 'PATCH' });
        
        alert('Статус заказа успешно возвращен на "Готов к выдаче"!');
        await fetchAndRenderHistory(); // Обновляем историю в модальном окне
        await fetchAndRenderIssueList(); // Обновляем список готовых к выдаче на основной вкладке
        
    } catch (error) {
        alert(`Ошибка возврата статуса: ${error.message}`);
    } finally {
        hideLoader(); 
    }
}

// --- Поиск по списку Готовых к Выдаче ---
function handleIssueSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim();
    document.querySelectorAll('#issue-list .client-group').forEach(group => {
        const name = group.dataset.clientName || '';
        const code = group.dataset.clientCode || '';
        const phone = group.dataset.clientPhone || '';
        const tracks = group.dataset.trackCodes || '';

        const isMatch = name.includes(searchTerm) || 
                        code.includes(searchTerm) || 
                        phone.includes(searchTerm) || 
                        tracks.includes(searchTerm);
        
        group.style.display = isMatch ? 'block' : 'none';
    });
}

// === КОНЕЦ МОДУЛЯ ВЫДАЧА ===

// =================================================================
// МОДУЛЬ: РАСХОДЫ (Владелец/Кассир) (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг вкладки "Расходы" ---
async function renderExpensesTab() {
    console.log("[Render] renderExpensesTab: Start");
    const today = new Date().toISOString().split('T')[0];
    const pane = document.getElementById('tab-expenses');
    if (!pane) return;

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div id="expenses-container" class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold text-gray-800">Учет расходов</h2>
                <button id="add-expense-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 text-sm">➕ Добавить расход</button>
            </div>
            
            <div class="flex flex-wrap gap-4 items-end p-4 bg-gray-50 rounded-lg mb-4 border">
                <div>
                    <label for="expense-start-date" class="block text-sm font-medium text-gray-700">С</label>
                    <input type="date" id="expense-start-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                <div>
                    <label for="expense-end-date" class="block text-sm font-medium text-gray-700">По</label>
                    <input type="date" id="expense-end-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                ${(currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) ? `
                <div>
                    <label for="expense-location-filter" class="block text-sm font-medium text-gray-700">Филиал</label>
                    <select id="expense-location-filter" class="mt-1 p-2 border rounded-md bg-white text-sm w-full">
                        <option value="">-- Все филиалы --</option>
                        ${companyLocations.map(loc => `<option value="${loc.id}">${loc.name}</option>`).join('')}
                    </select>
                </div>
                ` : ''}
                <button id="filter-expenses-btn" class="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700">Показать</button>
            </div>
            
            <div class="mb-4">
                <input type="search" id="expenses-search-input" placeholder="🔍 Поиск по типу, сумме, примечанию..." class="w-full p-2 border rounded-lg">
            </div>
            
            <div id="expenses-list" class="space-y-3">
                <p class="text-gray-500">Нажмите "Показать", чтобы загрузить расходы за период.</p>
            </div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const containerDiv = document.getElementById('expenses-container');
    if (containerDiv) {
        // Кнопка "Добавить расход"
        const addBtn = document.getElementById('add-expense-btn');
        if (addBtn) addBtn.addEventListener('click', () => openExpenseModal());

        // Кнопка "Показать" (фильтр)
        const filterBtn = document.getElementById('filter-expenses-btn');
        if (filterBtn) filterBtn.addEventListener('click', fetchAndRenderExpenses); 
        
        // Поле поиска
        const searchInput = document.getElementById('expenses-search-input');
        if (searchInput) searchInput.addEventListener('input', handleExpensesSearch);
        
        // Список (для делегирования действий)
        const listDiv = document.getElementById('expenses-list');
        if (listDiv) listDiv.addEventListener('click', handleExpenseActions);

        // ДОБАВИТЬ ЭТОТ СЛУШАТЕЛЬ:
        const locationFilter = document.getElementById('expense-location-filter');
        if (locationFilter) {
            locationFilter.addEventListener('change', fetchAndRenderExpenses);
            console.log("[Listener OK] Added change to #expense-location-filter");
        }

        // Загружаем расходы за сегодня при первой загрузке (по умолчанию)
        await fetchAndRenderExpenses();

    } else {
        console.error("!!! renderExpensesTab: #expenses-container not found.");
    }

    console.log("[Render] renderExpensesTab: End");
}


// --- Загрузка и отображение списка Расходов ---
// index.html (ЗАМЕНИТЬ ЭТОЙ ФУНКЦИЕЙ СТАРУЮ fetchAndRenderExpenses)

async function fetchAndRenderExpenses() {
    console.log("[Fetch] fetchAndRenderExpenses: Start");
    const listDiv = document.getElementById('expenses-list');
    const startDate = document.getElementById('expense-start-date')?.value;
    const endDate = document.getElementById('expense-end-date')?.value;
    if (!listDiv || !startDate || !endDate) return;

    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка расходов...</p>';
    showLoader(); 

    try {
        // --- ИСПРАВЛЕНИЕ: Собираем параметры, включая location_id ---
        const params = new URLSearchParams({
            start_date: startDate,
            end_date: endDate
        });

        // Добавляем location_id, если он выбран Владельцем
        // (Ищем фильтр expense-location-filter)
        const locationSelect = document.getElementById('expense-location-filter');
        if (locationSelect && locationSelect.value) { // (Этот select существует, только если роль = Владелец)
            params.append('location_id', locationSelect.value);
        }

        const url = `/api/expenses?${params.toString()}`;
        console.log("[Fetch Expenses] Requesting URL:", url);
        // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

        // Запрос к эндпоинту /api/expenses
        const expenses = await apiFetch(url);

        if (!expenses || expenses.length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">Расходов за выбранный период (и филиал) не найдено.</p>';
        } else {
            // Генерируем HTML
            listDiv.innerHTML = expenses.map(exp => {

                let employeeName = 'Общий (Владелец)'; 
                if (exp.shift && exp.shift.employee && exp.shift.employee.full_name) {
                    employeeName = exp.shift.employee.full_name; 
                }

                // Проверка, может ли ТЕКУЩИЙ пользователь редактировать
                const canEdit = (currentUser.role === 'Владелец') || 
                                (exp.shift && exp.shift.end_time === null); 

                // Проверка, может ли ТЕКУЩИЙ пользователь удалять
                const canDelete = (currentUser.role === 'Владелец') && 
                                (exp.shift === null || exp.shift.end_time === null); 

                return `
                    <div class="p-3 bg-gray-50 rounded-md border flex flex-wrap justify-between items-center gap-2 expense-item"
                         data-notes="${(exp.notes || '').toLowerCase()}"
                         data-type="${(exp.expense_type?.name || '').toLowerCase()}">

                        <div class="flex-grow min-w-[200px]">
                            <p class="font-bold text-lg">${exp.expense_type?.name || 'Тип не указан'} — <span class="text-red-600">${exp.amount.toFixed(2)} сом</span></p>
                            <p class="text-sm text-gray-700">${exp.notes || 'Без примечания'}</p>
                            <p class="text-xs text-gray-500">
                                ${new Date(exp.created_at).toLocaleString()} | Сотрудник: ${employeeName}
                            </p>
                        </div>

                        <div class="flex-shrink-0 flex gap-2">
                            ${canEdit ? `
                            <button data-expense-json='${JSON.stringify(exp)}' 
                                    class="edit-expense-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">
                                Изменить
                            </button>
                            ` : ''}

                            ${canDelete ? `
                            <button data-expense-id="${exp.id}" 
                                    data-expense-name="${exp.expense_type?.name}"
                                    class="delete-expense-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">
                                Удалить
                            </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        console.log("[Fetch] fetchAndRenderExpenses: Success");
    } catch (e) {
        console.error("!!! [Fetch] fetchAndRenderExpenses: Error", e);
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки расходов: ${e.message}</p>`;
    } finally {
        hideLoader();
    }
}

// --- Обработка действий (Редактирование, Удаление) ---
function handleExpenseActions(e) {
    const editBtn = e.target.closest('.edit-expense-btn');
    const deleteBtn = e.target.closest('.delete-expense-btn');
    
    if (editBtn) {
        try {
            const expenseData = JSON.parse(editBtn.dataset.expenseJson);
            openExpenseModal(expenseData); // TODO: Создать openExpenseModal
            // alert(`Редактирование расхода: ${expenseData.id}. Открытие модального окна.`);
        } catch (e) {
            console.error("Error parsing expense data:", e);
        }
    } else if (deleteBtn) {
        const expenseId = deleteBtn.dataset.expenseId;
        const expenseName = deleteBtn.dataset.expenseName;
        if (confirm(`Удалить расход "${expenseName}"? Это действие НЕОБРАТИМО и требует пароля Владельца!`)) {
            const password = prompt("Введите пароль Владельца для подтверждения удаления:");
            if (password) {
                handleDeleteExpense(expenseId, password);
            } else if (password !== null) {
                alert("Удаление отменено: пароль не введен.");
            }
        }
    }
}

// --- Функция удаления расхода ---
async function handleDeleteExpense(expenseId, password) {
    console.log(`[Delete] handleDeleteExpense: Deleting ID ${expenseId}`);
    showLoader();
    try {
        // Отправляем DELETE запрос (пароль передается как Query параметр)
        await apiFetch(`/api/expenses/${expenseId}?password=${encodeURIComponent(password)}`, { 
            method: 'DELETE' 
        });
        alert("Расход успешно удален!");
        await fetchAndRenderExpenses(); // Обновляем список
    } catch (err) {
        console.error("!!! [Delete] handleDeleteExpense: Error", err);
        alert(`Ошибка удаления расхода: ${err.message}`);
    } finally {
        hideLoader();
    }
}

// --- Функция поиска по расходам ---
function handleExpensesSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim();
    document.querySelectorAll('#expenses-list .expense-item').forEach(item => {
        const itemType = item.dataset.type || '';
        const itemNotes = item.dataset.notes || '';
        const itemContent = item.textContent?.toLowerCase() || '';

        const isMatch = itemType.includes(searchTerm) || itemNotes.includes(searchTerm) || itemContent.includes(searchTerm);
        item.style.display = isMatch ? 'flex' : 'none';
    });
}

// --- Функция: Открытие модального окна добавления/редактирования расхода ---
// index.html (Полностью заменяет openExpenseModal)

async function openExpenseModal(expense = null) {
    // Проверку на активную смену для СОТРУДНИКА оставим на бэкенде.
    // Владелец может открывать всегда.
    
    const expenseModal = document.getElementById('expense-modal');
    const modalContent = expenseModal.querySelector('.modal-content');
    const isEdit = expense !== null; // Редактирование пока не меняем
    
    modalContent.innerHTML = '<p class="text-center p-8">Загрузка данных...</p>';
    openModal('expense-modal');
    showLoader(); 

    try {
        // --- ЗАГРУЖАЕМ ДАННЫЕ ПАРАЛЛЕЛЬНО ---
        const [typesData, activeShiftsData] = await Promise.allSettled([
            // Загружаем типы расходов (из кэша или API)
            (companyExpenseTypes.length > 0) ? Promise.resolve(companyExpenseTypes) : apiFetch('/api/expense_types'),
            // Загружаем ВСЕ активные смены компании (для Владельца)
            (currentUser.role === 'Владелец') ? fetchActiveShiftsForCompany() : Promise.resolve([]) 
        ]);

        // Обрабатываем типы расходов
        if (typesData.status === 'fulfilled') {
            companyExpenseTypes = typesData.value;
        } else {
            throw new Error(`Не удалось загрузить типы расходов: ${typesData.reason?.message || typesData.reason}`);
        }
        
        // Обрабатываем активные смены (только для Владельца)
        let activeShifts = [];
        if (activeShiftsData.status === 'fulfilled') {
            activeShifts = activeShiftsData.value;
        } else {
            // Ошибка загрузки смен не критична, Владелец сможет добавить общий расход
            console.warn("Не удалось загрузить активные смены для выбора:", activeShiftsData.reason);
        }
        
        // Генерируем опции для Типов Расходов
        const typesOptions = companyExpenseTypes
            .map(t => `<option value="${t.id}" ${isEdit && expense.expense_type_id === t.id ? 'selected' : ''}>${t.name}</option>`)
            .join('');

        // --- ГЕНЕРИРУЕМ ВЫПАДАЮЩИЙ СПИСОК СМЕН ДЛЯ ВЛАДЕЛЬЦА ---
        let shiftSelectorHtml = '';
        if (currentUser.role === 'Владелец') {
            if (activeShifts.length > 0) {
                // Если есть активные смены, предлагаем выбор
                const shiftOptions = activeShifts.map(shift => {
                    const locationName = companyLocations.find(loc => loc.id === shift.location_id)?.name || `Филиал ${shift.location_id}`;
                    const employeeName = shift.employee?.full_name || 'Неизвестен';
                    return `<option value="${shift.id}">Смена #${shift.id} (${locationName} - ${employeeName})</option>`;
                }).join('');
                
                shiftSelectorHtml = `
                    <div>
                        <label for="expense-shift-select" class="block text-sm font-medium text-gray-700">Привязать к смене:</label>
                        <select id="expense-shift-select" name="shift_id" class="mt-1 w-full p-2 border rounded bg-white">
                            <option value="">-- Общий расход (без привязки) --</option>
                            ${shiftOptions}
                        </select>
                    </div>
                `;
            } else {
                // Если активных смен нет, сообщаем об этом
                shiftSelectorHtml = `<p class="text-sm text-gray-500">Нет активных смен для привязки. Расход будет добавлен как общий.</p>`;
            }
        } else {
            // Для обычного сотрудника показываем ID его текущей смены
             shiftSelectorHtml = `<p class="text-sm text-gray-600">Смена ID: ${activeShift?.id ?? 'N/A'}</p>`;
        }
        // --- КОНЕЦ ГЕНЕРАЦИИ СПИСКА СМЕН ---

        modalContent.innerHTML = `
            <div class="flex justify-between items-start">
                <h3 class="text-2xl font-bold mb-4">${isEdit ? 'Редактировать расход' : 'Добавить расход'}</h3>
                <button onclick="closeModal('expense-modal')" class="text-2xl font-bold">&times;</button>
            </div>
            <form id="expense-form" data-expense-id="${isEdit ? expense.id : ''}" class="space-y-4">
                
                ${shiftSelectorHtml}
                
                <div>
                    <label class="block text-sm font-medium text-gray-700">Тип расхода *</label>
                    <select name="expense_type_id" class="mt-1 w-full p-2 border rounded bg-white" required>${typesOptions}</select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Сумма (сом) *</label>
                    <input type="number" step="0.01" name="amount" class="mt-1 w-full p-2 border rounded" value="${isEdit ? expense.amount : ''}" required>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Примечание</label>
                    <textarea name="notes" class="mt-1 w-full p-2 border rounded">${isEdit ? expense.notes || '' : ''}</textarea>
                </div>
                <div class="flex gap-4 mt-6">
                    <button type="button" onclick="closeModal('expense-modal')" class="w-full bg-gray-200 py-2 rounded">Отмена</button>
                    <button type="submit" class="w-full bg-green-600 text-white py-2 rounded">Сохранить</button>
                </div>
            </form>
        `;
        
        // Привязываем обработчик submit к форме
        document.getElementById('expense-form')?.addEventListener('submit', handleSaveExpense);
        
    } catch(err) {
        alert(`Ошибка загрузки данных для расхода: ${err.message}`);
        closeModal('expense-modal');
    } finally {
        hideLoader();
    }
}

// --- Функция сохранения расхода ---
// index.html (Полностью заменяет handleSaveExpense)

async function handleSaveExpense(e) {
    e.preventDefault();
    const form = e.target;
    const expenseId = form.dataset.expenseId; // Исправлено с expense-id
    const isEdit = !!expenseId;
    
    const url = isEdit ? `/api/expenses/${expenseId}` : '/api/expenses'; 
    const method = isEdit ? 'PATCH' : 'POST'; 
    
    const payload = {
        expense_type_id: parseInt(form.elements.expense_type_id.value),
        amount: parseFloat(form.elements.amount.value),
        notes: form.elements.notes.value || null
        // shift_id будет добавлен ниже, если выбран
    };

    // --- ДОБАВЛЕНИЕ SHIFT_ID ДЛЯ ВЛАДЕЛЬЦА ---
    if (currentUser.role === 'Владелец' && !isEdit) { // Добавляем shift_id только при СОЗДАНИИ Владельцем
        const shiftSelect = document.getElementById('expense-shift-select');
        if (shiftSelect && shiftSelect.value) { // Если select существует и выбрано значение (не пустое)
            payload.shift_id = parseInt(shiftSelect.value); 
        } else {
            payload.shift_id = null; // Если выбрано "-- Общий расход --" или смен не было
        }
    }
    // Для обычных сотрудников shift_id определяется на бэкенде
    // При редактировании shift_id не меняем через эту форму
    // --- КОНЕЦ ДОБАВЛЕНИЯ SHIFT_ID ---

    if (isNaN(payload.amount) || payload.amount <= 0 || isNaN(payload.expense_type_id)) {
        alert("Пожалуйста, введите корректную сумму и выберите тип расхода.");
        return;
    }

    showLoader(); 
    try {
        const response = await apiFetch(url, {
            method: method,
            body: JSON.stringify(payload)
        });
        
        alert(isEdit ? 'Расход обновлен!' : 'Расход успешно добавлен!');
        closeModal('expense-modal');
        await fetchAndRenderExpenses(); // Обновляем список на вкладке
        
    } catch (err) {
        alert(`Ошибка: ${err.message}`);
    } finally {
        hideLoader();
    }
}

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ МОДУЛЬ: ОТЧЕТЫ)

// =================================================================
// МОДУЛЬ: ОТЧЕТЫ (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг главной вкладки "Отчеты" (создает под-вкладки) ---
function renderReportsTab() {
    console.log("[Render] renderReportsTab: Start");
    const pane = document.getElementById('tab-reports');
    if (!pane) return;

    const userPerms = new Set(currentUser.permissions || []);
    let subTabsHtml = '';
    let subContentHtml = '';
    let firstSubTabName = null; // Имя первой доступной под-вкладки

    // Создаем под-вкладки на основе прав
    if (userPerms.has('view_shift_report')) {
        subTabsHtml += '<button data-subtab="shift-report" class="report-subtab-btn tab-btn">Отчет по смене</button>';
        subContentHtml += '<div id="subtab-shift-report" class="report-subtab-pane tab-pane"></div>';
        if (!firstSubTabName) firstSubTabName = 'shift-report';
    }
    if (userPerms.has('view_full_reports')) {
        subTabsHtml += '<button data-subtab="summary-report" class="report-subtab-btn tab-btn">Сводный отчет</button>';
        subContentHtml += '<div id="subtab-summary-report" class="report-subtab-pane tab-pane"></div>';
        if (!firstSubTabName) firstSubTabName = 'summary-report';
    }

    // Генерируем HTML
    pane.innerHTML = `
        <div class="border-b border-gray-200">
            <nav class="-mb-px flex space-x-8" id="reports-subtabs">
                ${subTabsHtml.replaceAll('class="tab-btn"', 'class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700"')}
            </nav>
        </div>
        <div id="reports-subtab-content" class="mt-6">
            ${subContentHtml}
        </div>
    `;

    // Привязываем слушатель к под-вкладкам
    const subtabsContainer = document.getElementById('reports-subtabs');
    if (subtabsContainer) {
        subtabsContainer.addEventListener('click', e => {
            const tabButton = e.target.closest('.report-subtab-btn');
            if (tabButton) {
                activateReportSubTab(tabButton.dataset.subtab); // Активируем под-вкладку
            }
        });
    }

    // Рендерим содержимое под-вкладок (они теперь точно найдутся)
    if (document.getElementById('subtab-shift-report')) {
        renderShiftReportSubTab();
    }
    if (document.getElementById('subtab-summary-report')) {
        renderSummaryReportSubTab();
    }
    
    // Активируем первую доступную под-вкладку
    if (firstSubTabName) {
        activateReportSubTab(firstSubTabName);
    }
}

// --- Активация под-вкладок ---
function activateReportSubTab(tabName) {
    const tabsContainer = document.getElementById('reports-subtabs');
    const contentContainer = document.getElementById('reports-subtab-content');
    if (!tabsContainer || !contentContainer) return;

    tabsContainer.querySelectorAll('.report-subtab-btn').forEach(btn => {
        btn.classList.remove('border-indigo-500', 'text-indigo-600');
        btn.classList.add('border-transparent', 'text-gray-500');
    });
    
    const activeBtn = tabsContainer.querySelector(`[data-subtab="${tabName}"]`);
    if (activeBtn) {
        activeBtn.classList.add('border-indigo-500', 'text-indigo-600');
        activeBtn.classList.remove('border-transparent', 'text-gray-500');
    }

    contentContainer.querySelectorAll('.report-subtab-pane').forEach(pane => {
        pane.classList.add('hidden');
    });
    
    const activePane = document.getElementById(`subtab-${tabName}`);
    if (activePane) {
        activePane.classList.remove('hidden');
    }
}

// --- Рендеринг под-вкладки "Отчет по смене" ---
function renderShiftReportSubTab() {
    const pane = document.getElementById('subtab-shift-report');
    if (!pane) return;

    // --- ИСПРАВЛЕНИЕ: HTML для фильтра филиалов (только Владелец) ---
    // (companyLocations теперь гарантированно загружен из initializeMainAppUI)
    let locationFilterHtml = '';
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            // Предварительно выбираем основной филиал Владельца
            `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`
        ).join('');
        
        locationFilterHtml = `
            <div class="flex-shrink-0">
                <label for="shift-report-location-filter" class="text-xs font-medium text-gray-700">Филиал:</label>
                <select id="shift-report-location-filter" class="rounded-md border-gray-300 p-1.5 text-sm bg-white shadow-sm w-40">
                    ${locationOptions}
                </select>
            </div>
        `;
        console.log("[Render ShiftReport] Фильтр филиалов добавлен.");
    }
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md max-w-2xl mx-auto">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold">Отчет по текущей смене</h2>
                <div class="flex items-center gap-4">
                    ${locationFilterHtml} 
                    <button id="refresh-report-btn" title="Обновить отчет" class="text-2xl text-gray-500 hover:text-indigo-600">&circlearrowright;</button>
                </div>
            </div>
            <div id="shift-report-content" class="space-y-3">
                <p class="animate-pulse">Загрузка отчета...</p>
            </div>
        </div>
    `;
    
    document.getElementById('refresh-report-btn')?.addEventListener('click', fetchAndRenderCurrentShiftReport);
    // Добавляем слушатель к новому фильтру (если он есть)
    document.getElementById('shift-report-location-filter')?.addEventListener('change', fetchAndRenderCurrentShiftReport);

    fetchAndRenderCurrentShiftReport(); // Загружаем при первом рендере
}

// --- Загрузка отчета по ТЕКУЩЕЙ смене ---
async function fetchAndRenderCurrentShiftReport() {
    const contentDiv = document.getElementById('shift-report-content');
    if (!contentDiv) return;
    contentDiv.innerHTML = '<p class="animate-pulse">Обновление отчета...</p>';
    showLoader();

    // --- ИСПРАВЛЕНИЕ: Определяем, какой URL вызывать ---
    let url = ''; 
    
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('shift-report-location-filter');
        let locationIdToFetch = currentUser.location_id; // По умолчанию филиал Владельца

        if (locationSelect && locationSelect.value) {
            // Если Владелец выбрал филиал в списке
            locationIdToFetch = locationSelect.value;
        }
        
        if (locationIdToFetch) {
             url = `/api/reports/shift/location/${locationIdToFetch}`;
        } else {
             // Если Владелец не привязан к филиалу и ничего не выбрал
             contentDiv.innerHTML = `<p class="text-yellow-500 font-semibold">Ошибка: Владелец не привязан к филиалу. Выберите филиал из списка (если он есть).</p>`;
             hideLoader();
             return;
        }
        
    } else {
        // Обычный сотрудник (не Владелец)
        url = '/api/reports/shift/current'; // Бэкенд сам найдет его смену
    }
    
    console.log("[Shift Report] Requesting URL:", url);
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    try {
        const report = await apiFetch(url); 

        contentDiv.innerHTML = `
            <div class="text-sm text-gray-500">
                <p><strong>Сотрудник:</strong> ${report.employee_name || '?'}</p>
                <p><strong>Филиал:</strong> ${report.location_name || '?'}</p>
                <p><strong>Смена открыта:</strong> ${new Date(report.shift_start_time).toLocaleString()}</p>
            </div>
            <div class="border-t pt-4 mt-4 space-y-2 text-lg">
                <div class="flex justify-between"><span>Наличные на начало:</span> <span class="font-semibold">${report.starting_cash.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-green-600"><span>Приход наличными (+):</span> <span class="font-semibold">${report.cash_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-blue-600"><span>Приход по карте (+):</span> <span class="font-semibold">${report.card_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-red-600"><span>Расходы (операционные) (-):</span> <span class="font-semibold">${report.total_expenses.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-yellow-600"><span>Возвраты (-):</span> <span class="font-semibold">${report.total_returns.toFixed(2)} сом</span></div>
            </div>
            <div class="border-t pt-4 mt-4">
                <div class="flex justify-between text-xl font-bold">
                    <span>Итого в кассе (расчет):</span>
                    <span>${report.calculated_cash.toFixed(2)} сом</span>
                </div>
            </div>
        `;
    } catch (e) {
        // Если 404 - смены нет, если 403 - нет прав
        contentDiv.innerHTML = `<p class="text-red-500 font-semibold">Ошибка загрузки отчета: ${e.message}</p>`;
    } finally {
        hideLoader();
    }
}

// --- Рендеринг под-вкладки "Сводный отчет" ---
function renderSummaryReportSubTab() {
    const pane = document.getElementById('subtab-summary-report');
    if (!pane) return;
    const today = new Date().toISOString().split('T')[0];

    // Фильтр филиалов (только для Владельца)
    let locationFilterHtml = '';
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            `<option value="${loc.id}">${loc.name}</option>`
        ).join('');
        locationFilterHtml = `
            <div>
                <label for="summary-location-filter" class="block text-sm font-medium text-gray-700">Филиал:</label>
                <select id="summary-location-filter" class="mt-1 p-2 border rounded-md bg-white text-sm w-full">
                    <option value="">-- Все филиалы --</option>
                    ${locationOptions}
                </select>
            </div>
        `;
    }

    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md max-w-3xl mx-auto">
            <h2 class="text-2xl font-bold mb-4">Сводный отчет</h2>
            <div class="flex flex-wrap gap-4 items-end p-4 bg-gray-50 rounded-lg mb-4 border">
                <div>
                    <label for="summary-start-date" class="block text-sm font-medium">С</label>
                    <input type="date" id="summary-start-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                <div>
                    <label for="summary-end-date" class="block text-sm font-medium">По</label>
                    <input type="date" id="summary-end-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                ${locationFilterHtml} 
                <button id="generate-summary-report-btn" class="bg-blue-600 text-white py-2 px-4 rounded-md">Сформировать</button>
            </div>
            <div id="summary-report-content">
                <p class="text-gray-500">Выберите период и нажмите "Сформировать".</p>
            </div>
        </div>
    `;
    
    document.getElementById('generate-summary-report-btn')?.addEventListener('click', fetchAndRenderSummaryReport);
}

// --- Загрузка Сводного отчета ---
async function fetchAndRenderSummaryReport() {
    const contentDiv = document.getElementById('summary-report-content');
    if (!contentDiv) return;
    contentDiv.innerHTML = '<p class="animate-pulse">Формирование отчета...</p>';
    showLoader();

    const startDate = document.getElementById('summary-start-date').value;
    const endDate = document.getElementById('summary-end-date').value;
    
    const params = new URLSearchParams({
        start_date: startDate,
        end_date: endDate
    });
    
    // Добавляем location_id, если он выбран Владельцем
    const locationSelect = document.getElementById('summary-location-filter');
    if (locationSelect && locationSelect.value) {
        params.append('location_id', locationSelect.value);
    }
    
    try {
        const response = await apiFetch(`/api/reports/summary?${params.toString()}`);
        const summary = response.summary;

        let expensesHtml = Object.entries(summary.expenses_by_type)
            .map(([type, amount]) => `<div class="flex justify-between text-sm text-gray-700 ml-4"><span>- ${type}:</span><span>${amount.toFixed(2)} сом</span></div>`)
            .join('');
        if (!expensesHtml) expensesHtml = '<p class="text-sm text-gray-500 ml-4">Расходов за период нет.</p>';
        
        let shiftsHtml = '<h3 class="text-xl font-bold mt-6 mb-2">Закрытые смены за период</h3>';
        if (!summary.shifts || summary.shifts.length === 0) {
            shiftsHtml += '<p class="text-gray-500">Закрытых смен за этот период не найдено.</p>';
        } else {
            shiftsHtml += summary.shifts.map(shift => {
                // Ищем имя филиала в кэше
                const locationName = shift.location?.name || 'Филиал ?'; // Используем имя из ответа API
                return `
                    <div class="p-2 border rounded-md hover:bg-gray-50 flex justify-between items-center text-sm">
                        <div>
                            <p><strong>${shift.employee?.full_name || 'Неизвестен'}</strong> @ ${locationName}</p>
                            <p class="text-xs text-gray-500">${new Date(shift.start_time).toLocaleString()} - ${shift.end_time ? new Date(shift.end_time).toLocaleString() : 'АКТИВНА'}</p>
                        </div>
                        <button class="view-shift-report-btn bg-blue-100 text-blue-800 text-xs px-3 py-1 rounded-full" data-shift-id="${shift.id}">Подробнее</button>
                    </div>
                `
            }).join('');
        }

        // Рендерим весь отчет
        contentDiv.innerHTML = `
            <div class="border-t pt-4 mt-4 space-y-3 text-lg">
                <div class="flex justify-between text-green-600"><span>Общая выручка (+):</span><span class="font-bold">${summary.total_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-sm text-gray-700 ml-4"><span>(Наличными):</span><span>${summary.total_cash_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-sm text-gray-700 ml-4"><span>(Картой):</span><span>${summary.total_card_income.toFixed(2)} сом</span></div>
                
                <div class="flex justify-between text-red-600 mt-4"><span>Общие расходы (-):</span><span class="font-bold">${summary.total_expenses.toFixed(2)} сом</span></div>
                ${expensesHtml}
            </div>
            <div class="border-t pt-4 mt-6">
                <div class="flex justify-between text-2xl font-bold ${summary.net_profit >= 0 ? 'text-green-700' : 'text-red-700'}">
                    <span>Чистая прибыль:</span><span>${summary.net_profit.toFixed(2)} сом</span>
                </div>
            </div>
            ${shiftsHtml}
        `;

        // Привязываем слушатели к кнопкам "Подробнее"
        contentDiv.querySelectorAll('.view-shift-report-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const shiftId = e.target.dataset.shiftId;
                showPastShiftReportModal(shiftId);
            });
        });
    } catch (e) {
        contentDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки отчета: ${e.message}</p>`;
    } finally {
        hideLoader();
    }
}

// --- Показ модального окна с отчетом по ПРОШЛОЙ смене ---
async function showPastShiftReportModal(shiftId) {
    // Убедимся, что модальное окно #shift-report-modal существует в HTML
    const modal = document.getElementById('shift-report-modal'); 
    if (!modal) return console.error("Модальное окно #shift-report-modal не найдено!");
    const contentDiv = modal.querySelector('.modal-content');
    if (!contentDiv) return console.error("Контейнер .modal-content не найден!");
    
    contentDiv.innerHTML = '<p class="animate-pulse">Загрузка отчета по смене...</p>';
    openModal('shift-report-modal');
    showLoader(); 

    try {
        const report = await apiFetch(`/api/reports/shift/${shiftId}`);

        contentDiv.innerHTML = `
            <div class="flex justify-between items-start">
                <h3 class="text-2xl font-bold mb-4">Отчет по смене №${report.shift_id}</h3>
                <button onclick="closeModal('shift-report-modal')" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="text-sm text-gray-500">
                <p><strong>Сотрудник:</strong> ${report.employee_name}</p>
                <p><strong>Филиал:</strong> ${report.location_name}</p>
                <p><strong>Период:</strong> ${new Date(report.shift_start_time).toLocaleString()} - ${report.shift_end_time ? new Date(report.shift_end_time).toLocaleString() : 'АКТИВНА'}</p>
            </div>
            <div class="border-t pt-4 mt-4 space-y-2 text-lg">
                <div class="flex justify-between"><span>Наличные на начало:</span> <span class="font-semibold">${report.starting_cash.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-green-600"><span>Приход наличными (+):</span> <span class="font-semibold">${report.cash_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-blue-600"><span>Приход по карте (+):</span> <span class="font-semibold">${report.card_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-red-600"><span>Расходы (операционные) (-):</span> <span class="font-semibold">${report.total_expenses.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-yellow-600"><span>Возвраты (-):</span> <span class="font-semibold">${report.total_returns.toFixed(2)} сом</span></div>
            </div>
            <div class="border-t pt-4 mt-4 space-y-2">
                <div class="flex justify-between text-xl font-bold"><span>Итого в кассе (расчет):</span><span>${report.calculated_cash.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-lg"><span>В кассе по факту (при закрытии):</span><span class="font-semibold">${report.actual_closing_cash?.toFixed(2) || 'Смена не закрыта'} сом</span></div>
                ${report.discrepancy !== null ? `
                    <div class="flex justify-between text-xl font-bold ${report.discrepancy === 0 ? 'text-green-600' : 'text-red-600'}">
                        <span>Расхождение:</span>
                        <span>${report.discrepancy.toFixed(2)} сом</span>
                    </div>
                ` : ''}
            </div>
        `;
    } catch (e) {
        contentDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки отчета: ${e.message}</p>`;
    } finally {
        hideLoader();
    }
}
// === КОНЕЦ МОДУЛЯ ОТЧЕТЫ ===


</script>
</body>
</html>
